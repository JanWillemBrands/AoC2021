topLevelDeclaration = statements? .// WHITESPACE AND COMMENTwhitespace : /\s+/.                             // simplified whitespace//whitespace = whitespaceItem whitespace? .//whitespaceItem = lineBreak .//whitespaceItem = inlineSpace .//whitespaceItem = comment .//whitespaceItem = multilineComment .//whitespaceItem = U+0000, U+000B, or U+000C. 	// NULL or \0 or \u{0000}, VERTICAL TAB or \u{000B}, or FORM FEED or \u{000C}//lineBreak = U+000A 				            // NEWLINE or \n or \u{000A}//lineBreak = U+000D 				            // CARRIAGE RETURN or \r or \u{000D}//lineBreak = U+000D followed by U+000A//inlineSpaces = inlineSpace inlineSpaces? .//inlineSpace = U+0009 or U+0020 				// HORIZONTAL TAB or \t or \u{0009}, SPACE or \u{0020}comment : /\/\/.*/.                             // simplified single line comment// comment = "//" commentText lineBreak .multilineComment : /\/\*(?s).*?\*\// .          // simplified multiple line comment//multilineComment = "/*" multilineCommentText "*/" .//commentText = commentTextItem commentText? .//commentTextItem = Any Unicode scalar value except U+000A or U+000D//multilineCommentText = multilineCommentTextItem multilineCommentText? .//multilineCommentTextItem = multilineComment .//multilineCommentTextItem = commentTextItem .//multilineCommentTextItem = Any Unicode scalar value except "/*" or "*/"//IDENTIFIERSplainIdentifier             = /\p{XID_Start}\p{XID_Continue}*/ .       // simplified using Unicode PropertiesescapedIdentifier           = /`\p{XID_Start}\p{XID_Continue}*`/ .implicitParameterName       = /\$[0-9]+/ .propertyWrapperProjection   = /\$\p{XID_Continue}+/ .identifier = plainIdentifier | escapedIdentifier | implicitParameterName | propertyWrapperProjection .  // moved terminal definitions ahead of their usage//identifier = identifierHead identifierCharacters? .//identifier = "`" identifierHead identifierCharacters? "`" .//identifier = implicitParameterName .//identifier = propertyWrapperProjection .identifierList = identifier | identifier "," identifierList .//identifierList = identifier { "," identifier } .                  // EBNF// these are covered by XID_Start//identifierHead = Upper or lowercase letter A through Z//identifierHead = "_" .//identifierHead = U+00A8, U+00AA, U+00AD, U+00AF, U+00B2ÐU+00B5, or U+00B7ÐU+00BA//identifierHead = U+00BCÐU+00BE, U+00C0ÐU+00D6, U+00D8ÐU+00F6, or U+00F8ÐU+00FF//identifierHead = U+0100ÐU+02FF, U+0370ÐU+167F, U+1681ÐU+180D, or U+180FÐU+1DBF//identifierHead = U+1E00ÐU+1FFF//identifierHead = U+200BÐU+200D, U+202AÐU+202E, U+203FÐU+2040, U+2054, or U+2060ÐU+206F//identifierHead = U+2070ÐU+20CF, U+2100ÐU+218F, U+2460ÐU+24FF, or U+2776ÐU+2793//identifierHead = U+2C00ÐU+2DFF or U+2E80ÐU+2FFF//identifierHead = U+3004ÐU+3007, U+3021ÐU+302F, U+3031ÐU+303F, or U+3040ÐU+D7FF//identifierHead = U+F900ÐU+FD3D, U+FD40ÐU+FDCF, U+FDF0ÐU+FE1F, or U+FE30ÐU+FE44//identifierHead = U+FE47ÐU+FFFD//identifierHead = U+10000ÐU+1FFFD, U+20000ÐU+2FFFD, U+30000ÐU+3FFFD, or U+40000ÐU+4FFFD//identifierHead = U+50000ÐU+5FFFD, U+60000ÐU+6FFFD, U+70000ÐU+7FFFD, or U+80000ÐU+8FFFD//identifierHead = U+90000ÐU+9FFFD, U+A0000ÐU+AFFFD, U+B0000ÐU+BFFFD, or U+C0000ÐU+CFFFD//identifierHead = U+D0000ÐU+DFFFD or U+E0000ÐU+EFFFD// These are covered by XID_Continue//identifierCharacter = Digit 0 through 9//identifierCharacter = U+0300ÐU+036F, U+1DC0ÐU+1DFF, U+20D0ÐU+20FF, or U+FE20ÐU+FE2F//identifierCharacter = identifierHead .//identifierCharacters = identifierCharacter identifierCharacters? .//implicitParameterName = "$" decimalDigits .//propertyWrapperProjection = "$" identifierCharacters .// REGULAR EXPRESSIONSregularExpressionLiteral = /#*\/(?:[^\/\\]|\\.)*\/#*/ .     // this captures a legal Swift regex that has already been validated by the compiler//regularExpressionLiteral = regularExpressionLiteralOpeningDelimiter regularExpression regularExpressionLiteralClosingDelimiter .//regularExpression = Any regular expression        // WHOAAAAAA//regularExpressionLiteralOpeningDelimiter = extendedRegularExpressionLiteralDelimiter? "/" .//regularExpressionLiteralClosingDelimiter = "/" extendedRegularExpressionLiteralDelimiter? .//extendedRegularExpressionLiteralDelimiter = "#" extendedRegularExpressionLiteralDelimiter? .// LITERALSbinaryLiteral: /-?0b[0-1][0-1_]*/ .//binaryLiteral = "0b" binaryDigit binaryLiteralCharacters? .//binaryDigit = Digit 0 or 1//binaryLiteralCharacter = binaryDigit | "_" .//binaryLiteralCharacters = binaryLiteralCharacter binaryLiteralCharacters? .octalLiteral: /-?0o[0-7][0-7_]*/ .//octalLiteral = "0o" octalDigit octalLiteralCharacters? .//octalDigit = Digit 0 through 7//octalLiteralCharacter = octalDigit | "_" .//octalLiteralCharacters = octalLiteralCharacter octalLiteralCharacters? .decimalLiteral: /-?[0-9][0-9_]*/ .//decimalLiteral = decimalDigit decimalLiteralCharacters? .//decimalDigit = Digit 0 through 9decimalDigits = /[0-9]+/ .//decimalDigits = decimalDigit decimalDigits? .//decimalLiteralCharacter = decimalDigit | "_" .//decimalLiteralCharacters = decimalLiteralCharacter decimalLiteralCharacters? .hexadecimalLiteral: /-?0x[0-9a-fA-F][0-9a-fA-F_]*/ .//hexadecimalLiteral = "0x" hexadecimalDigit hexadecimalLiteralCharacters? .//hexadecimalDigit = Digit 0 through 9, a through f, or A through F//hexadecimalLiteralCharacter = hexadecimalDigit | "_" .//hexadecimalLiteralCharacters = hexadecimalLiteralCharacter hexadecimalLiteralCharacters? .decimalFloatingPointLiteral     = /-?[0-9][0-9_]*(?:\.[0-9][0-9_]*)?(?:[eE][+-]?[0-9][0-9_]*)?/ .hexadecimalFloatingPointLiteral = /-?0x[0-9a-fA-F][0-9a-fA-F_]*(?:\.[0-9a-fA-F][0-9a-fA-F_]*)?(?:[pP][+-]?[0-9][0-9_]*)/ .//floatingPointLiteral = decimalLiteral decimalFraction? decimalExponent? .//floatingPointLiteral = hexadecimalLiteral hexadecimalFraction? hexadecimalExponent .floatingPointLiteral = decimalFloatingPointLiteral | hexadecimalFloatingPointLiteral .      // moved after the terminal definitions//decimalFraction = "." decimalLiteral .//decimalExponent = floatingPointE sign? decimalLiteral .//hexadecimalFraction = "." hexadecimalDigit hexadecimalLiteralCharacters? .//hexadecimalExponent = floatingPointP sign? decimalLiteral .//floatingPointE = "e" | "E" .//floatingPointP = "p" | "P" .//sign = "+" | "-" .literal = numericLiteral | stringLiteral | regularExpressionLiteral | booleanLiteral | nilLiteral .       // moved after the terminal definitionsnumericLiteral = integerLiteral | floatingPointLiteral .//numericLiteral = "-"? integerLiteral | "-"? floatingPointLiteral .booleanLiteral = "true" | "false" .nilLiteral = "nil" .integerLiteral = binaryLiteral .integerLiteral = octalLiteral .integerLiteral = decimalLiteral .integerLiteral = hexadecimalLiteral .// STRINGS//stringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"" .//stringLiteralClosingDelimiter = "\"" extendedStringLiteralDelimiter? .staticStringLiteral = /#*"(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .//staticStringLiteral = stringLiteralOpeningDelimiter quotedText? stringLiteralClosingDelimiter .//staticStringLiteral = multilineStringLiteralOpeningDelimiter multilineQuotedText? multilineStringLiteralClosingDelimiter .//multilineStringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"\"\"" .//multilineStringLiteralClosingDelimiter = "\"\"\"" extendedStringLiteralDelimiter? .//extendedStringLiteralDelimiter = "#" extendedStringLiteralDelimiter? .//quotedText = quotedTextItem quotedText? .//quotedTextItem = escapedCharacter .//quotedTextItem = Any Unicode scalar value except ", \, U+000A, or U+000D//multilineQuotedText = multilineQuotedTextItem multilineQuotedText? .//multilineQuotedTextItem = escapedCharacter .//multilineQuotedTextItem = Any Unicode scalar value except \//multilineQuotedTextItem = escapedNewline .interpolatedStringLiteral = /#*"(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .//interpolatedStringLiteral = stringLiteralOpeningDelimiter interpolatedText? stringLiteralClosingDelimiter .//interpolatedStringLiteral = multilineStringLiteralOpeningDelimiter multilineInterpolatedText? multilineStringLiteralClosingDelimiter .//interpolatedText = interpolatedTextItem interpolatedText? .//interpolatedTextItem = "\\(" expression ")" | quotedTextItem .//multilineInterpolatedText = multilineInterpolatedTextItem multilineInterpolatedText? .//multilineInterpolatedTextItem = "\\(" expression ")" | multilineQuotedTextItem .//escapeSequence = "\\" extendedStringLiteralDelimiter .//escapedCharacter = escapeSequence "0" | escapeSequence "\\" | escapeSequence "t" | escapeSequence "n" | escapeSequence "r" | escapeSequence """ | escapeSequence "'" .//escapedCharacter = escapeSequence "u" "{" unicodeScalarDigits "}" .//unicodeScalarDigits = Between one and eight hexadecimal digits//escapedNewline = escapeSequence inlineSpaces? lineBreak .stringLiteral = staticStringLiteral | interpolatedStringLiteral .       // this captures a legal Swift string that has already been validated by the compiler, moved after the terminal definitions// OPERATORSplainOperator = /[\/=+\-*%!&|^~?<>\p{Sm}\p{So}][\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]*/ .dotOperator   = /\.[\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]+/ .//operator = operatorHead operatorCharacters? .//operator = dotOperatorHead dotOperatorCharacters .Operator = plainOperator | dotOperator .           // this captures a legal Swift operator that has already been validated by the compiler, moved after terminal definitions, capitalized to avoid conflict of operator nonTerminal with "operator" literal terminal// Grok: operatorHead characters are covered by P (Punctuation), Sm (Symbol, Math), and So (Symbol, Other).//operatorHead = "/" | "=" | "-" | "+" | "!" | "*" | "%" | "<" | ">" | "&" | "|" | "^" | "~" | "?" .//operatorHead = U+00A1ÐU+00A7//operatorHead = U+00A9 or U+00AB//operatorHead = U+00AC or U+00AE//operatorHead = U+00B0ÐU+00B1//operatorHead = U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7//operatorHead = U+2016ÐU+2017//operatorHead = U+2020ÐU+2027//operatorHead = U+2030ÐU+203E//operatorHead = U+2041ÐU+2053//operatorHead = U+2055ÐU+205E//operatorHead = U+2190ÐU+23FF//operatorHead = U+2500ÐU+2775//operatorHead = U+2794ÐU+2BFF//operatorHead = U+2E00ÐU+2E7F//operatorHead = U+3001ÐU+3003//operatorHead = U+3008ÐU+3020//operatorHead = U+3030// Grok: the additional ranges listed under operatorCharacter belong to the Mn (Mark, Nonspacing) category.//operatorCharacter = operatorHead .//operatorCharacter = U+0300ÐU+036F//operatorCharacter = U+1DC0ÐU+1DFF//operatorCharacter = U+20D0ÐU+20FF//operatorCharacter = U+FE00ÐU+FE0F//operatorCharacter = U+FE20ÐU+FE2F//operatorCharacter = U+E0100ÐU+E01EF//operatorCharacters = operatorCharacter operatorCharacters? .//dotOperatorHead = "." .//dotOperatorCharacter = "." | operatorCharacter .//dotOperatorCharacters = dotOperatorCharacter dotOperatorCharacters? .infixOperator = Operator .prefixOperator = Operator .postfixOperator = Operator .//// PROBABLY THE END OF THE TERMINALS, WHAT FOLLOWS ARE NONTERMINALS//type = functionType .type = arrayType .type = dictionaryType .type = typeIdentifier .type = tupleType .type = optionalType .type = implicitlyUnwrappedOptionalType .type = protocolCompositionType .type = opaqueType .type = metatypeType .type = anyType .type = selfType .type = "(" type ")" .typeAnnotation = ":" attributes? "inout"? type .typeIdentifier = typeName genericArgumentClause? | typeName genericArgumentClause? "." typeIdentifier .typeName = identifier .tupleType = "(" ")" | "(" tupleTypeElement "," tupleTypeElementList ")" .tupleTypeElementList = tupleTypeElement | tupleTypeElement "," tupleTypeElementList .tupleTypeElement = elementName typeAnnotation | type .elementName = identifier .functionType = attributes? functionTypeArgumentClause "async"? throwsClause? ">" type .functionTypeArgumentClause = "(" ")" .functionTypeArgumentClause = "(" functionTypeArgumentList "..."? ")" .functionTypeArgumentList = functionTypeArgument | functionTypeArgument "," functionTypeArgumentList .functionTypeArgument = attributes? "inout"? type | argumentLabel typeAnnotation .argumentLabel = identifier .throwsClause = "throws" | "throws" "(" type ")" .arrayType = "[" type "]" .dictionaryType = "[" type ":" type "]" .optionalType = type "?" .implicitlyUnwrappedOptionalType = type "!" .protocolCompositionType = typeIdentifier "&" protocolCompositionContinuation .protocolCompositionContinuation = typeIdentifier | protocolCompositionType .opaqueType = "some" type .boxedProtocolType = "any" type .metatypeType = type "." "Type" | type "." "Protocol" .anyType = "Any" .selfType = "Self" .typeInheritanceClause = ":" typeInheritanceList .typeInheritanceList = attributes? typeIdentifier | attributes? typeIdentifier "," typeInheritanceList .expression = tryOperator? awaitOperator? prefixExpression infixExpressions? .  // WTF is this \ doing here?prefixExpression = prefixOperator? postfixExpression .prefixExpression = inOutExpression .inOutExpression = "&" primaryExpression .tryOperator = "try" | "try" "?" | "try" "!" .awaitOperator = "await" .infixExpression = infixOperator prefixExpression .infixExpression = assignmentOperator tryOperator? awaitOperator? prefixExpression .infixExpression = conditionalOperator tryOperator? awaitOperator? prefixExpression .infixExpression = typeCastingOperator .infixExpressions = infixExpression infixExpressions? .assignmentOperator = "=" .conditionalOperator = "?" expression ":" .typeCastingOperator = "is" type .typeCastingOperator = "as" type .typeCastingOperator = "as" "?" type .typeCastingOperator = "as" "!" type .primaryExpression = identifier genericArgumentClause? .primaryExpression = literalExpression .primaryExpression = selfExpression .primaryExpression = superclassExpression .primaryExpression = conditionalExpression .primaryExpression = closureExpression .primaryExpression = parenthesizedExpression .primaryExpression = tupleExpression .primaryExpression = implicitMemberExpression .primaryExpression = wildcardExpression .primaryExpression = macroExpansionExpression .primaryExpression = keyPathExpression .primaryExpression = selectorExpression .primaryExpression = keyPathStringExpression .literalExpression = literal .literalExpression = arrayLiteral | dictionaryLiteral | playgroundLiteral .arrayLiteral = "[" arrayLiteralItems? "]" .arrayLiteralItems = arrayLiteralItem ","? | arrayLiteralItem "," arrayLiteralItems .arrayLiteralItem = expression .dictionaryLiteral = "[" dictionaryLiteralItems "]" | "[" ":" "]" .dictionaryLiteralItems = dictionaryLiteralItem ","? | dictionaryLiteralItem "," dictionaryLiteralItems .dictionaryLiteralItem = expression ":" expression .playgroundLiteral = "#colorLiteral" "(" "red" ":" expression "," "green" ":" expression "," "blue" ":" expression "," "alpha" ":" expression ")" .playgroundLiteral = "#fileLiteral" "(" "resourceName" ":" expression ")" .playgroundLiteral = "#imageLiteral" "(" "resourceName" ":" expression ")" .selfExpression = "self" | selfMethodExpression | selfSubscriptExpression | selfInitializerExpression .selfMethodExpression = "self" "." identifier .selfSubscriptExpression = "self" "[" functionCallArgumentList "]" .selfInitializerExpression = "self" "." "init" .superclassExpression = superclassMethodExpression | superclassSubscriptExpression | superclassInitializerExpression .superclassMethodExpression = "super" "." identifier .superclassSubscriptExpression = "super" "[" functionCallArgumentList "]" .superclassInitializerExpression = "super" "." "init" .conditionalExpression = ifExpression | switchExpression .ifExpression = "if" conditionList "{" statement "}" ifExpressionTail .ifExpressionTail = "else" ifExpression .ifExpressionTail = "else" "{" statement "}" .switchExpression = "switch" expression "{" switchExpressionCases "}" .switchExpressionCases = switchExpressionCase switchExpressionCases? .switchExpressionCase = caseLabel statement .switchExpressionCase = defaultLabel statement .closureExpression = "{" attributes? closureSignature? statements? "}" .closureSignature = captureList? closureParameterClause "async"? throwsClause? functionResult? "in" .closureSignature = captureList "in" .closureParameterClause = "(" ")" | "(" closureParameterList ")" | identifierList .closureParameterList = closureParameter | closureParameter "," closureParameterList .closureParameter = closureParameterName typeAnnotation? .closureParameter = closureParameterName typeAnnotation "..." .closureParameterName = identifier .captureList = "[" captureListItems "]" .captureListItems = captureListItem | captureListItem "," captureListItems .captureListItem = captureSpecifier? identifier .captureListItem = captureSpecifier? identifier "=" expression .captureListItem = captureSpecifier? selfExpression .captureSpecifier = "weak" | "unowned" | "unowned(safe)" | "unowned(unsafe)" .implicitMemberExpression = "." identifier .implicitMemberExpression = "." identifier "." postfixExpression .parenthesizedExpression = "(" expression ")" .tupleExpression = "(" ")" | "(" tupleElement "," tupleElementList ")" .tupleElementList = tupleElement | tupleElement "," tupleElementList .tupleElement = expression | identifier ":" expression .wildcardExpression = "_" .macroExpansionExpression = "#" identifier genericArgumentClause? functionCallArgumentClause? trailingClosures? .keyPathExpression = "\\" type? "." keyPathComponents .      // escape needed//keyPathExpression = "\" type? "." keyPathComponents .keyPathComponents = keyPathComponent | keyPathComponent "." keyPathComponents .keyPathComponent = identifier keyPathPostfixes? | keyPathPostfixes .keyPathPostfixes = keyPathPostfix keyPathPostfixes? .keyPathPostfix = "?" | "!" | "self" | "[" functionCallArgumentList "]" .selectorExpression = "#selector" "(" expression ")" .selectorExpression = "#selector" "(" "getter:" expression ")" .selectorExpression = "#selector" "(" "setter:" expression ")" .keyPathStringExpression = "#keyPath" "(" expression ")" .postfixExpression = primaryExpression .postfixExpression = postfixExpression postfixOperator .postfixExpression = functionCallExpression .postfixExpression = initializerExpression .postfixExpression = explicitMemberExpression .postfixExpression = postfixSelfExpression .postfixExpression = subscriptExpression .postfixExpression = forcedValueExpression .postfixExpression = optionalChainingExpression .functionCallExpression = postfixExpression functionCallArgumentClause .functionCallExpression = postfixExpression functionCallArgumentClause? trailingClosures .functionCallArgumentClause = "(" ")" | "(" functionCallArgumentList ")" .functionCallArgumentList = functionCallArgument | functionCallArgument "," functionCallArgumentList .functionCallArgument = expression | identifier ":" expression .functionCallArgument = Operator | identifier ":" Operator .trailingClosures = closureExpression labeledTrailingClosures? .labeledTrailingClosures = labeledTrailingClosure labeledTrailingClosures? .labeledTrailingClosure = identifier ":" closureExpression .initializerExpression = postfixExpression "." "init" .initializerExpression = postfixExpression "." "init" "(" argumentNames ")" .explicitMemberExpression = postfixExpression "." decimalDigits .explicitMemberExpression = postfixExpression "." identifier genericArgumentClause? .explicitMemberExpression = postfixExpression "." identifier "(" argumentNames ")" .explicitMemberExpression = postfixExpression conditionalCompilationBlock .argumentNames = argumentName argumentNames? .argumentName = identifier ":" .postfixSelfExpression = postfixExpression "." "self" .subscriptExpression = postfixExpression "[" functionCallArgumentList "]" .forcedValueExpression = postfixExpression "!" .optionalChainingExpression = postfixExpression "?" .statement = expression ";"? .statement = declaration ";"? .statement = loopStatement ";"? .statement = branchStatement ";"? .statement = labeledStatement ";"? .statement = controlTransferStatement ";"? .statement = deferStatement ";"? .statement = doStatement ";"? .statement = compilerControlStatement .statements = statement statements? .loopStatement = forInStatement .loopStatement = whileStatement .loopStatement = repeatWhileStatement .forInStatement = "for" "case"? pattern "in" expression whereClause? codeBlock .whileStatement = "while" conditionList codeBlock .conditionList = condition | condition "," conditionList .condition = expression | availabilityCondition | caseCondition | optionalBindingCondition .caseCondition = "case" pattern initializer .optionalBindingCondition = "let" pattern initializer? | "var" pattern initializer? .repeatWhileStatement = "repeat" codeBlock "while" expression .branchStatement = ifStatement .branchStatement = guardStatement .branchStatement = switchStatement .ifStatement = "if" conditionList codeBlock elseClause? .elseClause = "else" codeBlock | "else" ifStatement .guardStatement = "guard" conditionList "else" codeBlock .switchStatement = "switch" expression "{" switchCases? "}" .switchCases = switchCase switchCases? .switchCase = caseLabel statements .switchCase = defaultLabel statements .switchCase = conditionalSwitchCase .caseLabel = attributes? "case" caseItemList ":" .caseItemList = pattern whereClause? | pattern whereClause? "," caseItemList .defaultLabel = attributes? "default" ":" .whereClause = "where" whereExpression .whereExpression = expression .conditionalSwitchCase = switchIfDirectiveClause switchElseifDirectiveClauses? switchElseDirectiveClause? endifDirective .switchIfDirectiveClause = ifDirective compilationCondition switchCases? .switchElseifDirectiveClauses = elseifDirectiveClause switchElseifDirectiveClauses? .switchElseifDirectiveClause = elseifDirective compilationCondition switchCases? .switchElseDirectiveClause = elseDirective switchCases? .labeledStatement = statementLabel loopStatement .labeledStatement = statementLabel ifStatement .labeledStatement = statementLabel switchStatement .labeledStatement = statementLabel doStatement .statementLabel = labelName ":" .labelName = identifier .controlTransferStatement = breakStatement .controlTransferStatement = continueStatement .controlTransferStatement = fallthroughStatement .controlTransferStatement = returnStatement .controlTransferStatement = throwStatement .breakStatement = "break" labelName? .continueStatement = "continue" labelName? .fallthroughStatement = "fallthrough" .returnStatement = "return" expression? .throwStatement = "throw" expression .deferStatement = "defer" codeBlock .doStatement = "do" throwsClause? codeBlock catchClauses? .catchClauses = catchClause catchClauses? .catchClause = "catch" catchPatternList? codeBlock .catchPatternList = catchPattern | catchPattern "," catchPatternList .catchPattern = pattern whereClause? .compilerControlStatement = conditionalCompilationBlock .compilerControlStatement = lineControlStatement .compilerControlStatement = diagnosticStatement .conditionalCompilationBlock = ifDirectiveClause elseifDirectiveClauses? elseDirectiveClause? endifDirective .ifDirectiveClause = ifDirective compilationCondition statements? .elseifDirectiveClauses = elseifDirectiveClause elseifDirectiveClauses? .elseifDirectiveClause = elseifDirective compilationCondition statements? .elseDirectiveClause = elseDirective statements? .ifDirective = "#if" .elseifDirective = "#elseif" .elseDirective = "#else" .endifDirective = "#endif" .compilationCondition = platformCondition .compilationCondition = identifier .compilationCondition = booleanLiteral .compilationCondition = "(" compilationCondition ")" .compilationCondition = "!" compilationCondition .compilationCondition = compilationCondition "&&" compilationCondition .compilationCondition = compilationCondition "||" compilationCondition .platformCondition = "os" "(" operatingSystem ")" .platformCondition = "arch" "(" architecture ")" .platformCondition = "swift" "(" ">=" swiftVersion ")" | "swift" "(" "<" swiftVersion ")" .platformCondition = "compiler" "(" ">=" swiftVersion ")" | "compiler" "(" "<" swiftVersion ")" .platformCondition = "canImport" "(" importPath ")" .platformCondition = "targetEnvironment" "(" environment ")" .operatingSystem = "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows" .architecture = "i386" | "x86_64" | "arm" | "arm64" .swiftVersion = decimalDigits swiftVersionContinuation? .swiftVersionContinuation = "." decimalDigits swiftVersionContinuation? .environment = "simulator" | "macCatalyst" .lineNumber = /0*[1-9][0-9]*/ .lineControlStatement = "#sourceLocation" "(" "file:" filePath "," "line:" lineNumber ")" .lineControlStatement = "#sourceLocation" "(" ")" .//lineNumber = A decimal integer greater than zero .            // WTFfilePath = staticStringLiteral .diagnosticStatement = "#warning" "(" stringLiteral ")" | "#error" "(" stringLiteral ")" . // WTF missing, added as per Grok suggestionavailabilityCondition = "#available" "(" availabilityArguments ")" .availabilityCondition = "#unavailable" "(" availabilityArguments ")" .availabilityArguments = availabilityArgument | availabilityArgument "," availabilityArguments .availabilityArgument = platformName platformVersion .availabilityArgument = "*" .platformName = "iOS" | "iOSApplicationExtension" .platformName = "macOS" | "macOSApplicationExtension" .platformName = "macCatalyst" | "macCatalystApplicationExtension" .platformName = "watchOS" | "watchOSApplicationExtension" .platformName = "tvOS" | "tvOSApplicationExtension" .platformName = "visionOS" | "visionOSApplicationExtension" .platformVersion = decimalDigits .platformVersion = decimalDigits "." decimalDigits .platformVersion = decimalDigits "." decimalDigits "." decimalDigits .declaration = importDeclaration .declaration = constantDeclaration .declaration = variableDeclaration .declaration = typealiasDeclaration .declaration = functionDeclaration .declaration = enumDeclaration .declaration = structDeclaration .declaration = classDeclaration .declaration = actorDeclaration .declaration = protocolDeclaration .declaration = initializerDeclaration .declaration = deinitializerDeclaration .declaration = extensionDeclaration .declaration = subscriptDeclaration .declaration = operatorDeclaration .declaration = precedenceGroupDeclaration . // WTF is \ doing here ???codeBlock = "{" statements? "}" .importDeclaration = attributes? "import" importKind? importPath .importKind = "typealias" | "struct" | "class" | "enum" | "protocol" | "let" | "var" | "func" .importPath = identifier | identifier "." importPath .constantDeclaration = attributes? declarationModifiers? "let" patternInitializerList .patternInitializerList = patternInitializer | patternInitializer "," patternInitializerList .patternInitializer = pattern initializer? .initializer = "=" expression .variableDeclaration = variableDeclarationHead patternInitializerList .variableDeclaration = variableDeclarationHead variableName typeAnnotation codeBlock .variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterBlock .variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .variableDeclaration = variableDeclarationHead variableName initializer willSetDidSetBlock .variableDeclaration = variableDeclarationHead variableName typeAnnotation initializer? willSetDidSetBlock .variableDeclarationHead = attributes? declarationModifiers? "var" .variableName = identifier .getterSetterBlock = codeBlock .getterSetterBlock = "{" getterClause setterClause? "}" .getterSetterBlock = "{" setterClause getterClause "}" .getterClause = attributes? mutationModifier? "get" codeBlock .setterClause = attributes? mutationModifier? "set" setterName? codeBlock .setterName = "(" identifier ")" .getterSetterKeywordBlock = "{" getterKeywordClause setterKeywordClause? "}" .getterSetterKeywordBlock = "{" setterKeywordClause getterKeywordClause "}" .getterKeywordClause = attributes? mutationModifier? "get" .setterKeywordClause = attributes? mutationModifier? "set" .willSetDidSetBlock = "{" willSetClause didSetClause? "}" .willSetDidSetBlock = "{" didSetClause willSetClause? "}" .willSetClause = attributes? "willSet" setterName? codeBlock .didSetClause = attributes? "didSet" setterName? codeBlock .typealiasDeclaration = attributes? accessLevelModifier? "typealias" typealiasName genericParameterClause? typealiasAssignment .typealiasName = identifier .typealiasAssignment = "=" type .functionDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? functionBody? .functionHead = attributes? declarationModifiers? "func" .functionName = identifier | Operator .functionSignature = parameterClause "async"? throwsClause? functionResult? .functionSignature = parameterClause "async"? "rethrows" functionResult? .functionResult = ">" attributes? type .functionBody = codeBlock .parameterClause = "(" ")" | "(" parameterList ")" .parameterList = parameter | parameter "," parameterList .parameter = externalParameterName? localParameterName parameterTypeAnnotation defaultArgumentClause? .parameter = externalParameterName? localParameterName parameterTypeAnnotation .parameter = externalParameterName? localParameterName parameterTypeAnnotation "..." .externalParameterName = identifier .localParameterName = identifier .parameterTypeAnnotation = ":" attributes? parameterModifier? type .parameterModifier = "inout" | "borrowing" | "consuming" .defaultArgumentClause = "=" expression .enumDeclaration = attributes? accessLevelModifier? unionStyleEnum .enumDeclaration = attributes? accessLevelModifier? rawValueStyleEnum .unionStyleEnum = "indirect"? "enum" enumName genericParameterClause? typeInheritanceClause? genericWhereClause? "{" unionStyleEnumMembers? "}" .unionStyleEnumMembers = unionStyleEnumMember unionStyleEnumMembers? .unionStyleEnumMember = declaration | unionStyleEnumCaseClause | compilerControlStatement .unionStyleEnumCaseClause = attributes? "indirect"? "case" unionStyleEnumCaseList .unionStyleEnumCaseList = unionStyleEnumCase | unionStyleEnumCase "," unionStyleEnumCaseList .unionStyleEnumCase = enumCaseName tupleType? .enumName = identifier .enumCaseName = identifier .rawValueStyleEnum = "enum" enumName genericParameterClause? typeInheritanceClause genericWhereClause? "{" rawValueStyleEnumMembers "}" .rawValueStyleEnumMembers = rawValueStyleEnumMember rawValueStyleEnumMembers? .rawValueStyleEnumMember = declaration | rawValueStyleEnumCaseClause | compilerControlStatement .rawValueStyleEnumCaseClause = attributes? "case" rawValueStyleEnumCaseList .rawValueStyleEnumCaseList = rawValueStyleEnumCase | rawValueStyleEnumCase "," rawValueStyleEnumCaseList .rawValueStyleEnumCase = enumCaseName rawValueAssignment? .rawValueAssignment = "=" rawValueLiteral .rawValueLiteral = numericLiteral | staticStringLiteral | booleanLiteral .structDeclaration = attributes? accessLevelModifier? "struct" structName genericParameterClause? typeInheritanceClause? genericWhereClause? structBody .structName = identifier .structBody = "{" structMembers? "}" .structMembers = structMember structMembers? .structMember = declaration | compilerControlStatement .classDeclaration = attributes? accessLevelModifier? "final"? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .classDeclaration = attributes? "final" accessLevelModifier? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .className = identifier .classBody = "{" classMembers? "}" .classMembers = classMember classMembers? .classMember = declaration | compilerControlStatement .actorDeclaration = attributes? accessLevelModifier? "actor" actorName genericParameterClause? typeInheritanceClause? genericWhereClause? actorBody .actorName = identifier .actorBody = "{" actorMembers? "}" .actorMembers = actorMember actorMembers? .actorMember = declaration | compilerControlStatement .protocolDeclaration = attributes? accessLevelModifier? "protocol" protocolName typeInheritanceClause? genericWhereClause? protocolBody .protocolName = identifier .protocolBody = "{" protocolMembers? "}" .protocolMembers = protocolMember protocolMembers? .protocolMember = protocolMemberDeclaration | compilerControlStatement .protocolMemberDeclaration = protocolPropertyDeclaration .protocolMemberDeclaration = protocolMethodDeclaration .protocolMemberDeclaration = protocolInitializerDeclaration .protocolMemberDeclaration = protocolSubscriptDeclaration .protocolMemberDeclaration = protocolAssociatedTypeDeclaration .protocolMemberDeclaration = typealiasDeclaration .protocolPropertyDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .protocolMethodDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? .protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause throwsClause? genericWhereClause? .protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause "rethrows" genericWhereClause? .protocolSubscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .protocolAssociatedTypeDeclaration = attributes? accessLevelModifier? "associatedtype" typealiasName typeInheritanceClause? typealiasAssignment? genericWhereClause? .initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? throwsClause? genericWhereClause? initializerBody .initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? "rethrows" genericWhereClause? initializerBody .initializerHead = attributes? declarationModifiers? "init" .initializerHead = attributes? declarationModifiers? "init" "?" .initializerHead = attributes? declarationModifiers? "init" "!" .initializerBody = codeBlock .deinitializerDeclaration = attributes? "deinit" codeBlock .extensionDeclaration = attributes? accessLevelModifier? "extension" typeIdentifier typeInheritanceClause? genericWhereClause? extensionBody .extensionBody = "{" extensionMembers? "}" .extensionMembers = extensionMember extensionMembers? .extensionMember = declaration | compilerControlStatement .subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? codeBlock .subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterBlock .subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .subscriptHead = attributes? declarationModifiers? "subscript" genericParameterClause? parameterClause .subscriptResult = ">" attributes? type .macroDeclaration = macroHead identifier genericParameterClause? macroSignature macroDefinition? genericWhereClause .macroHead = attributes? declarationModifiers? "macro" .macroSignature = parameterClause macroFunctionSignatureResult? .macroFunctionSignatureResult = ">" type .macroDefinition = "=" expression .operatorDeclaration = prefixOperatorDeclaration | postfixOperatorDeclaration | infixOperatorDeclaration .prefixOperatorDeclaration = "prefix" "operator" Operator .postfixOperatorDeclaration = "postfix" "operator" Operator .infixOperatorDeclaration = "infix" "operator" Operator infixOperatorGroup? .infixOperatorGroup = ":" precedenceGroupName .precedenceGroupDeclaration = "precedencegroup" precedenceGroupName "{" precedenceGroupAttributes? "}" .precedenceGroupAttributes = precedenceGroupAttribute precedenceGroupAttributes? .precedenceGroupAttribute = precedenceGroupRelation .precedenceGroupAttribute = precedenceGroupAssignment .precedenceGroupAttribute = precedenceGroupAssociativity .precedenceGroupRelation = "higherThan" ":" precedenceGroupNames .precedenceGroupRelation = "lowerThan" ":" precedenceGroupNames .precedenceGroupAssignment = "assignment" ":" booleanLiteral .precedenceGroupAssociativity = "associativity" ":" "left" .precedenceGroupAssociativity = "associativity" ":" "right" .precedenceGroupAssociativity = "associativity" ":" "none" .precedenceGroupNames = precedenceGroupName | precedenceGroupName "," precedenceGroupNames .precedenceGroupName = identifier .declarationModifier = "class" | "convenience" | "dynamic" | "final" | "infix" | "lazy" | "optional" | "override" | "postfix" | "prefix" | "required" | "static" | "unowned" | "unowned" "(" "safe" ")" | "unowned" "(" "unsafe" ")" | "weak" .declarationModifier = accessLevelModifier .declarationModifier = mutationModifier .declarationModifier = actorIsolationModifier .declarationModifiers = declarationModifier declarationModifiers? .accessLevelModifier = "private" | "private" "(" "set" ")" .accessLevelModifier = "fileprivate" | "fileprivate" "(" "set" ")" .accessLevelModifier = "internal" | "internal" "(" "set" ")" .accessLevelModifier = "package" | "package" "(" "set" ")" .accessLevelModifier = "public" | "public" "(" "set" ")" .accessLevelModifier = "open" | "open" "(" "set" ")" .mutationModifier = "mutating" | "nonmutating" .actorIsolationModifier = "nonisolated" .attribute = "@" attributeName attributeArgumentClause? .attributeName = identifier .attributeArgumentClause = "(" balancedTokens? ")" .attributes = attribute attributes? .innerBalancedToken = /[^()\[\]{}\s]/ .    // approximation since belancedToken has already been matched by the compiler, needs work to exclude commentinnerBalancedTokens = innerBalancedToken innerBalancedTokens? .balancedTokens = balancedToken balancedTokens? .balancedToken = "(" balancedTokens? | innerBalancedToken? ")" .balancedToken = "[" balancedTokens? | innerBalancedToken? "]" .balancedToken = "{" balancedTokens? | innerBalancedToken? "}" .// WTF???//balancedToken = Any identifier, keyword, literal, or operator .//balancedToken = Any punctuation except (, ), [, ], {, or } .pattern = wildcardPattern typeAnnotation? .pattern = identifierPattern typeAnnotation? .pattern = valueBindingPattern .pattern = tuplePattern typeAnnotation? .pattern = enumCasePattern .pattern = optionalPattern .pattern = typeCastingPattern .pattern = expressionPattern .wildcardPattern = "_" .identifierPattern = identifier .valueBindingPattern = "var" pattern | "let" pattern .tuplePattern = "(" tuplePatternElementList? ")" .tuplePatternElementList = tuplePatternElement | tuplePatternElement "," tuplePatternElementList .tuplePatternElement = pattern | identifier ":" pattern .enumCasePattern = typeIdentifier? "." enumCaseName tuplePattern? .optionalPattern = identifierPattern "?" .typeCastingPattern = isPattern | asPattern .isPattern = "is" type .asPattern = pattern "as" type .expressionPattern = expression .genericParameterClause = "<" genericParameterList ">" .genericParameterList = genericParameter | genericParameter "," genericParameterList .genericParameter = typeName .genericParameter = typeName ":" typeIdentifier .genericParameter = typeName ":" protocolCompositionType .genericWhereClause = "where" requirementList .requirementList = requirement | requirement "," requirementList .requirement = conformanceRequirement | sameTypeRequirement .conformanceRequirement = typeIdentifier ":" typeIdentifier .conformanceRequirement = typeIdentifier ":" protocolCompositionType .sameTypeRequirement = typeIdentifier "==" type .genericArgumentClause = "<" genericArgumentList ">" .genericArgumentList = genericArgument | genericArgument "," genericArgumentList .genericArgument = type .^^^////  main.swift//  Advent////  Created by Johannes Brands on 01/03/2024.//import Foundation// transform the APUS ('EBNF') grammar from the input file into a grammar tree ('Abstract Syntax Tree')// by using grammarParser, which is a hand-built recursive descent parsertrace = falselet grammarFileURL = URL(fileURLWithPath: #filePath)    .deletingLastPathComponent()//    .appendingPathComponent("test")    .appendingPathComponent("Swift6Grammar")//    .appendingPathComponent("apusNoAction")//    .appendingPathComponent("apusNoActionKLN")//    .appendingPathComponent("TortureSyntax")//    .appendingPathComponent("apus")//    .appendingPathComponent("tortureART")//    .appendingPathComponent("apusAmbiguous")    .appendingPathExtension("apus")var grammarParser: GrammarParserdo {    grammarParser = try GrammarParser(inputFile: grammarFileURL, patterns: apusTerminals)} catch {    print("error: could not read from \(grammarFileURL.absoluteString)")    exit(0)}var startSymbol = ""    // if "" then startSymbol will set set by parseGrammar to the first nonTerminal in the grammar filelet grammarRoot: GrammarNodeguard let root = grammarParser.parseGrammar(explicitStartSymbol: startSymbol) else {    print("Error: Start symbol '\(startSymbol)' not found")    exit(1)}grammarRoot = roottrace = falsetrace("all grammar tokens:")for t in tokens {    trace(t)}// the GrammarNode being processedvar currentSlot = grammarRoot// the top of one of the stacks in the Graph Structured Stackvar currentStack = gssRootvar failedParses = 0var successfullParses = 0var descriptorCount = 0for m in messages {    trace = false    initScanner(fromString: m, patterns: terminals)    trace = true    trace("all message tokens:")    for t in tokens {        trace(t)    }    trace = false    resetMessageParser()    currentSlot = grammarRoot    currentStack = gssRoot    addDescriptor(slot: grammarRoot.alt!, stack: currentStack, index: currentIndex)    // use the AST to parse the message    let start = clock()    parseMessage()    let end = clock()    let cpuTime = Double(end - start) / Double(CLOCKS_PER_SEC)    print(cpuTime, descriptorCount, gss.count)//    print("CPU time: \(cpuTime) seconds")}#if DEBUGtrace = falselet generatedParserFile = URL(fileURLWithPath: #filePath)    .deletingLastPathComponent()    .appendingPathComponent("output")    .appendingPathExtension("swift")let parserGenerator = ParserGenerator(outputFile: generatedParserFile)do {    try parserGenerator.generateParser()} catch {    print("error: could not write to \(generatedParserFile.absoluteString)")    exit(5)}trace = falselet generatedDiagramFile = URL(fileURLWithPath: #filePath)    .deletingLastPathComponent()    .appendingPathComponent("ART")    .appendingPathExtension("gv")let diagramsGenerator = DiagramsGenerator(outputFile: generatedDiagramFile)do {    try diagramsGenerator.generateDiagrams()} catch {    print("error: could not write to \(generatedDiagramFile.absoluteString)")    exit(6)}#endif