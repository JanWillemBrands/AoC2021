# GLL Parser with ART Implementation - Background

## Overview
This project implements a GLL (Generalized LL) parser following ART (Abstract Recognition Tree) concepts. GLL is a generalized parsing algorithm that can handle all context-free grammars, including ambiguous and left-recursive grammars that traditional LL parsers cannot handle.

## Key Research Papers & References

### PDF 1: GLL parse-tree generation
- **Summary**: Backtracking techniques which are often used to extend recursive descent (RD)
parsers can have explosive run-times and cannot deal with grammars with left re-
cursion. GLL parsers are fully general, worst-case cubic parsers which have the
recursive descent-like property that they are easy to write and to use for grammar
debugging. They have the direct relationship with the grammar that an RD parser
has. In this paper we give an algorithm for generating GLL parsers which build
an SPPF representation of the derivations of the input, complementing our exist-
ing GLL recognition algorithm, and we show that such parsers and recognisers are
worst-case cubic.
- **Key concepts**: The use of a graph structured stack to efficiently share stacks from multiple derivation paths.
- **Location**: '/Users/janwillem/Desktop/GLL/GLL parse-tree generation.pdf'

### PDF 2: A Reference GLL Implementation
- **Summary**: The Generalised-LL (GLL) context-free parsing algorithm
was introduced at the 2009 LDTA workshop, and since then a
series of variant algorithms and implementations have been
described. There is a wide variety of optimisations that may
be applied to GLL, some of which were already present in
the originally published form.
This paper presents a reference GLL implementation shorn
of all optimisations as a common baseline for the real-world
comparison of performance across GLL variants. This base-
line version has particular value for non-specialists, since
its simple form may be straightforwardly encoded in the
implementer’s preferred programming language.
We also describe our approach to low level memory man-
agement of GLL internal data structures. Our evaluation on
large inputs shows a factor 3–4 speedup over a naïve im-
plementation using the standard Java APIs and a factor 4–5
reduction in heap requirements. We conclude with notes
on some algorithm-level optimisations that may be applied
independently of the internal data representation.
- **Key concepts**: The efficient storage of grammar structure in a graph.
- **Location**: '/Users/janwillem/Desktop/GLL/GLL parse-tree generation.pdf'

### PDF 3: Derivation representation using binary subtree sets
- **Summary**: This paper introduces sets of binary subtree representations as an alternative to
shared packed parse forests as the output of a generalised parser, and shows how these
may be generated by Earley’s algorithm, by a new GLL-style parser and by Johnson’s
continuation passing combinator style parsers. The set based output removes the
clerical overhead associated with graph constructions, making the parsers simpler.
- **Key concepts**: Replace SPFF's with sets.
- **Location**: '/Users/janwillem/Desktop/GLL/Derivation representation using binary subtree sets.pdf'

## APUS Grammar Language
- **Summary**: APUS is the custom EBNF-style grammar specification language used in this project.
- **Location**: '/Users/janwillem/Library/Mobile Documents/com~apple~CloudDocs/Xcode/AoC2021/apusNoActionKLN.apus'

### Syntax
The syntax of APUS is described in APUS itself

### Terminals
The syntax of APUS terminals are regular expressions, as defined in the Swift language

### Example Grammar
```
whitespace : /\s+/.

S = "a" | S "b" | S ["b"] C .

C = "c" .
```

## Architecture

### Core Components

#### GrammarParser
- Hand-built recursive descent parser
- Transforms APUS grammar into an Abstract Syntax Tree (AST)
- Produces `GrammarNode` structures

#### Message Parser
- Uses the grammar AST to parse input messages
- Implements GLL algorithm with descriptors and clusters
- Builds the Compact Recognition Forest (CRF)

#### Parser Generator
- Generates executable Swift parser code from the grammar
- Output: `output.swift`

#### Diagrams Generator
- Creates Graphviz visualizations of the parsing structure
- Output: `ART.gv`

## Key Data Structures

### GrammarNode
The Abstract Syntax Tree representation of the grammar rules.

### Descriptors
Work items representing parse states to explore. Each descriptor contains:
- Current grammar slot (position in a rule)
- Current cluster (node in the parse forest)
- Current input index

### Clusters (CRF Nodes)
Nodes in the Compact Recognition Forest representing parsed portions of the input.

### GSS (Graph-Structured Stack)
[Describe how the GSS is used in your implementation]

## GLL Algorithm Implementation

### Descriptor Processing
- `addDescriptor()`: Adds new descriptors to the work queue
- `addDescriptorsForAlternates()`: Creates descriptors for alternate grammar rules
- Duplicate detection to avoid redundant work

### Parse Forest Construction
- CRF (Compact Recognition Forest) building
- ART (Abstract Recognition Tree) generation
- Handling ambiguity through shared structure

### Ambiguity Handling
The parser can handle ambiguous grammars by exploring all possible parse paths and representing them compactly in the CRF/ART structure.

## Implementation Notes

### Terminal Pattern Matching
- `apusTerminals`: Patterns for lexing the grammar file
- `terminals`: Patterns for lexing the input messages

### Performance Metrics
The implementation tracks:
- `descriptorCount`: Total descriptors created
- `duplicateDescriptorCount`: Duplicate descriptors detected (optimization metric)
- CPU time for parsing
- CRF size

### Test Grammars
Various test cases are available:
- `test.apus`: Basic test grammar
- `Swift.apus`: Swift language grammar
- `apusAmbiguous.apus`: Ambiguous grammar tests
- `TortureSyntax.apus`: Stress tests for complex grammar constructs
- `AfroozehHunt.apus`: [Description]
- `apusNoActionKLN.apus`: [Description]
- `tortureART.apus`: [Description]

## Key Terminology

- **GLL (Generalized LL)**: A parsing algorithm that extends LL parsing to handle all context-free grammars
- **ART (Abstract Recognition Tree)**: The compact graph structure representing all possible parse trees
- **CRF (Compact Recognition Forest)**: The shared parse forest data structure
- **GSS (Graph-Structured Stack)**: Graph-structured representation of the parse stack
- **SPPF (Shared Packed Parse Forest)**: Alternative term for the parse forest structure
- **Descriptors**: Work items in the GLL algorithm representing parse states
- **Clusters**: Nodes in the parse forest/ART
- **Slots**: Positions in grammar rules (between symbols)
- **Yields**: Successful parse results

## Design Decisions

### Why GLL?
[Explain the choice of GLL over other parsing algorithms]

### ART vs SPPF
[Explain the relationship/differences between ART and SPPF in your implementation]

### APUS Language Design
[Rationale for the APUS grammar specification format]

## Future Work & TODOs

### Performance Optimizations
- **TODO: Refactor GrammarNode to use arena allocation with integer IDs**
  - Current: Reference-based `final class` with pointer traversal
  - Target: Flat array storage with integer indexing (like ART reference implementation)
  - Expected: 3-4x speedup, 4-5x memory reduction (per ART paper benchmarks)
  - Structure: `GrammarArena` with `SlotID` indices instead of `GrammarNode?` pointers
  - Benefits: Better cache locality, no ARC overhead, contiguous memory layout

[Any other planned improvements or areas of investigation]

## References
- Scott, E. and Johnstone, A. "GLL Parsing"
- [Other relevant papers and resources]

---

*This document provides context for AI assistants and developers working with this GLL parser implementation.*
