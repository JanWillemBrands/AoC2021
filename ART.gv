digraph G {
  fontname = Menlo
  fontsize = 10
  node [fontname = Menlo, fontsize = 10, color = gray, height = 0, width = 0, margin= 0.04]
  edge [fontname = Menlo, fontsize = 10, color = gray, arrowsize = 0.3]
  graph [ranksep = 0.1]
  rankdir = "TB"
  subgraph GSS {
    cluster = true
    label = <////··main.swif...> fontcolor = red
    labeljust = l
    node [shape = box, style = rounded, height = 0]
    AAB0 [label = <AAB0<br/><font color="gray" point-size="8.0"> </font>>]
    AAB0 -> TJ0
    AAB1 [label = <AAB1<br/><font color="gray" point-size="8.0"> </font>>]
    AAB1 -> TJ1
    AAE0 [label = <AAE0<br/><font color="gray" point-size="8.0"> </font>>]
    AAE0 -> TJ0
    AAE1 [label = <AAE1<br/><font color="gray" point-size="8.0"> </font>>]
    AAE1 -> TJ1
    ABB0 [label = <ABB0<br/><font color="gray" point-size="8.0"> </font>>]
    ABB0 -> TM0
    ABB1 [label = <ABB1<br/><font color="gray" point-size="8.0"> </font>>]
    ABB1 -> TM1
    ABE0 [label = <ABE0<br/><font color="gray" point-size="8.0"> </font>>]
    ABE0 -> TM0
    ABE1 [label = <ABE1<br/><font color="gray" point-size="8.0"> </font>>]
    ABE1 -> TM1
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> AOB0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> API0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> APA0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ARZ0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ART0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ATE0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ASW0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ASN0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ASH0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> ATV0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> AUB0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> AUI0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> AUN0
    ANX0 [label = <ANX0<br/><font color="gray" point-size="8.0"> </font>>]
    ANX0 -> PC0
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> AOB1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> API1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> APA1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ARZ1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ART1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ATE1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ASW1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ASN1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ASH1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> ATV1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> AUB1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> AUI1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> AUN1
    ANX1 [label = <ANX1<br/><font color="gray" point-size="8.0"> </font>>]
    ANX1 -> PC1
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> API0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> AOB0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> APA0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ARZ0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ART0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ATE0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ASW0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ASN0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ASH0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> ATV0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> AUB0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> AUI0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> AUN0
    AOB0 [label = <AOB0<br/><font color="gray" point-size="8.0"> </font>>]
    AOB0 -> PC0
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> API1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> AOB1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> APA1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ARZ1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ART1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ATE1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ASW1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ASN1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ASH1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> ATV1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> AUB1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> AUI1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> AUN1
    AOB1 [label = <AOB1<br/><font color="gray" point-size="8.0"> </font>>]
    AOB1 -> PC1
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ARZ0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> API0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> AOB0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> APA0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ART0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ATE0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ASW0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ASN0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ASH0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> ATV0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> AUB0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> AUI0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> AUN0
    AOF0 [label = <AOF0<br/><font color="gray" point-size="8.0"> </font>>]
    AOF0 -> PC0
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ARZ1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> API1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> AOB1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> APA1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ART1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ATE1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ASW1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ASN1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ASH1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> ATV1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> AUB1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> AUI1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> AUN1
    AOF1 [label = <AOF1<br/><font color="gray" point-size="8.0"> </font>>]
    AOF1 -> PC1
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ATE0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ARZ0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> API0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> AOB0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> APA0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ART0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ASW0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ASN0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ASH0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> ATV0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> AUB0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> AUI0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> AUN0
    AOI0 [label = <AOI0<br/><font color="gray" point-size="8.0"> </font>>]
    AOI0 -> PC0
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ATE1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ARZ1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> API1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> AOB1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> APA1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ART1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ASW1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ASN1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ASH1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> ATV1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> AUB1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> AUI1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> AUN1
    AOI1 [label = <AOI1<br/><font color="gray" point-size="8.0"> </font>>]
    AOI1 -> PC1
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ATV0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ATE0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ARZ0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> API0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> AOB0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> APA0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ART0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ASW0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ASN0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> ASH0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> AUB0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> AUI0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> AUN0
    AOL0 [label = <AOL0<br/><font color="gray" point-size="8.0"> </font>>]
    AOL0 -> PC0
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ATV1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ATE1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ARZ1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> API1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> AOB1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> APA1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ART1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ASW1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ASN1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> ASH1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> AUB1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> AUI1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> AUN1
    AOL1 [label = <AOL1<br/><font color="gray" point-size="8.0"> </font>>]
    AOL1 -> PC1
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> AUB0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ATV0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ATE0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ARZ0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> API0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> AOB0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> APA0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ART0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ASW0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ASN0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> ASH0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> AUI0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> AUN0
    AOO0 [label = <AOO0<br/><font color="gray" point-size="8.0"> </font>>]
    AOO0 -> PC0
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> AUB1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ATV1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ATE1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ARZ1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> API1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> AOB1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> APA1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ART1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ASW1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ASN1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> ASH1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> AUI1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> AUN1
    AOO1 [label = <AOO1<br/><font color="gray" point-size="8.0"> </font>>]
    AOO1 -> PC1
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> AUI0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> AUB0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ATV0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ATE0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ARZ0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> API0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> AOB0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> APA0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ART0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ASW0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ASN0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> ASH0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> AUN0
    AOR0 [label = <AOR0<br/><font color="gray" point-size="8.0"> </font>>]
    AOR0 -> PC0
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> AUI1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> AUB1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ATV1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ATE1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ARZ1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> API1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> AOB1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> APA1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ART1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ASW1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ASN1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> ASH1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> AUN1
    AOR1 [label = <AOR1<br/><font color="gray" point-size="8.0"> </font>>]
    AOR1 -> PC1
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> AUN0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> AUI0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> AUB0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ATV0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ATE0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ARZ0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> API0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> AOB0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> APA0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ART0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ASW0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ASN0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> ASH0
    AOU0 [label = <AOU0<br/><font color="gray" point-size="8.0"> </font>>]
    AOU0 -> PC0
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> AUN1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> AUI1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> AUB1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ATV1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ATE1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ARZ1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> API1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> AOB1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> APA1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ART1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ASW1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ASN1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> ASH1
    AOU1 [label = <AOU1<br/><font color="gray" point-size="8.0"> </font>>]
    AOU1 -> PC1
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> PC0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> AUN0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> AUI0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> AUB0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ATV0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ATE0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ARZ0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> API0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> AOB0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> APA0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ART0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ASW0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ASN0
    AOX0 [label = <AOX0<br/><font color="gray" point-size="8.0"> </font>>]
    AOX0 -> ASH0
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> PC1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> AUN1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> AUI1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> AUB1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ATV1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ATE1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ARZ1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> API1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> AOB1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> APA1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ART1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ASW1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ASN1
    AOX1 [label = <AOX1<br/><font color="gray" point-size="8.0"> </font>>]
    AOX1 -> ASH1
    APA0 [label = <APA0<br/><font color="gray" point-size="8.0"> </font>>]
    APA0 -> AOF0
    APA1 [label = <APA1<br/><font color="gray" point-size="8.0"> </font>>]
    APA1 -> AOF1
    API0 [label = <API0<br/><font color="gray" point-size="8.0"> </font>>]
    API0 -> AOF0
    API1 [label = <API1<br/><font color="gray" point-size="8.0"> </font>>]
    API1 -> AOF1
    ART0 [label = <ART0<br/><font color="gray" point-size="8.0"> </font>>]
    ART0 -> AOI0
    ART1 [label = <ART1<br/><font color="gray" point-size="8.0"> </font>>]
    ART1 -> AOI1
    ARZ0 [label = <ARZ0<br/><font color="gray" point-size="8.0"> </font>>]
    ARZ0 -> AOI0
    ARZ1 [label = <ARZ1<br/><font color="gray" point-size="8.0"> </font>>]
    ARZ1 -> AOI1
    ASH0 [label = <ASH0<br/><font color="gray" point-size="8.0"> </font>>]
    ASH0 -> AOL0
    ASH1 [label = <ASH1<br/><font color="gray" point-size="8.0"> </font>>]
    ASH1 -> AOL1
    ASN0 [label = <ASN0<br/><font color="gray" point-size="8.0"> </font>>]
    ASN0 -> AOL0
    ASN1 [label = <ASN1<br/><font color="gray" point-size="8.0"> </font>>]
    ASN1 -> AOL1
    ASW0 [label = <ASW0<br/><font color="gray" point-size="8.0"> </font>>]
    ASW0 -> AOL0
    ASW1 [label = <ASW1<br/><font color="gray" point-size="8.0"> </font>>]
    ASW1 -> AOL1
    ATE0 [label = <ATE0<br/><font color="gray" point-size="8.0"> </font>>]
    ATE0 -> AOL0
    ATE1 [label = <ATE1<br/><font color="gray" point-size="8.0"> </font>>]
    ATE1 -> AOL1
    ATV0 [label = <ATV0<br/><font color="gray" point-size="8.0"> </font>>]
    ATV0 -> AOO0
    ATV1 [label = <ATV1<br/><font color="gray" point-size="8.0"> </font>>]
    ATV1 -> AOO1
    AUB0 [label = <AUB0<br/><font color="gray" point-size="8.0"> </font>>]
    AUB0 -> AOR0
    AUB1 [label = <AUB1<br/><font color="gray" point-size="8.0"> </font>>]
    AUB1 -> AOR1
    AUI0 [label = <AUI0<br/><font color="gray" point-size="8.0"> </font>>]
    AUI0 -> AOU0
    AUI1 [label = <AUI1<br/><font color="gray" point-size="8.0"> </font>>]
    AUI1 -> AOU1
    AUN0 [label = <AUN0<br/><font color="gray" point-size="8.0"> </font>>]
    AUN0 -> AOX0
    AUN1 [label = <AUN1<br/><font color="gray" point-size="8.0"> </font>>]
    AUN1 -> AOX1
    AUV0 [label = <AUV0<br/><font color="gray" point-size="8.0"> </font>>]
    AUV0 -> AXD0
    AVD0 [label = <AVD0<br/><font color="gray" point-size="8.0"> </font>>]
    AVD0 -> AXD0
    AVK0 [label = <AVK0<br/><font color="gray" point-size="8.0"> </font>>]
    AVK0 -> AXD0
    AVR0 [label = <AVR0<br/><font color="gray" point-size="8.0"> </font>>]
    AVR0 -> AXD0
    AVY0 [label = <AVY0<br/><font color="gray" point-size="8.0"> </font>>]
    AVY0 -> AXD0
    AWF0 [label = <AWF0<br/><font color="gray" point-size="8.0"> </font>>]
    AWF0 -> AXD0
    AWM0 [label = <AWM0<br/><font color="gray" point-size="8.0"> </font>>]
    AWM0 -> AXD0
    AWT0 [label = <AWT0<br/><font color="gray" point-size="8.0"> </font>>]
    AWT0 -> AXD0
    AWX0 [label = <AWX0<br/><font color="gray" point-size="8.0"> </font>>]
    AWX0 -> AXD0
    AXD0 [label = <AXD0<br/><font color="gray" point-size="8.0"> </font>>]
    AXD0 -> D0
    AXI0 [label = <AXI0<br/><font color="gray" point-size="8.0"> </font>>]
    AXI0 -> AVK0
    AXM0 [label = <AXM0<br/><font color="gray" point-size="8.0"> </font>>]
    AXM0 -> AVK0
    AXP0 [label = <AXP0<br/><font color="gray" point-size="8.0"> </font>>]
    AXP0 -> AVK0
    BAO0 [label = <BAO0<br/><font color="gray" point-size="8.0"> </font>>]
    BAO0 -> AVR0
    BAS0 [label = <BAS0<br/><font color="gray" point-size="8.0"> </font>>]
    BAS0 -> AVR0
    BAV0 [label = <BAV0<br/><font color="gray" point-size="8.0"> </font>>]
    BAV0 -> AVR0
    BB0 [label = <BB0<br/><font color="gray" point-size="8.0"> </font>>]
    BB0 -> UQ0
    BB1 [label = <BB1<br/><font color="gray" point-size="8.0"> </font>>]
    BB1 -> UQ1
    BE0 [label = <BE0<br/><font color="gray" point-size="8.0"> </font>>]
    BE0 -> UQ0
    BE1 [label = <BE1<br/><font color="gray" point-size="8.0"> </font>>]
    BE1 -> UQ1
    BGR0 [label = <BGR0<br/><font color="gray" point-size="8.0"> </font>>]
    BGR0 -> AVY0
    BGW0 [label = <BGW0<br/><font color="gray" point-size="8.0"> </font>>]
    BGW0 -> AVY0
    BHA0 [label = <BHA0<br/><font color="gray" point-size="8.0"> </font>>]
    BHA0 -> AVY0
    BHE0 [label = <BHE0<br/><font color="gray" point-size="8.0"> </font>>]
    BHE0 -> AVY0
    BHI0 [label = <BHI0<br/><font color="gray" point-size="8.0"> </font>>]
    BHI0 -> BHE0
    BHI0 [label = <BHI0<br/><font color="gray" point-size="8.0"> </font>>]
    BHI0 -> BHA0
    BHI0 [label = <BHI0<br/><font color="gray" point-size="8.0"> </font>>]
    BHI0 -> BGW0
    BHI0 [label = <BHI0<br/><font color="gray" point-size="8.0"> </font>>]
    BHI0 -> BGR0
    BHN0 [label = <BHN0<br/><font color="gray" point-size="8.0"> </font>>]
    BHN0 -> BHI0
    BHR0 [label = <BHR0<br/><font color="gray" point-size="8.0"> </font>>]
    BHR0 -> AWF0
    BHV0 [label = <BHV0<br/><font color="gray" point-size="8.0"> </font>>]
    BHV0 -> AWF0
    BHY0 [label = <BHY0<br/><font color="gray" point-size="8.0"> </font>>]
    BHY0 -> AWF0
    BIB0 [label = <BIB0<br/><font color="gray" point-size="8.0"> </font>>]
    BIB0 -> AWF0
    BIE0 [label = <BIE0<br/><font color="gray" point-size="8.0"> </font>>]
    BIE0 -> AWF0
    BK0 [label = <BK0<br/><font color="gray" point-size="8.0"> </font>>]
    BK0 -> UQ0
    BK1 [label = <BK1<br/><font color="gray" point-size="8.0"> </font>>]
    BK1 -> UQ1
    BLO0 [label = <BLO0<br/><font color="gray" point-size="8.0"> </font>>]
    BLO0 -> AWX0
    BLS0 [label = <BLS0<br/><font color="gray" point-size="8.0"> </font>>]
    BLS0 -> AWX0
    BLV0 [label = <BLV0<br/><font color="gray" point-size="8.0"> </font>>]
    BLV0 -> AWX0
    BMB0 [label = <BMB0<br/><font color="gray" point-size="8.0"> </font>>]
    BMB0 -> BLO0
    BML0 [label = <BML0<br/><font color="gray" point-size="8.0"> </font>>]
    BML0 -> BMB0
    BN0 [label = <BN0<br/><font color="gray" point-size="8.0"> </font>>]
    BN0 -> UQ0
    BN1 [label = <BN1<br/><font color="gray" point-size="8.0"> </font>>]
    BN1 -> UQ1
    BR0 [label = <BR0<br/><font color="gray" point-size="8.0"> </font>>]
    BR0 -> BB0
    BR1 [label = <BR1<br/><font color="gray" point-size="8.0"> </font>>]
    BR1 -> BB1
    BU0 [label = <BU0<br/><font color="gray" point-size="8.0"> </font>>]
    BU0 -> BB0
    BU1 [label = <BU1<br/><font color="gray" point-size="8.0"> </font>>]
    BU1 -> BB1
    BYH0 [label = <BYH0<br/><font color="gray" point-size="8.0"> </font>>]
    BYH0 -> AVD0
    BYL0 [label = <BYL0<br/><font color="gray" point-size="8.0"> </font>>]
    BYL0 -> AVD0
    BYO0 [label = <BYO0<br/><font color="gray" point-size="8.0"> </font>>]
    BYO0 -> AVD0
    BYR0 [label = <BYR0<br/><font color="gray" point-size="8.0"> </font>>]
    BYR0 -> AVD0
    BYU0 [label = <BYU0<br/><font color="gray" point-size="8.0"> </font>>]
    BYU0 -> AVD0
    BYX0 [label = <BYX0<br/><font color="gray" point-size="8.0"> </font>>]
    BYX0 -> AVD0
    BZA0 [label = <BZA0<br/><font color="gray" point-size="8.0"> </font>>]
    BZA0 -> AVD0
    BZD0 [label = <BZD0<br/><font color="gray" point-size="8.0"> </font>>]
    BZD0 -> AVD0
    BZG0 [label = <BZG0<br/><font color="gray" point-size="8.0"> </font>>]
    BZG0 -> AVD0
    BZJ0 [label = <BZJ0<br/><font color="gray" point-size="8.0"> </font>>]
    BZJ0 -> AVD0
    BZM0 [label = <BZM0<br/><font color="gray" point-size="8.0"> </font>>]
    BZM0 -> AVD0
    BZP0 [label = <BZP0<br/><font color="gray" point-size="8.0"> </font>>]
    BZP0 -> AVD0
    BZS0 [label = <BZS0<br/><font color="gray" point-size="8.0"> </font>>]
    BZS0 -> AVD0
    BZV0 [label = <BZV0<br/><font color="gray" point-size="8.0"> </font>>]
    BZV0 -> AVD0
    BZY0 [label = <BZY0<br/><font color="gray" point-size="8.0"> </font>>]
    BZY0 -> AVD0
    CAB0 [label = <CAB0<br/><font color="gray" point-size="8.0"> </font>>]
    CAB0 -> AVD0
    CAO0 [label = <CAO0<br/><font color="gray" point-size="8.0"> </font>>]
    CAO0 -> BYH0
    CCJ0 [label = <CCJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CCJ0 -> BYL0
    CCN0 [label = <CCN0<br/><font color="gray" point-size="8.0"> </font>>]
    CCN0 -> BYL0
    CDR0 [label = <CDR0<br/><font color="gray" point-size="8.0"> </font>>]
    CDR0 -> BYO0
    CDW0 [label = <CDW0<br/><font color="gray" point-size="8.0"> </font>>]
    CDW0 -> BYO0
    CEC0 [label = <CEC0<br/><font color="gray" point-size="8.0"> </font>>]
    CEC0 -> BYO0
    CEI0 [label = <CEI0<br/><font color="gray" point-size="8.0"> </font>>]
    CEI0 -> BYO0
    CEO0 [label = <CEO0<br/><font color="gray" point-size="8.0"> </font>>]
    CEO0 -> BYO0
    CEU0 [label = <CEU0<br/><font color="gray" point-size="8.0"> </font>>]
    CEU0 -> BYO0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CEU0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CEO0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CEI0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CEC0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CDW0
    CFF0 [label = <CFF0<br/><font color="gray" point-size="8.0"> </font>>]
    CFF0 -> CDR0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CEU0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CEO0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CEI0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CEC0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CDW0
    CFJ0 [label = <CFJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CFJ0 -> CDR0
    CLF0 [label = <CLF0<br/><font color="gray" point-size="8.0"> </font>>]
    CLF0 -> BYR0
    CLJ0 [label = <CLJ0<br/><font color="gray" point-size="8.0"> </font>>]
    CLJ0 -> BYR0
    CMF0 [label = <CMF0<br/><font color="gray" point-size="8.0"> </font>>]
    CMF0 -> BYU0
    CMY0 [label = <CMY0<br/><font color="gray" point-size="8.0"> </font>>]
    CMY0 -> CMF0
    CNC0 [label = <CNC0<br/><font color="gray" point-size="8.0"> </font>>]
    CNC0 -> CMF0
    CSN0 [label = <CSN0<br/><font color="gray" point-size="8.0"> </font>>]
    CSN0 -> BYX0
    CSR0 [label = <CSR0<br/><font color="gray" point-size="8.0"> </font>>]
    CSR0 -> BYX0
    CSU0 [label = <CSU0<br/><font color="gray" point-size="8.0"> </font>>]
    CSU0 -> BYX0
    CSZ0 [label = <CSZ0<br/><font color="gray" point-size="8.0"> </font>>]
    CSZ0 -> BYX0
    CTD0 [label = <CTD0<br/><font color="gray" point-size="8.0"> </font>>]
    CTD0 -> BYX0
    CTG0 [label = <CTG0<br/><font color="gray" point-size="8.0"> </font>>]
    CTG0 -> BYX0
    CZN0 [label = <CZN0<br/><font color="gray" point-size="8.0"> </font>>]
    CZN0 -> BZA0
    CZR0 [label = <CZR0<br/><font color="gray" point-size="8.0"> </font>>]
    CZR0 -> BZA0
    D0 [label = <D0<br/><font color="gray" point-size="8.0"> </font>>]
    D0 -> ●○
    DBP0 [label = <DBP0<br/><font color="gray" point-size="8.0"> </font>>]
    DBP0 -> BZD0
    DBT0 [label = <DBT0<br/><font color="gray" point-size="8.0"> </font>>]
    DBT0 -> BZD0
    DCT0 [label = <DCT0<br/><font color="gray" point-size="8.0"> </font>>]
    DCT0 -> BZD0
    DEV0 [label = <DEV0<br/><font color="gray" point-size="8.0"> </font>>]
    DEV0 -> BZG0
    DEZ0 [label = <DEZ0<br/><font color="gray" point-size="8.0"> </font>>]
    DEZ0 -> BZG0
    DGX0 [label = <DGX0<br/><font color="gray" point-size="8.0"> </font>>]
    DGX0 -> BZJ0
    DHB0 [label = <DHB0<br/><font color="gray" point-size="8.0"> </font>>]
    DHB0 -> BZJ0
    DMY0 [label = <DMY0<br/><font color="gray" point-size="8.0"> </font>>]
    DMY0 -> BZM0
    DNU0 [label = <DNU0<br/><font color="gray" point-size="8.0"> </font>>]
    DNU0 -> BZM0
    DOK0 [label = <DOK0<br/><font color="gray" point-size="8.0"> </font>>]
    DOK0 -> DNU0
    DOK0 [label = <DOK0<br/><font color="gray" point-size="8.0"> </font>>]
    DOK0 -> DMY0
    DOO0 [label = <DOO0<br/><font color="gray" point-size="8.0"> </font>>]
    DOO0 -> DNU0
    DOO0 [label = <DOO0<br/><font color="gray" point-size="8.0"> </font>>]
    DOO0 -> DMY0
    DOW0 [label = <DOW0<br/><font color="gray" point-size="8.0"> </font>>]
    DOW0 -> DNU0
    DOW0 [label = <DOW0<br/><font color="gray" point-size="8.0"> </font>>]
    DOW0 -> DMY0
    DPA0 [label = <DPA0<br/><font color="gray" point-size="8.0"> </font>>]
    DPA0 -> DNU0
    DPA0 [label = <DPA0<br/><font color="gray" point-size="8.0"> </font>>]
    DPA0 -> DMY0
    DPI0 [label = <DPI0<br/><font color="gray" point-size="8.0"> </font>>]
    DPI0 -> DNU0
    DPI0 [label = <DPI0<br/><font color="gray" point-size="8.0"> </font>>]
    DPI0 -> DMY0
    DPM0 [label = <DPM0<br/><font color="gray" point-size="8.0"> </font>>]
    DPM0 -> DNU0
    DPM0 [label = <DPM0<br/><font color="gray" point-size="8.0"> </font>>]
    DPM0 -> DMY0
    DPY0 [label = <DPY0<br/><font color="gray" point-size="8.0"> </font>>]
    DPY0 -> BZP0
    DQH0 [label = <DQH0<br/><font color="gray" point-size="8.0"> </font>>]
    DQH0 -> BZS0
    DQL0 [label = <DQL0<br/><font color="gray" point-size="8.0"> </font>>]
    DQL0 -> BZS0
    DS0 [label = <DS0<br/><font color="gray" point-size="8.0"> 1</font>>]
    DS0 -> OZ0
    DSA0 [label = <DSA0<br/><font color="gray" point-size="8.0"> </font>>]
    DSA0 -> BZV0
    DSK0 [label = <DSK0<br/><font color="gray" point-size="8.0"> </font>>]
    DSK0 -> BZV0
    DST0 [label = <DST0<br/><font color="gray" point-size="8.0"> </font>>]
    DST0 -> BZV0
    DTD0 [label = <DTD0<br/><font color="gray" point-size="8.0"> </font>>]
    DTD0 -> DST0
    DTD0 [label = <DTD0<br/><font color="gray" point-size="8.0"> </font>>]
    DTD0 -> DSK0
    DTD0 [label = <DTD0<br/><font color="gray" point-size="8.0"> </font>>]
    DTD0 -> DSA0
    DTH0 [label = <DTH0<br/><font color="gray" point-size="8.0"> </font>>]
    DTH0 -> DST0
    DTH0 [label = <DTH0<br/><font color="gray" point-size="8.0"> </font>>]
    DTH0 -> DSK0
    DTH0 [label = <DTH0<br/><font color="gray" point-size="8.0"> </font>>]
    DTH0 -> DSA0
    DVV0 [label = <DVV0<br/><font color="gray" point-size="8.0"> </font>>]
    DVV0 -> BZY0
    DVY0 [label = <DVY0<br/><font color="gray" point-size="8.0"> </font>>]
    DVY0 -> BZY0
    DWB0 [label = <DWB0<br/><font color="gray" point-size="8.0"> </font>>]
    DWB0 -> BZY0
    ECG0 [label = <ECG0<br/><font color="gray" point-size="8.0"> </font>>]
    ECG0 -> ECS0
    ECJ0 [label = <ECJ0<br/><font color="gray" point-size="8.0"> </font>>]
    ECJ0 -> ECS0
    ECM0 [label = <ECM0<br/><font color="gray" point-size="8.0"> </font>>]
    ECM0 -> ECS0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> DTH0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> DPM0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> DPA0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> DOO0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> CNC0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> CFJ0
    ECS0 [label = <ECS0<br/><font color="gray" point-size="8.0"> </font>>]
    ECS0 -> CCN0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DTD0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DQH0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DPY0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DPI0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DOW0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DOK0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DGX0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DEV0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DCT0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> DBP0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CZN0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CSZ0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CSN0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CMY0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CLF0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CFF0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CCJ0
    EGK0 [label = <EGK0<br/><font color="gray" point-size="8.0"> </font>>]
    EGK0 -> CAO0
    OJ0 [label = <OJ0<br/><font color="gray" point-size="8.0"> </font>>]
    OJ0 -> AUV0
    ON0 [label = <ON0<br/><font color="gray" point-size="8.0"> </font>>]
    ON0 -> AUV0
    OT0 [label = <OT0<br/><font color="gray" point-size="8.0"> </font>>]
    OT0 -> AUV0
    OZ0 [label = <OZ0<br/><font color="gray" point-size="8.0"> 1</font>>]
    OZ0 -> OT0
    PC0 [label = <PC0<br/><font color="gray" point-size="8.0"> </font>>]
    PC0 -> OT0
    PC1 [label = <PC1<br/><font color="gray" point-size="8.0"> </font>>]
    PC1 -> OT0
    PG0 [label = <PG0<br/><font color="gray" point-size="8.0"> </font>>]
    PG0 -> OT0
    SY0 [label = <SY0<br/><font color="gray" point-size="8.0"> </font>>]
    SY0 -> ANX0
    SY1 [label = <SY1<br/><font color="gray" point-size="8.0"> </font>>]
    SY1 -> ANX1
    TD0 [label = <TD0<br/><font color="gray" point-size="8.0"> </font>>]
    TD0 -> ANX0
    TD1 [label = <TD1<br/><font color="gray" point-size="8.0"> </font>>]
    TD1 -> ANX1
    TG0 [label = <TG0<br/><font color="gray" point-size="8.0"> </font>>]
    TG0 -> ANX0
    TG1 [label = <TG1<br/><font color="gray" point-size="8.0"> </font>>]
    TG1 -> ANX1
    TJ0 [label = <TJ0<br/><font color="gray" point-size="8.0"> </font>>]
    TJ0 -> ANX0
    TJ1 [label = <TJ1<br/><font color="gray" point-size="8.0"> </font>>]
    TJ1 -> ANX1
    TM0 [label = <TM0<br/><font color="gray" point-size="8.0"> </font>>]
    TM0 -> ANX0
    TM1 [label = <TM1<br/><font color="gray" point-size="8.0"> </font>>]
    TM1 -> ANX1
    TP0 [label = <TP0<br/><font color="gray" point-size="8.0"> </font>>]
    TP0 -> ANX0
    TP1 [label = <TP1<br/><font color="gray" point-size="8.0"> </font>>]
    TP1 -> ANX1
    TS0 [label = <TS0<br/><font color="gray" point-size="8.0"> </font>>]
    TS0 -> ANX0
    TS1 [label = <TS1<br/><font color="gray" point-size="8.0"> </font>>]
    TS1 -> ANX1
    TV0 [label = <TV0<br/><font color="gray" point-size="8.0"> </font>>]
    TV0 -> ANX0
    TV1 [label = <TV1<br/><font color="gray" point-size="8.0"> </font>>]
    TV1 -> ANX1
    TY0 [label = <TY0<br/><font color="gray" point-size="8.0"> </font>>]
    TY0 -> ANX0
    TY1 [label = <TY1<br/><font color="gray" point-size="8.0"> </font>>]
    TY1 -> ANX1
    UB0 [label = <UB0<br/><font color="gray" point-size="8.0"> </font>>]
    UB0 -> ANX0
    UB1 [label = <UB1<br/><font color="gray" point-size="8.0"> </font>>]
    UB1 -> ANX1
    UE0 [label = <UE0<br/><font color="gray" point-size="8.0"> </font>>]
    UE0 -> ANX0
    UE1 [label = <UE1<br/><font color="gray" point-size="8.0"> </font>>]
    UE1 -> ANX1
    UH0 [label = <UH0<br/><font color="gray" point-size="8.0"> </font>>]
    UH0 -> ANX0
    UH1 [label = <UH1<br/><font color="gray" point-size="8.0"> </font>>]
    UH1 -> ANX1
    UK0 [label = <UK0<br/><font color="gray" point-size="8.0"> </font>>]
    UK0 -> ANX0
    UK1 [label = <UK1<br/><font color="gray" point-size="8.0"> </font>>]
    UK1 -> ANX1
    UN0 [label = <UN0<br/><font color="gray" point-size="8.0"> </font>>]
    UN0 -> ANX0
    UN1 [label = <UN1<br/><font color="gray" point-size="8.0"> </font>>]
    UN1 -> ANX1
    UQ0 [label = <UQ0<br/><font color="gray" point-size="8.0"> </font>>]
    UQ0 -> TD0
    UQ1 [label = <UQ1<br/><font color="gray" point-size="8.0"> </font>>]
    UQ1 -> TD1
    UU0 [label = <UU0<br/><font color="gray" point-size="8.0"> </font>>]
    UU0 -> TD0
    UU1 [label = <UU1<br/><font color="gray" point-size="8.0"> </font>>]
    UU1 -> TD1
    UX0 [label = <UX0<br/><font color="gray" point-size="8.0"> </font>>]
    UX0 -> TD0
    UX1 [label = <UX1<br/><font color="gray" point-size="8.0"> </font>>]
    UX1 -> TD1
    VA0 [label = <VA0<br/><font color="gray" point-size="8.0"> </font>>]
    VA0 -> TD0
    VA1 [label = <VA1<br/><font color="gray" point-size="8.0"> </font>>]
    VA1 -> TD1
    YV0 [label = <YV0<br/><font color="gray" point-size="8.0"> </font>>]
    YV0 -> TG0
    YV1 [label = <YV1<br/><font color="gray" point-size="8.0"> </font>>]
    YV1 -> TG1
    YY0 [label = <YY0<br/><font color="gray" point-size="8.0"> </font>>]
    YY0 -> TG0
    YY1 [label = <YY1<br/><font color="gray" point-size="8.0"> </font>>]
    YY1 -> TG1
    ZB0 [label = <ZB0<br/><font color="gray" point-size="8.0"> </font>>]
    ZB0 -> TG0
    ZB1 [label = <ZB1<br/><font color="gray" point-size="8.0"> </font>>]
    ZB1 -> TG1
    ZY0 [label = <ZY0<br/><font color="gray" point-size="8.0"> </font>>]
    ZY0 -> TJ0
    ZY1 [label = <ZY1<br/><font color="gray" point-size="8.0"> </font>>]
    ZY1 -> TJ1
  }
  subgraph clusteridentifierList {
    node [shape = box]
    label = <identifierList = identifier | identifier "," identifierList .>
    labeljust = l
    identifierListR0C0 [label = <AJ<br/>N identifierList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    identifierListR0C1 [label = <AB<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR1C1 [label = <AC<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR2C1 [label = <AD<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR1C1 -> identifierListR2C1 [weight=100000000]
    identifierListR0C1 -> identifierListR1C1 [weight=100000000]
    identifierListR0C2 [label = <AE<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR1C2 [label = <AF<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    identifierListR2C2 [label = <AG<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    identifierListR3C2 [label = <AH<br/>N identifierList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR4C2 [label = <AI<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    identifierListR3C2 -> identifierListR4C2 [weight=100000000]
    identifierListR2C2 -> identifierListR3C2 [weight=100000000]
    identifierListR1C2 -> identifierListR2C2 [weight=100000000]
    identifierListR0C2 -> identifierListR1C2 [weight=100000000]
    rank = same {identifierListR0C1 -> identifierListR0C2}
    rank = same {identifierListR0C0 -> identifierListR0C1}
    node [style = invis]
    edge [style = invis]
    identifierListR0C0 -> identifierListR1C0 [weight=100000000]
    rank = same {identifierListR1C0 -> identifierListR1C1}
    identifierListR1C0 -> identifierListR2C0 [weight=100000000]
    rank = same {identifierListR2C0 -> identifierListR2C1}
    identifierListR2C0 -> identifierListR3C0 [weight=100000000]
    identifierListR2C1 -> identifierListR3C1 [weight=100000000]
    rank = same {identifierListR3C0 -> identifierListR3C1}
    rank = same {identifierListR3C1 -> identifierListR3C2}
    identifierListR3C0 -> identifierListR4C0 [weight=100000000]
    identifierListR3C1 -> identifierListR4C1 [weight=100000000]
    rank = same {identifierListR4C0 -> identifierListR4C1}
    rank = same {identifierListR4C1 -> identifierListR4C2}
  }
  subgraph clusterfunctionCallArgumentClause {
    node [shape = box]
    label = <functionCallArgumentClause = "(" ")" | "(" functionCallArgumentList ")" .>
    labeljust = l
    functionCallArgumentClauseR0C0 [label = <APU<br/>N functionCallArgumentClause<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    functionCallArgumentClauseR0C1 [label = <APL<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR1C1 [label = <APM<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    functionCallArgumentClauseR2C1 [label = <APN<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR3C1 [label = <APO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR2C1 -> functionCallArgumentClauseR3C1 [weight=100000000]
    functionCallArgumentClauseR1C1 -> functionCallArgumentClauseR2C1 [weight=100000000]
    functionCallArgumentClauseR0C1 -> functionCallArgumentClauseR1C1 [weight=100000000]
    functionCallArgumentClauseR0C2 [label = <APP<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR1C2 [label = <APQ<br/>T "("<br/>fi ["("]<br/>fo [")", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    functionCallArgumentClauseR2C2 [label = <APR<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    functionCallArgumentClauseR3C2 [label = <APS<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR4C2 [label = <APT<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallArgumentClauseR3C2 -> functionCallArgumentClauseR4C2 [weight=100000000]
    functionCallArgumentClauseR2C2 -> functionCallArgumentClauseR3C2 [weight=100000000]
    functionCallArgumentClauseR1C2 -> functionCallArgumentClauseR2C2 [weight=100000000]
    functionCallArgumentClauseR0C2 -> functionCallArgumentClauseR1C2 [weight=100000000]
    rank = same {functionCallArgumentClauseR0C1 -> functionCallArgumentClauseR0C2}
    rank = same {functionCallArgumentClauseR0C0 -> functionCallArgumentClauseR0C1}
    node [style = invis]
    edge [style = invis]
    functionCallArgumentClauseR0C0 -> functionCallArgumentClauseR1C0 [weight=100000000]
    rank = same {functionCallArgumentClauseR1C0 -> functionCallArgumentClauseR1C1}
    functionCallArgumentClauseR1C0 -> functionCallArgumentClauseR2C0 [weight=100000000]
    rank = same {functionCallArgumentClauseR2C0 -> functionCallArgumentClauseR2C1}
    functionCallArgumentClauseR2C0 -> functionCallArgumentClauseR3C0 [weight=100000000]
    rank = same {functionCallArgumentClauseR3C0 -> functionCallArgumentClauseR3C1}
    functionCallArgumentClauseR3C0 -> functionCallArgumentClauseR4C0 [weight=100000000]
    functionCallArgumentClauseR3C1 -> functionCallArgumentClauseR4C1 [weight=100000000]
    rank = same {functionCallArgumentClauseR4C0 -> functionCallArgumentClauseR4C1}
    rank = same {functionCallArgumentClauseR4C1 -> functionCallArgumentClauseR4C2}
  }
  subgraph clusterenumName {
    node [shape = box]
    label = <enumName = identifier .>
    labeljust = l
    enumNameR0C0 [label = <CWH<br/>N enumName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    enumNameR0C1 [label = <CWE<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    enumNameR1C1 [label = <CWF<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    enumNameR2C1 [label = <CWG<br/>END <br/>fi [""]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    enumNameR1C1 -> enumNameR2C1 [weight=100000000]
    enumNameR0C1 -> enumNameR1C1 [weight=100000000]
    rank = same {enumNameR0C0 -> enumNameR0C1}
    node [style = invis]
    edge [style = invis]
    enumNameR0C0 -> enumNameR1C0 [weight=100000000]
    rank = same {enumNameR1C0 -> enumNameR1C1}
    enumNameR1C0 -> enumNameR2C0 [weight=100000000]
    rank = same {enumNameR2C0 -> enumNameR2C1}
  }
  subgraph clusternilLiteral {
    node [shape = box]
    label = <nilLiteral = "nil" .>
    labeljust = l
    nilLiteralR0C0 [label = <CG<br/>N nilLiteral<br/>fi ["nil"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    nilLiteralR0C1 [label = <CD<br/>ALT <br/>fi ["nil"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    nilLiteralR1C1 [label = <CE<br/>T "nil"<br/>fi ["nil"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    nilLiteralR2C1 [label = <CF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    nilLiteralR1C1 -> nilLiteralR2C1 [weight=100000000]
    nilLiteralR0C1 -> nilLiteralR1C1 [weight=100000000]
    rank = same {nilLiteralR0C0 -> nilLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    nilLiteralR0C0 -> nilLiteralR1C0 [weight=100000000]
    rank = same {nilLiteralR1C0 -> nilLiteralR1C1}
    nilLiteralR1C0 -> nilLiteralR2C0 [weight=100000000]
    rank = same {nilLiteralR2C0 -> nilLiteralR2C1}
  }
  subgraph clusterunionStyleEnumCaseClause {
    node [shape = box]
    label = <unionStyleEnumCaseClause = [ attributes ] [ "indirect" ] "case" unionStyleEnumCaseList .>
    labeljust = l
    unionStyleEnumCaseClauseR0C0 [label = <CVM<br/>N unionStyleEnumCaseClause<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    unionStyleEnumCaseClauseR0C1 [label = <CVA<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    unionStyleEnumCaseClauseR1C1 [label = <CVE<br/>OPT <br/>fi ["", "@"]<br/>fo ["case", "indirect"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR2C1 [label = <CVI<br/>OPT <br/>fi ["", "indirect"]<br/>fo ["case"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR3C1 [label = <CVJ<br/>T "case"<br/>fi ["case"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR4C1 [label = <CVK<br/>N unionStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR5C1 [label = <CVL<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR4C1 -> unionStyleEnumCaseClauseR5C1 [weight=100000000]
    unionStyleEnumCaseClauseR3C1 -> unionStyleEnumCaseClauseR4C1 [weight=100000000]
    unionStyleEnumCaseClauseR2C1 -> unionStyleEnumCaseClauseR3C1 [weight=100000000]
    unionStyleEnumCaseClauseR2C2 [label = <CVG<br/>ALT <br/>fi ["indirect"]<br/>fo ["case"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR3C2 [label = <CVF<br/>T "indirect"<br/>fi ["indirect"]<br/>fo ["case"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR4C2 [label = <CVH<br/>END <br/>fi [""]<br/>fo ["case"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR3C2 -> unionStyleEnumCaseClauseR4C2 [weight=100000000]
    unionStyleEnumCaseClauseR2C2 -> unionStyleEnumCaseClauseR3C2 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR2C1 -> unionStyleEnumCaseClauseR2C2}
    unionStyleEnumCaseClauseR1C1 -> unionStyleEnumCaseClauseR2C1 [weight=100000000]
    unionStyleEnumCaseClauseR1C3 [label = <CVC<br/>ALT <br/>fi ["@"]<br/>fo ["case", "indirect"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR2C3 [label = <CVB<br/>N attributes<br/>fi ["@"]<br/>fo ["case", "indirect"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR3C3 [label = <CVD<br/>END <br/>fi [""]<br/>fo ["case", "indirect"]<br/>am []<br/>>]
    unionStyleEnumCaseClauseR2C3 -> unionStyleEnumCaseClauseR3C3 [weight=100000000]
    unionStyleEnumCaseClauseR1C3 -> unionStyleEnumCaseClauseR2C3 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR1C1 -> unionStyleEnumCaseClauseR1C3}
    unionStyleEnumCaseClauseR0C1 -> unionStyleEnumCaseClauseR1C1 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR0C0 -> unionStyleEnumCaseClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {unionStyleEnumCaseClauseR0C1 -> unionStyleEnumCaseClauseR0C2}
    rank = same {unionStyleEnumCaseClauseR0C2 -> unionStyleEnumCaseClauseR0C3}
    unionStyleEnumCaseClauseR0C0 -> unionStyleEnumCaseClauseR1C0 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR1C0 -> unionStyleEnumCaseClauseR1C1}
    unionStyleEnumCaseClauseR0C3 -> unionStyleEnumCaseClauseR1C3 [weight=100000000]
    unionStyleEnumCaseClauseR1C0 -> unionStyleEnumCaseClauseR2C0 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR2C0 -> unionStyleEnumCaseClauseR2C1}
    unionStyleEnumCaseClauseR2C0 -> unionStyleEnumCaseClauseR3C0 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR3C0 -> unionStyleEnumCaseClauseR3C1}
    unionStyleEnumCaseClauseR3C0 -> unionStyleEnumCaseClauseR4C0 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR4C0 -> unionStyleEnumCaseClauseR4C1}
    unionStyleEnumCaseClauseR3C3 -> unionStyleEnumCaseClauseR4C3 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR4C2 -> unionStyleEnumCaseClauseR4C3}
    unionStyleEnumCaseClauseR4C0 -> unionStyleEnumCaseClauseR5C0 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR5C0 -> unionStyleEnumCaseClauseR5C1}
    unionStyleEnumCaseClauseR4C2 -> unionStyleEnumCaseClauseR5C2 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR5C1 -> unionStyleEnumCaseClauseR5C2}
    unionStyleEnumCaseClauseR4C3 -> unionStyleEnumCaseClauseR5C3 [weight=100000000]
    rank = same {unionStyleEnumCaseClauseR5C2 -> unionStyleEnumCaseClauseR5C3}
  }
  subgraph clusterguardStatement {
    node [shape = box]
    label = <guardStatement = "guard" conditionList "else" codeBlock .>
    labeljust = l
    guardStatementR0C0 [label = <BBV<br/>N guardStatement<br/>fi ["guard"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    guardStatementR0C1 [label = <BBP<br/>ALT <br/>fi ["guard"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    guardStatementR1C1 [label = <BBQ<br/>T "guard"<br/>fi ["guard"]<br/>fo ["#available", "#unavailable", "case", "else", "let", "try", "var"]<br/>am []<br/>>]
    guardStatementR2C1 [label = <BBR<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else"]<br/>am []<br/>>]
    guardStatementR3C1 [label = <BBS<br/>T "else"<br/>fi ["else"]<br/>fo ["{"]<br/>am []<br/>>]
    guardStatementR4C1 [label = <BBT<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    guardStatementR5C1 [label = <BBU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    guardStatementR4C1 -> guardStatementR5C1 [weight=100000000]
    guardStatementR3C1 -> guardStatementR4C1 [weight=100000000]
    guardStatementR2C1 -> guardStatementR3C1 [weight=100000000]
    guardStatementR1C1 -> guardStatementR2C1 [weight=100000000]
    guardStatementR0C1 -> guardStatementR1C1 [weight=100000000]
    rank = same {guardStatementR0C0 -> guardStatementR0C1}
    node [style = invis]
    edge [style = invis]
    guardStatementR0C0 -> guardStatementR1C0 [weight=100000000]
    rank = same {guardStatementR1C0 -> guardStatementR1C1}
    guardStatementR1C0 -> guardStatementR2C0 [weight=100000000]
    rank = same {guardStatementR2C0 -> guardStatementR2C1}
    guardStatementR2C0 -> guardStatementR3C0 [weight=100000000]
    rank = same {guardStatementR3C0 -> guardStatementR3C1}
    guardStatementR3C0 -> guardStatementR4C0 [weight=100000000]
    rank = same {guardStatementR4C0 -> guardStatementR4C1}
    guardStatementR4C0 -> guardStatementR5C0 [weight=100000000]
    rank = same {guardStatementR5C0 -> guardStatementR5C1}
  }
  subgraph clusterparameter {
    node [shape = box]
    label = <parameter = [ externalParameterName ] localParameterName parameterTypeAnnotation [ defaultArgumentClause ] | [ externalParameterName ] localParameterName parameterTypeAnnotation | [ externalParameterName ] localParameterName parameterTypeAnnotation "..." .>
    labeljust = l
    parameterR0C0 [label = <CQI<br/>N parameter<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    parameterR0C1 [label = <CPW<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR1C1 [label = <CQA<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    parameterR2C1 [label = <CQB<br/>N localParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    parameterR3C1 [label = <CQC<br/>N parameterTypeAnnotation<br/>fi [":"]<br/>fo [")", ",", "="]<br/>am []<br/>>]
    parameterR4C1 [label = <CQG<br/>OPT <br/>fi ["", "="]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR5C1 [label = <CQH<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR4C1 -> parameterR5C1 [weight=100000000]
    parameterR4C2 [label = <CQE<br/>ALT <br/>fi ["="]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR5C2 [label = <CQD<br/>N defaultArgumentClause<br/>fi ["="]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR6C2 [label = <CQF<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR5C2 -> parameterR6C2 [weight=100000000]
    parameterR4C2 -> parameterR5C2 [weight=100000000]
    rank = same {parameterR4C1 -> parameterR4C2}
    parameterR3C1 -> parameterR4C1 [weight=100000000]
    parameterR2C1 -> parameterR3C1 [weight=100000000]
    parameterR1C1 -> parameterR2C1 [weight=100000000]
    parameterR1C3 [label = <CPY<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C3 [label = <CPX<br/>N externalParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR3C3 [label = <CPZ<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C3 -> parameterR3C3 [weight=100000000]
    parameterR1C3 -> parameterR2C3 [weight=100000000]
    rank = same {parameterR1C1 -> parameterR1C3}
    parameterR0C1 -> parameterR1C1 [weight=100000000]
    parameterR0C4 [label = <CQJ<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR1C4 [label = <CQN<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    parameterR2C4 [label = <CQO<br/>N localParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    parameterR3C4 [label = <CQP<br/>N parameterTypeAnnotation<br/>fi [":"]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR4C4 [label = <CQQ<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR3C4 -> parameterR4C4 [weight=100000000]
    parameterR2C4 -> parameterR3C4 [weight=100000000]
    parameterR1C4 -> parameterR2C4 [weight=100000000]
    parameterR1C5 [label = <CQL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C5 [label = <CQK<br/>N externalParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR3C5 [label = <CQM<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C5 -> parameterR3C5 [weight=100000000]
    parameterR1C5 -> parameterR2C5 [weight=100000000]
    rank = same {parameterR1C4 -> parameterR1C5}
    parameterR0C4 -> parameterR1C4 [weight=100000000]
    parameterR0C6 [label = <CQR<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR1C6 [label = <CQV<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    parameterR2C6 [label = <CQW<br/>N localParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    parameterR3C6 [label = <CQX<br/>N parameterTypeAnnotation<br/>fi [":"]<br/>fo ["..."]<br/>am []<br/>>]
    parameterR4C6 [label = <CQY<br/>T "..."<br/>fi ["..."]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR5C6 [label = <CQZ<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    parameterR4C6 -> parameterR5C6 [weight=100000000]
    parameterR3C6 -> parameterR4C6 [weight=100000000]
    parameterR2C6 -> parameterR3C6 [weight=100000000]
    parameterR1C6 -> parameterR2C6 [weight=100000000]
    parameterR1C7 [label = <CQT<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C7 [label = <CQS<br/>N externalParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR3C7 [label = <CQU<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterR2C7 -> parameterR3C7 [weight=100000000]
    parameterR1C7 -> parameterR2C7 [weight=100000000]
    rank = same {parameterR1C6 -> parameterR1C7}
    parameterR0C6 -> parameterR1C6 [weight=100000000]
    rank = same {parameterR0C4 -> parameterR0C6}
    rank = same {parameterR0C1 -> parameterR0C4}
    rank = same {parameterR0C0 -> parameterR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {parameterR0C6 -> parameterR0C7}
    parameterR0C0 -> parameterR1C0 [weight=100000000]
    rank = same {parameterR1C0 -> parameterR1C1}
    parameterR0C7 -> parameterR1C7 [weight=100000000]
    parameterR1C0 -> parameterR2C0 [weight=100000000]
    rank = same {parameterR2C0 -> parameterR2C1}
    rank = same {parameterR2C1 -> parameterR2C2}
    rank = same {parameterR2C2 -> parameterR2C3}
    parameterR2C0 -> parameterR3C0 [weight=100000000]
    rank = same {parameterR3C0 -> parameterR3C1}
    parameterR2C2 -> parameterR3C2 [weight=100000000]
    rank = same {parameterR3C1 -> parameterR3C2}
    rank = same {parameterR3C2 -> parameterR3C3}
    parameterR3C0 -> parameterR4C0 [weight=100000000]
    rank = same {parameterR4C0 -> parameterR4C1}
    parameterR3C2 -> parameterR4C2 [weight=100000000]
    parameterR3C3 -> parameterR4C3 [weight=100000000]
    rank = same {parameterR4C2 -> parameterR4C3}
    rank = same {parameterR4C3 -> parameterR4C4}
    parameterR3C5 -> parameterR4C5 [weight=100000000]
    rank = same {parameterR4C4 -> parameterR4C5}
    rank = same {parameterR4C5 -> parameterR4C6}
    parameterR3C7 -> parameterR4C7 [weight=100000000]
    rank = same {parameterR4C6 -> parameterR4C7}
    parameterR4C0 -> parameterR5C0 [weight=100000000]
    rank = same {parameterR5C0 -> parameterR5C1}
    parameterR4C3 -> parameterR5C3 [weight=100000000]
    rank = same {parameterR5C2 -> parameterR5C3}
    parameterR4C4 -> parameterR5C4 [weight=100000000]
    rank = same {parameterR5C3 -> parameterR5C4}
    parameterR4C5 -> parameterR5C5 [weight=100000000]
    rank = same {parameterR5C4 -> parameterR5C5}
    rank = same {parameterR5C5 -> parameterR5C6}
    parameterR4C7 -> parameterR5C7 [weight=100000000]
    rank = same {parameterR5C6 -> parameterR5C7}
    parameterR5C0 -> parameterR6C0 [weight=100000000]
    parameterR5C1 -> parameterR6C1 [weight=100000000]
    rank = same {parameterR6C0 -> parameterR6C1}
    rank = same {parameterR6C1 -> parameterR6C2}
    parameterR5C3 -> parameterR6C3 [weight=100000000]
    rank = same {parameterR6C2 -> parameterR6C3}
    parameterR5C4 -> parameterR6C4 [weight=100000000]
    rank = same {parameterR6C3 -> parameterR6C4}
    parameterR5C5 -> parameterR6C5 [weight=100000000]
    rank = same {parameterR6C4 -> parameterR6C5}
    parameterR5C6 -> parameterR6C6 [weight=100000000]
    rank = same {parameterR6C5 -> parameterR6C6}
    parameterR5C7 -> parameterR6C7 [weight=100000000]
    rank = same {parameterR6C6 -> parameterR6C7}
  }
  subgraph clusterexpression {
    node [shape = box]
    label = <expression = [ tryOperator ] [ awaitOperator ] prefixExpression [ infixExpressions ] .>
    labeljust = l
    expressionR0C0 [label = <OV<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionR0C1 [label = <OG<br/>ALT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionR1C1 [label = <OK<br/>OPT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionR2C1 [label = <OO<br/>OPT <br/>fi ["", "await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR3C1 [label = <OP<br/>N prefixExpression<br/>fi ["", "&amp;", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    expressionR4C1 [label = <OT<br/>OPT <br/>fi ["", "=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["=", "as"]<br/>>]
    expressionR5C1 [label = <OU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR4C1 -> expressionR5C1 [weight=100000000]
    expressionR4C2 [label = <OR<br/>ALT <br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR5C2 [label = <OQ<br/>N infixExpressions<br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR6C2 [label = <OS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR5C2 -> expressionR6C2 [weight=100000000]
    expressionR4C2 -> expressionR5C2 [weight=100000000]
    rank = same {expressionR4C1 -> expressionR4C2}
    expressionR3C1 -> expressionR4C1 [weight=100000000]
    expressionR2C1 -> expressionR3C1 [weight=100000000]
    expressionR2C3 [label = <OM<br/>ALT <br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR3C3 [label = <OL<br/>N awaitOperator<br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR4C3 [label = <ON<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR3C3 -> expressionR4C3 [weight=100000000]
    expressionR2C3 -> expressionR3C3 [weight=100000000]
    rank = same {expressionR2C1 -> expressionR2C3}
    expressionR1C1 -> expressionR2C1 [weight=100000000]
    expressionR1C4 [label = <OI<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR2C4 [label = <OH<br/>N tryOperator<br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR3C4 [label = <OJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionR2C4 -> expressionR3C4 [weight=100000000]
    expressionR1C4 -> expressionR2C4 [weight=100000000]
    rank = same {expressionR1C1 -> expressionR1C4}
    expressionR0C1 -> expressionR1C1 [weight=100000000]
    rank = same {expressionR0C0 -> expressionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {expressionR0C1 -> expressionR0C2}
    rank = same {expressionR0C2 -> expressionR0C3}
    rank = same {expressionR0C3 -> expressionR0C4}
    expressionR0C0 -> expressionR1C0 [weight=100000000]
    rank = same {expressionR1C0 -> expressionR1C1}
    expressionR0C4 -> expressionR1C4 [weight=100000000]
    expressionR1C0 -> expressionR2C0 [weight=100000000]
    rank = same {expressionR2C0 -> expressionR2C1}
    expressionR2C0 -> expressionR3C0 [weight=100000000]
    rank = same {expressionR3C0 -> expressionR3C1}
    rank = same {expressionR3C1 -> expressionR3C2}
    rank = same {expressionR3C2 -> expressionR3C3}
    expressionR3C0 -> expressionR4C0 [weight=100000000]
    rank = same {expressionR4C0 -> expressionR4C1}
    expressionR3C2 -> expressionR4C2 [weight=100000000]
    expressionR3C4 -> expressionR4C4 [weight=100000000]
    rank = same {expressionR4C3 -> expressionR4C4}
    expressionR4C0 -> expressionR5C0 [weight=100000000]
    rank = same {expressionR5C0 -> expressionR5C1}
    expressionR4C3 -> expressionR5C3 [weight=100000000]
    rank = same {expressionR5C2 -> expressionR5C3}
    expressionR4C4 -> expressionR5C4 [weight=100000000]
    rank = same {expressionR5C3 -> expressionR5C4}
    expressionR5C0 -> expressionR6C0 [weight=100000000]
    expressionR5C1 -> expressionR6C1 [weight=100000000]
    rank = same {expressionR6C0 -> expressionR6C1}
    rank = same {expressionR6C1 -> expressionR6C2}
    expressionR5C3 -> expressionR6C3 [weight=100000000]
    rank = same {expressionR6C2 -> expressionR6C3}
    expressionR5C4 -> expressionR6C4 [weight=100000000]
    rank = same {expressionR6C3 -> expressionR6C4}
  }
  subgraph clusterdeferStatement {
    node [shape = box]
    label = <deferStatement = "defer" codeBlock .>
    labeljust = l
    deferStatementR0C0 [label = <BJQ<br/>N deferStatement<br/>fi ["defer"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deferStatementR0C1 [label = <BJM<br/>ALT <br/>fi ["defer"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deferStatementR1C1 [label = <BJN<br/>T "defer"<br/>fi ["defer"]<br/>fo ["{"]<br/>am []<br/>>]
    deferStatementR2C1 [label = <BJO<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deferStatementR3C1 [label = <BJP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deferStatementR2C1 -> deferStatementR3C1 [weight=100000000]
    deferStatementR1C1 -> deferStatementR2C1 [weight=100000000]
    deferStatementR0C1 -> deferStatementR1C1 [weight=100000000]
    rank = same {deferStatementR0C0 -> deferStatementR0C1}
    node [style = invis]
    edge [style = invis]
    deferStatementR0C0 -> deferStatementR1C0 [weight=100000000]
    rank = same {deferStatementR1C0 -> deferStatementR1C1}
    deferStatementR1C0 -> deferStatementR2C0 [weight=100000000]
    rank = same {deferStatementR2C0 -> deferStatementR2C1}
    deferStatementR2C0 -> deferStatementR3C0 [weight=100000000]
    rank = same {deferStatementR3C0 -> deferStatementR3C1}
  }
  subgraph clusteractorIsolationModifier {
    node [shape = box]
    label = <actorIsolationModifier = "nonisolated" .>
    labeljust = l
    actorIsolationModifierR0C0 [label = <EFI<br/>N actorIsolationModifier<br/>fi ["nonisolated"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    actorIsolationModifierR0C1 [label = <EFF<br/>ALT <br/>fi ["nonisolated"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    actorIsolationModifierR1C1 [label = <EFG<br/>T "nonisolated"<br/>fi ["nonisolated"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    actorIsolationModifierR2C1 [label = <EFH<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    actorIsolationModifierR1C1 -> actorIsolationModifierR2C1 [weight=100000000]
    actorIsolationModifierR0C1 -> actorIsolationModifierR1C1 [weight=100000000]
    rank = same {actorIsolationModifierR0C0 -> actorIsolationModifierR0C1}
    node [style = invis]
    edge [style = invis]
    actorIsolationModifierR0C0 -> actorIsolationModifierR1C0 [weight=100000000]
    rank = same {actorIsolationModifierR1C0 -> actorIsolationModifierR1C1}
    actorIsolationModifierR1C0 -> actorIsolationModifierR2C0 [weight=100000000]
    rank = same {actorIsolationModifierR2C0 -> actorIsolationModifierR2C1}
  }
  subgraph clustergetterClause {
    node [shape = box]
    label = <getterClause = [ attributes ] [ mutationModifier ] "get" codeBlock .>
    labeljust = l
    getterClauseR0C0 [label = <CGX<br/>N getterClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterClauseR0C1 [label = <CGL<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterClauseR1C1 [label = <CGP<br/>OPT <br/>fi ["", "@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterClauseR2C1 [label = <CGT<br/>OPT <br/>fi ["", "mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterClauseR3C1 [label = <CGU<br/>T "get"<br/>fi ["get"]<br/>fo ["{"]<br/>am []<br/>>]
    getterClauseR4C1 [label = <CGV<br/>N codeBlock<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterClauseR5C1 [label = <CGW<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterClauseR4C1 -> getterClauseR5C1 [weight=100000000]
    getterClauseR3C1 -> getterClauseR4C1 [weight=100000000]
    getterClauseR2C1 -> getterClauseR3C1 [weight=100000000]
    getterClauseR2C2 [label = <CGR<br/>ALT <br/>fi ["mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterClauseR3C2 [label = <CGQ<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterClauseR4C2 [label = <CGS<br/>END <br/>fi [""]<br/>fo ["get"]<br/>am []<br/>>]
    getterClauseR3C2 -> getterClauseR4C2 [weight=100000000]
    getterClauseR2C2 -> getterClauseR3C2 [weight=100000000]
    rank = same {getterClauseR2C1 -> getterClauseR2C2}
    getterClauseR1C1 -> getterClauseR2C1 [weight=100000000]
    getterClauseR1C3 [label = <CGN<br/>ALT <br/>fi ["@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterClauseR2C3 [label = <CGM<br/>N attributes<br/>fi ["@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterClauseR3C3 [label = <CGO<br/>END <br/>fi [""]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterClauseR2C3 -> getterClauseR3C3 [weight=100000000]
    getterClauseR1C3 -> getterClauseR2C3 [weight=100000000]
    rank = same {getterClauseR1C1 -> getterClauseR1C3}
    getterClauseR0C1 -> getterClauseR1C1 [weight=100000000]
    rank = same {getterClauseR0C0 -> getterClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {getterClauseR0C1 -> getterClauseR0C2}
    rank = same {getterClauseR0C2 -> getterClauseR0C3}
    getterClauseR0C0 -> getterClauseR1C0 [weight=100000000]
    rank = same {getterClauseR1C0 -> getterClauseR1C1}
    getterClauseR0C3 -> getterClauseR1C3 [weight=100000000]
    getterClauseR1C0 -> getterClauseR2C0 [weight=100000000]
    rank = same {getterClauseR2C0 -> getterClauseR2C1}
    getterClauseR2C0 -> getterClauseR3C0 [weight=100000000]
    rank = same {getterClauseR3C0 -> getterClauseR3C1}
    getterClauseR3C0 -> getterClauseR4C0 [weight=100000000]
    rank = same {getterClauseR4C0 -> getterClauseR4C1}
    getterClauseR3C3 -> getterClauseR4C3 [weight=100000000]
    rank = same {getterClauseR4C2 -> getterClauseR4C3}
    getterClauseR4C0 -> getterClauseR5C0 [weight=100000000]
    rank = same {getterClauseR5C0 -> getterClauseR5C1}
    getterClauseR4C2 -> getterClauseR5C2 [weight=100000000]
    rank = same {getterClauseR5C1 -> getterClauseR5C2}
    getterClauseR4C3 -> getterClauseR5C3 [weight=100000000]
    rank = same {getterClauseR5C2 -> getterClauseR5C3}
  }
  subgraph clusterclosureParameterList {
    node [shape = box]
    label = <closureParameterList = closureParameter | closureParameter "," closureParameterList .>
    labeljust = l
    closureParameterListR0C0 [label = <AFK<br/>N closureParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    closureParameterListR0C1 [label = <AFC<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR1C1 [label = <AFD<br/>N closureParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR2C1 [label = <AFE<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR1C1 -> closureParameterListR2C1 [weight=100000000]
    closureParameterListR0C1 -> closureParameterListR1C1 [weight=100000000]
    closureParameterListR0C2 [label = <AFF<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR1C2 [label = <AFG<br/>N closureParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    closureParameterListR2C2 [label = <AFH<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureParameterListR3C2 [label = <AFI<br/>N closureParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR4C2 [label = <AFJ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterListR3C2 -> closureParameterListR4C2 [weight=100000000]
    closureParameterListR2C2 -> closureParameterListR3C2 [weight=100000000]
    closureParameterListR1C2 -> closureParameterListR2C2 [weight=100000000]
    closureParameterListR0C2 -> closureParameterListR1C2 [weight=100000000]
    rank = same {closureParameterListR0C1 -> closureParameterListR0C2}
    rank = same {closureParameterListR0C0 -> closureParameterListR0C1}
    node [style = invis]
    edge [style = invis]
    closureParameterListR0C0 -> closureParameterListR1C0 [weight=100000000]
    rank = same {closureParameterListR1C0 -> closureParameterListR1C1}
    closureParameterListR1C0 -> closureParameterListR2C0 [weight=100000000]
    rank = same {closureParameterListR2C0 -> closureParameterListR2C1}
    closureParameterListR2C0 -> closureParameterListR3C0 [weight=100000000]
    closureParameterListR2C1 -> closureParameterListR3C1 [weight=100000000]
    rank = same {closureParameterListR3C0 -> closureParameterListR3C1}
    rank = same {closureParameterListR3C1 -> closureParameterListR3C2}
    closureParameterListR3C0 -> closureParameterListR4C0 [weight=100000000]
    closureParameterListR3C1 -> closureParameterListR4C1 [weight=100000000]
    rank = same {closureParameterListR4C0 -> closureParameterListR4C1}
    rank = same {closureParameterListR4C1 -> closureParameterListR4C2}
  }
  subgraph clusterbalancedTokens {
    node [shape = box]
    label = <balancedTokens = balancedToken [ balancedTokens ] .>
    labeljust = l
    balancedTokensR0C0 [label = <EHD<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR0C1 [label = <EGW<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR1C1 [label = <EGX<br/>N balancedToken<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR2C1 [label = <EHB<br/>OPT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR3C1 [label = <EHC<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokensR2C1 -> balancedTokensR3C1 [weight=100000000]
    balancedTokensR2C2 [label = <EGZ<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR3C2 [label = <EGY<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokensR4C2 [label = <EHA<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokensR3C2 -> balancedTokensR4C2 [weight=100000000]
    balancedTokensR2C2 -> balancedTokensR3C2 [weight=100000000]
    rank = same {balancedTokensR2C1 -> balancedTokensR2C2}
    balancedTokensR1C1 -> balancedTokensR2C1 [weight=100000000]
    balancedTokensR0C1 -> balancedTokensR1C1 [weight=100000000]
    rank = same {balancedTokensR0C0 -> balancedTokensR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {balancedTokensR0C1 -> balancedTokensR0C2}
    balancedTokensR0C0 -> balancedTokensR1C0 [weight=100000000]
    rank = same {balancedTokensR1C0 -> balancedTokensR1C1}
    balancedTokensR0C2 -> balancedTokensR1C2 [weight=100000000]
    rank = same {balancedTokensR1C1 -> balancedTokensR1C2}
    balancedTokensR1C0 -> balancedTokensR2C0 [weight=100000000]
    rank = same {balancedTokensR2C0 -> balancedTokensR2C1}
    balancedTokensR1C2 -> balancedTokensR2C2 [weight=100000000]
    balancedTokensR2C0 -> balancedTokensR3C0 [weight=100000000]
    rank = same {balancedTokensR3C0 -> balancedTokensR3C1}
    balancedTokensR3C0 -> balancedTokensR4C0 [weight=100000000]
    balancedTokensR3C1 -> balancedTokensR4C1 [weight=100000000]
    rank = same {balancedTokensR4C0 -> balancedTokensR4C1}
    rank = same {balancedTokensR4C1 -> balancedTokensR4C2}
  }
  subgraph clusterclassBody {
    node [shape = box]
    label = <classBody = "{" [ classMembers ] "}" .>
    labeljust = l
    classBodyR0C0 [label = <DEC<br/>N classBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classBodyR0C1 [label = <DDU<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classBodyR1C1 [label = <DDV<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    classBodyR2C1 [label = <DDZ<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classBodyR3C1 [label = <DEA<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classBodyR4C1 [label = <DEB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classBodyR3C1 -> classBodyR4C1 [weight=100000000]
    classBodyR2C1 -> classBodyR3C1 [weight=100000000]
    classBodyR2C2 [label = <DDX<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classBodyR3C2 [label = <DDW<br/>N classMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classBodyR4C2 [label = <DDY<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    classBodyR3C2 -> classBodyR4C2 [weight=100000000]
    classBodyR2C2 -> classBodyR3C2 [weight=100000000]
    rank = same {classBodyR2C1 -> classBodyR2C2}
    classBodyR1C1 -> classBodyR2C1 [weight=100000000]
    classBodyR0C1 -> classBodyR1C1 [weight=100000000]
    rank = same {classBodyR0C0 -> classBodyR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {classBodyR0C1 -> classBodyR0C2}
    classBodyR0C0 -> classBodyR1C0 [weight=100000000]
    rank = same {classBodyR1C0 -> classBodyR1C1}
    classBodyR0C2 -> classBodyR1C2 [weight=100000000]
    rank = same {classBodyR1C1 -> classBodyR1C2}
    classBodyR1C0 -> classBodyR2C0 [weight=100000000]
    rank = same {classBodyR2C0 -> classBodyR2C1}
    classBodyR1C2 -> classBodyR2C2 [weight=100000000]
    classBodyR2C0 -> classBodyR3C0 [weight=100000000]
    rank = same {classBodyR3C0 -> classBodyR3C1}
    classBodyR3C0 -> classBodyR4C0 [weight=100000000]
    rank = same {classBodyR4C0 -> classBodyR4C1}
  }
  subgraph clustercaseCondition {
    node [shape = box]
    label = <caseCondition = "case" pattern initializer .>
    labeljust = l
    caseConditionR0C0 [label = <AZN<br/>N caseCondition<br/>fi ["case"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    caseConditionR0C1 [label = <AZI<br/>ALT <br/>fi ["case"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    caseConditionR1C1 [label = <AZJ<br/>T "case"<br/>fi ["case"]<br/>fo ["(", "=", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    caseConditionR2C1 [label = <AZK<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["="]<br/>am []<br/>>]
    caseConditionR3C1 [label = <AZL<br/>N initializer<br/>fi ["="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    caseConditionR4C1 [label = <AZM<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    caseConditionR3C1 -> caseConditionR4C1 [weight=100000000]
    caseConditionR2C1 -> caseConditionR3C1 [weight=100000000]
    caseConditionR1C1 -> caseConditionR2C1 [weight=100000000]
    caseConditionR0C1 -> caseConditionR1C1 [weight=100000000]
    rank = same {caseConditionR0C0 -> caseConditionR0C1}
    node [style = invis]
    edge [style = invis]
    caseConditionR0C0 -> caseConditionR1C0 [weight=100000000]
    rank = same {caseConditionR1C0 -> caseConditionR1C1}
    caseConditionR1C0 -> caseConditionR2C0 [weight=100000000]
    rank = same {caseConditionR2C0 -> caseConditionR2C1}
    caseConditionR2C0 -> caseConditionR3C0 [weight=100000000]
    rank = same {caseConditionR3C0 -> caseConditionR3C1}
    caseConditionR3C0 -> caseConditionR4C0 [weight=100000000]
    rank = same {caseConditionR4C0 -> caseConditionR4C1}
  }
  subgraph clusterattributeName {
    node [shape = box]
    label = <attributeName = identifier .>
    labeljust = l
    attributeNameR0C0 [label = <EFV<br/>N attributeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeNameR0C1 [label = <EFS<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeNameR1C1 [label = <EFT<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeNameR2C1 [label = <EFU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeNameR1C1 -> attributeNameR2C1 [weight=100000000]
    attributeNameR0C1 -> attributeNameR1C1 [weight=100000000]
    rank = same {attributeNameR0C0 -> attributeNameR0C1}
    node [style = invis]
    edge [style = invis]
    attributeNameR0C0 -> attributeNameR1C0 [weight=100000000]
    rank = same {attributeNameR1C0 -> attributeNameR1C1}
    attributeNameR1C0 -> attributeNameR2C0 [weight=100000000]
    rank = same {attributeNameR2C0 -> attributeNameR2C1}
  }
  subgraph clusterpostfixSelfExpression {
    node [shape = box]
    label = <postfixSelfExpression = postfixExpression "." "self" .>
    labeljust = l
    postfixSelfExpressionR0C0 [label = <ATY<br/>N postfixSelfExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixSelfExpressionR0C1 [label = <ATT<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixSelfExpressionR1C1 [label = <ATU<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    postfixSelfExpressionR2C1 [label = <ATV<br/>T "."<br/>fi ["."]<br/>fo ["self"]<br/>am []<br/>>]
    postfixSelfExpressionR3C1 [label = <ATW<br/>T "self"<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixSelfExpressionR4C1 [label = <ATX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixSelfExpressionR3C1 -> postfixSelfExpressionR4C1 [weight=100000000]
    postfixSelfExpressionR2C1 -> postfixSelfExpressionR3C1 [weight=100000000]
    postfixSelfExpressionR1C1 -> postfixSelfExpressionR2C1 [weight=100000000]
    postfixSelfExpressionR0C1 -> postfixSelfExpressionR1C1 [weight=100000000]
    rank = same {postfixSelfExpressionR0C0 -> postfixSelfExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    postfixSelfExpressionR0C0 -> postfixSelfExpressionR1C0 [weight=100000000]
    rank = same {postfixSelfExpressionR1C0 -> postfixSelfExpressionR1C1}
    postfixSelfExpressionR1C0 -> postfixSelfExpressionR2C0 [weight=100000000]
    rank = same {postfixSelfExpressionR2C0 -> postfixSelfExpressionR2C1}
    postfixSelfExpressionR2C0 -> postfixSelfExpressionR3C0 [weight=100000000]
    rank = same {postfixSelfExpressionR3C0 -> postfixSelfExpressionR3C1}
    postfixSelfExpressionR3C0 -> postfixSelfExpressionR4C0 [weight=100000000]
    rank = same {postfixSelfExpressionR4C0 -> postfixSelfExpressionR4C1}
  }
  subgraph clusterrequirementList {
    node [shape = box]
    label = <requirementList = requirement | requirement "," requirementList .>
    labeljust = l
    requirementListR0C0 [label = <EPC<br/>N requirementList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    requirementListR0C1 [label = <EOU<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR1C1 [label = <EOV<br/>N requirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR2C1 [label = <EOW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR1C1 -> requirementListR2C1 [weight=100000000]
    requirementListR0C1 -> requirementListR1C1 [weight=100000000]
    requirementListR0C2 [label = <EOX<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR1C2 [label = <EOY<br/>N requirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    requirementListR2C2 [label = <EOZ<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    requirementListR3C2 [label = <EPA<br/>N requirementList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR4C2 [label = <EPB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementListR3C2 -> requirementListR4C2 [weight=100000000]
    requirementListR2C2 -> requirementListR3C2 [weight=100000000]
    requirementListR1C2 -> requirementListR2C2 [weight=100000000]
    requirementListR0C2 -> requirementListR1C2 [weight=100000000]
    rank = same {requirementListR0C1 -> requirementListR0C2}
    rank = same {requirementListR0C0 -> requirementListR0C1}
    node [style = invis]
    edge [style = invis]
    requirementListR0C0 -> requirementListR1C0 [weight=100000000]
    rank = same {requirementListR1C0 -> requirementListR1C1}
    requirementListR1C0 -> requirementListR2C0 [weight=100000000]
    rank = same {requirementListR2C0 -> requirementListR2C1}
    requirementListR2C0 -> requirementListR3C0 [weight=100000000]
    requirementListR2C1 -> requirementListR3C1 [weight=100000000]
    rank = same {requirementListR3C0 -> requirementListR3C1}
    rank = same {requirementListR3C1 -> requirementListR3C2}
    requirementListR3C0 -> requirementListR4C0 [weight=100000000]
    requirementListR3C1 -> requirementListR4C1 [weight=100000000]
    rank = same {requirementListR4C0 -> requirementListR4C1}
    rank = same {requirementListR4C1 -> requirementListR4C2}
  }
  subgraph clusterpostfixExpression {
    node [shape = box]
    label = <postfixExpression = primaryExpression | postfixExpression postfixOperator | functionCallExpression | initializerExpression | explicitMemberExpression | postfixSelfExpression | subscriptExpression | forcedValueExpression | optionalChainingExpression .>
    labeljust = l
    postfixExpressionR0C0 [label = <ANY<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>>]
    postfixExpressionR0C1 [label = <ANV<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C1 [label = <ANW<br/>N primaryExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C1 [label = <ANX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C1 -> postfixExpressionR2C1 [weight=100000000]
    postfixExpressionR0C1 -> postfixExpressionR1C1 [weight=100000000]
    postfixExpressionR0C2 [label = <ANZ<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C2 [label = <AOA<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["dotOperator", "plainOperator"]<br/>am []<br/>>]
    postfixExpressionR2C2 [label = <AOB<br/>N postfixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR3C2 [label = <AOC<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C2 -> postfixExpressionR3C2 [weight=100000000]
    postfixExpressionR1C2 -> postfixExpressionR2C2 [weight=100000000]
    postfixExpressionR0C2 -> postfixExpressionR1C2 [weight=100000000]
    postfixExpressionR0C3 [label = <AOD<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C3 [label = <AOE<br/>N functionCallExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C3 [label = <AOF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C3 -> postfixExpressionR2C3 [weight=100000000]
    postfixExpressionR0C3 -> postfixExpressionR1C3 [weight=100000000]
    postfixExpressionR0C4 [label = <AOG<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C4 [label = <AOH<br/>N initializerExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C4 [label = <AOI<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C4 -> postfixExpressionR2C4 [weight=100000000]
    postfixExpressionR0C4 -> postfixExpressionR1C4 [weight=100000000]
    postfixExpressionR0C5 [label = <AOJ<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C5 [label = <AOK<br/>N explicitMemberExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C5 [label = <AOL<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C5 -> postfixExpressionR2C5 [weight=100000000]
    postfixExpressionR0C5 -> postfixExpressionR1C5 [weight=100000000]
    postfixExpressionR0C6 [label = <AOM<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C6 [label = <AON<br/>N postfixSelfExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C6 [label = <AOO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C6 -> postfixExpressionR2C6 [weight=100000000]
    postfixExpressionR0C6 -> postfixExpressionR1C6 [weight=100000000]
    postfixExpressionR0C7 [label = <AOP<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C7 [label = <AOQ<br/>N subscriptExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C7 [label = <AOR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C7 -> postfixExpressionR2C7 [weight=100000000]
    postfixExpressionR0C7 -> postfixExpressionR1C7 [weight=100000000]
    postfixExpressionR0C8 [label = <AOS<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C8 [label = <AOT<br/>N forcedValueExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C8 [label = <AOU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C8 -> postfixExpressionR2C8 [weight=100000000]
    postfixExpressionR0C8 -> postfixExpressionR1C8 [weight=100000000]
    postfixExpressionR0C9 [label = <AOV<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C9 [label = <AOW<br/>N optionalChainingExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR2C9 [label = <AOX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixExpressionR1C9 -> postfixExpressionR2C9 [weight=100000000]
    postfixExpressionR0C9 -> postfixExpressionR1C9 [weight=100000000]
    rank = same {postfixExpressionR0C8 -> postfixExpressionR0C9}
    rank = same {postfixExpressionR0C7 -> postfixExpressionR0C8}
    rank = same {postfixExpressionR0C6 -> postfixExpressionR0C7}
    rank = same {postfixExpressionR0C5 -> postfixExpressionR0C6}
    rank = same {postfixExpressionR0C4 -> postfixExpressionR0C5}
    rank = same {postfixExpressionR0C3 -> postfixExpressionR0C4}
    rank = same {postfixExpressionR0C2 -> postfixExpressionR0C3}
    rank = same {postfixExpressionR0C1 -> postfixExpressionR0C2}
    rank = same {postfixExpressionR0C0 -> postfixExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    postfixExpressionR0C0 -> postfixExpressionR1C0 [weight=100000000]
    rank = same {postfixExpressionR1C0 -> postfixExpressionR1C1}
    postfixExpressionR1C0 -> postfixExpressionR2C0 [weight=100000000]
    rank = same {postfixExpressionR2C0 -> postfixExpressionR2C1}
    postfixExpressionR2C0 -> postfixExpressionR3C0 [weight=100000000]
    postfixExpressionR2C1 -> postfixExpressionR3C1 [weight=100000000]
    rank = same {postfixExpressionR3C0 -> postfixExpressionR3C1}
    rank = same {postfixExpressionR3C1 -> postfixExpressionR3C2}
    postfixExpressionR2C3 -> postfixExpressionR3C3 [weight=100000000]
    rank = same {postfixExpressionR3C2 -> postfixExpressionR3C3}
    postfixExpressionR2C4 -> postfixExpressionR3C4 [weight=100000000]
    rank = same {postfixExpressionR3C3 -> postfixExpressionR3C4}
    postfixExpressionR2C5 -> postfixExpressionR3C5 [weight=100000000]
    rank = same {postfixExpressionR3C4 -> postfixExpressionR3C5}
    postfixExpressionR2C6 -> postfixExpressionR3C6 [weight=100000000]
    rank = same {postfixExpressionR3C5 -> postfixExpressionR3C6}
    postfixExpressionR2C7 -> postfixExpressionR3C7 [weight=100000000]
    rank = same {postfixExpressionR3C6 -> postfixExpressionR3C7}
    postfixExpressionR2C8 -> postfixExpressionR3C8 [weight=100000000]
    rank = same {postfixExpressionR3C7 -> postfixExpressionR3C8}
    postfixExpressionR2C9 -> postfixExpressionR3C9 [weight=100000000]
    rank = same {postfixExpressionR3C8 -> postfixExpressionR3C9}
  }
  subgraph clusterdeclarationModifiers {
    node [shape = box]
    label = <declarationModifiers = declarationModifier [ declarationModifiers ] .>
    labeljust = l
    declarationModifiersR0C0 [label = <ECU<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR0C1 [label = <ECN<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR1C1 [label = <ECO<br/>N declarationModifier<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifiersR2C1 [label = <ECS<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR3C1 [label = <ECT<br/>END <br/>fi [""]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR2C1 -> declarationModifiersR3C1 [weight=100000000]
    declarationModifiersR2C2 [label = <ECQ<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR3C2 [label = <ECP<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR4C2 [label = <ECR<br/>END <br/>fi [""]<br/>fo ["func", "init", "let", "macro", "subscript", "var"]<br/>am []<br/>>]
    declarationModifiersR3C2 -> declarationModifiersR4C2 [weight=100000000]
    declarationModifiersR2C2 -> declarationModifiersR3C2 [weight=100000000]
    rank = same {declarationModifiersR2C1 -> declarationModifiersR2C2}
    declarationModifiersR1C1 -> declarationModifiersR2C1 [weight=100000000]
    declarationModifiersR0C1 -> declarationModifiersR1C1 [weight=100000000]
    rank = same {declarationModifiersR0C0 -> declarationModifiersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {declarationModifiersR0C1 -> declarationModifiersR0C2}
    declarationModifiersR0C0 -> declarationModifiersR1C0 [weight=100000000]
    rank = same {declarationModifiersR1C0 -> declarationModifiersR1C1}
    declarationModifiersR0C2 -> declarationModifiersR1C2 [weight=100000000]
    rank = same {declarationModifiersR1C1 -> declarationModifiersR1C2}
    declarationModifiersR1C0 -> declarationModifiersR2C0 [weight=100000000]
    rank = same {declarationModifiersR2C0 -> declarationModifiersR2C1}
    declarationModifiersR1C2 -> declarationModifiersR2C2 [weight=100000000]
    declarationModifiersR2C0 -> declarationModifiersR3C0 [weight=100000000]
    rank = same {declarationModifiersR3C0 -> declarationModifiersR3C1}
    declarationModifiersR3C0 -> declarationModifiersR4C0 [weight=100000000]
    declarationModifiersR3C1 -> declarationModifiersR4C1 [weight=100000000]
    rank = same {declarationModifiersR4C0 -> declarationModifiersR4C1}
    rank = same {declarationModifiersR4C1 -> declarationModifiersR4C2}
  }
  subgraph clusterstructName {
    node [shape = box]
    label = <structName = identifier .>
    labeljust = l
    structNameR0C0 [label = <DAN<br/>N structName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    structNameR0C1 [label = <DAK<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    structNameR1C1 [label = <DAL<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    structNameR2C1 [label = <DAM<br/>END <br/>fi [""]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    structNameR1C1 -> structNameR2C1 [weight=100000000]
    structNameR0C1 -> structNameR1C1 [weight=100000000]
    rank = same {structNameR0C0 -> structNameR0C1}
    node [style = invis]
    edge [style = invis]
    structNameR0C0 -> structNameR1C0 [weight=100000000]
    rank = same {structNameR1C0 -> structNameR1C1}
    structNameR1C0 -> structNameR2C0 [weight=100000000]
    rank = same {structNameR2C0 -> structNameR2C1}
  }
  subgraph clusteroperatingSystem {
    node [shape = box]
    label = <operatingSystem = "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows" .>
    labeljust = l
    operatingSystemR0C0 [label = <BSG<br/>N operatingSystem<br/>fi ["Linux", "Windows", "iOS", "macOS", "tvOS", "visionOS", "watchOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR0C1 [label = <BRL<br/>ALT <br/>fi ["macOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C1 [label = <BRM<br/>T "macOS"<br/>fi ["macOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C1 [label = <BRN<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C1 -> operatingSystemR2C1 [weight=100000000]
    operatingSystemR0C1 -> operatingSystemR1C1 [weight=100000000]
    operatingSystemR0C2 [label = <BRO<br/>ALT <br/>fi ["iOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C2 [label = <BRP<br/>T "iOS"<br/>fi ["iOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C2 [label = <BRQ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C2 -> operatingSystemR2C2 [weight=100000000]
    operatingSystemR0C2 -> operatingSystemR1C2 [weight=100000000]
    operatingSystemR0C3 [label = <BRR<br/>ALT <br/>fi ["watchOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C3 [label = <BRS<br/>T "watchOS"<br/>fi ["watchOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C3 [label = <BRT<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C3 -> operatingSystemR2C3 [weight=100000000]
    operatingSystemR0C3 -> operatingSystemR1C3 [weight=100000000]
    operatingSystemR0C4 [label = <BRU<br/>ALT <br/>fi ["tvOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C4 [label = <BRV<br/>T "tvOS"<br/>fi ["tvOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C4 [label = <BRW<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C4 -> operatingSystemR2C4 [weight=100000000]
    operatingSystemR0C4 -> operatingSystemR1C4 [weight=100000000]
    operatingSystemR0C5 [label = <BRX<br/>ALT <br/>fi ["visionOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C5 [label = <BRY<br/>T "visionOS"<br/>fi ["visionOS"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C5 [label = <BRZ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C5 -> operatingSystemR2C5 [weight=100000000]
    operatingSystemR0C5 -> operatingSystemR1C5 [weight=100000000]
    operatingSystemR0C6 [label = <BSA<br/>ALT <br/>fi ["Linux"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C6 [label = <BSB<br/>T "Linux"<br/>fi ["Linux"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C6 [label = <BSC<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C6 -> operatingSystemR2C6 [weight=100000000]
    operatingSystemR0C6 -> operatingSystemR1C6 [weight=100000000]
    operatingSystemR0C7 [label = <BSD<br/>ALT <br/>fi ["Windows"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C7 [label = <BSE<br/>T "Windows"<br/>fi ["Windows"]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR2C7 [label = <BSF<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    operatingSystemR1C7 -> operatingSystemR2C7 [weight=100000000]
    operatingSystemR0C7 -> operatingSystemR1C7 [weight=100000000]
    rank = same {operatingSystemR0C6 -> operatingSystemR0C7}
    rank = same {operatingSystemR0C5 -> operatingSystemR0C6}
    rank = same {operatingSystemR0C4 -> operatingSystemR0C5}
    rank = same {operatingSystemR0C3 -> operatingSystemR0C4}
    rank = same {operatingSystemR0C2 -> operatingSystemR0C3}
    rank = same {operatingSystemR0C1 -> operatingSystemR0C2}
    rank = same {operatingSystemR0C0 -> operatingSystemR0C1}
    node [style = invis]
    edge [style = invis]
    operatingSystemR0C0 -> operatingSystemR1C0 [weight=100000000]
    rank = same {operatingSystemR1C0 -> operatingSystemR1C1}
    operatingSystemR1C0 -> operatingSystemR2C0 [weight=100000000]
    rank = same {operatingSystemR2C0 -> operatingSystemR2C1}
  }
  subgraph clusterlabeledTrailingClosure {
    node [shape = box]
    label = <labeledTrailingClosure = identifier ":" closureExpression .>
    labeljust = l
    labeledTrailingClosureR0C0 [label = <ARQ<br/>N labeledTrailingClosure<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosureR0C1 [label = <ARL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosureR1C1 [label = <ARM<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    labeledTrailingClosureR2C1 [label = <ARN<br/>T ":"<br/>fi [":"]<br/>fo ["{"]<br/>am []<br/>>]
    labeledTrailingClosureR3C1 [label = <ARO<br/>N closureExpression<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosureR4C1 [label = <ARP<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosureR3C1 -> labeledTrailingClosureR4C1 [weight=100000000]
    labeledTrailingClosureR2C1 -> labeledTrailingClosureR3C1 [weight=100000000]
    labeledTrailingClosureR1C1 -> labeledTrailingClosureR2C1 [weight=100000000]
    labeledTrailingClosureR0C1 -> labeledTrailingClosureR1C1 [weight=100000000]
    rank = same {labeledTrailingClosureR0C0 -> labeledTrailingClosureR0C1}
    node [style = invis]
    edge [style = invis]
    labeledTrailingClosureR0C0 -> labeledTrailingClosureR1C0 [weight=100000000]
    rank = same {labeledTrailingClosureR1C0 -> labeledTrailingClosureR1C1}
    labeledTrailingClosureR1C0 -> labeledTrailingClosureR2C0 [weight=100000000]
    rank = same {labeledTrailingClosureR2C0 -> labeledTrailingClosureR2C1}
    labeledTrailingClosureR2C0 -> labeledTrailingClosureR3C0 [weight=100000000]
    rank = same {labeledTrailingClosureR3C0 -> labeledTrailingClosureR3C1}
    labeledTrailingClosureR3C0 -> labeledTrailingClosureR4C0 [weight=100000000]
    rank = same {labeledTrailingClosureR4C0 -> labeledTrailingClosureR4C1}
  }
  subgraph clusterdefaultArgumentClause {
    node [shape = box]
    label = <defaultArgumentClause = "=" expression .>
    labeljust = l
    defaultArgumentClauseR0C0 [label = <CSJ<br/>N defaultArgumentClause<br/>fi ["="]<br/>fo [")", ","]<br/>am []<br/>>]
    defaultArgumentClauseR0C1 [label = <CSF<br/>ALT <br/>fi ["="]<br/>fo [")", ","]<br/>am []<br/>>]
    defaultArgumentClauseR1C1 [label = <CSG<br/>T "="<br/>fi ["="]<br/>fo [")", ",", "try"]<br/>am []<br/>>]
    defaultArgumentClauseR2C1 [label = <CSH<br/>N expression<br/>fi ["", "try"]<br/>fo [")", ","]<br/>am []<br/>>]
    defaultArgumentClauseR3C1 [label = <CSI<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    defaultArgumentClauseR2C1 -> defaultArgumentClauseR3C1 [weight=100000000]
    defaultArgumentClauseR1C1 -> defaultArgumentClauseR2C1 [weight=100000000]
    defaultArgumentClauseR0C1 -> defaultArgumentClauseR1C1 [weight=100000000]
    rank = same {defaultArgumentClauseR0C0 -> defaultArgumentClauseR0C1}
    node [style = invis]
    edge [style = invis]
    defaultArgumentClauseR0C0 -> defaultArgumentClauseR1C0 [weight=100000000]
    rank = same {defaultArgumentClauseR1C0 -> defaultArgumentClauseR1C1}
    defaultArgumentClauseR1C0 -> defaultArgumentClauseR2C0 [weight=100000000]
    rank = same {defaultArgumentClauseR2C0 -> defaultArgumentClauseR2C1}
    defaultArgumentClauseR2C0 -> defaultArgumentClauseR3C0 [weight=100000000]
    rank = same {defaultArgumentClauseR3C0 -> defaultArgumentClauseR3C1}
  }
  subgraph clusteridentifier {
    node [shape = box]
    label = <identifier = "plainIdentifier" | "escapedIdentifier" | "implicitParameterName" | "propertyWrapperProjection" .>
    labeljust = l
    identifierR0C0 [label = <AA<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR0C1 [label = <O<br/>ALT <br/>fi ["plainIdentifier"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C1 [label = <P<br/>T "plainIdentifier"<br/>fi ["plainIdentifier"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR2C1 [label = <Q<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C1 -> identifierR2C1 [weight=100000000]
    identifierR0C1 -> identifierR1C1 [weight=100000000]
    identifierR0C2 [label = <R<br/>ALT <br/>fi ["escapedIdentifier"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C2 [label = <S<br/>T "escapedIdentifier"<br/>fi ["escapedIdentifier"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR2C2 [label = <T<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C2 -> identifierR2C2 [weight=100000000]
    identifierR0C2 -> identifierR1C2 [weight=100000000]
    identifierR0C3 [label = <U<br/>ALT <br/>fi ["implicitParameterName"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C3 [label = <V<br/>T "implicitParameterName"<br/>fi ["implicitParameterName"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR2C3 [label = <W<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C3 -> identifierR2C3 [weight=100000000]
    identifierR0C3 -> identifierR1C3 [weight=100000000]
    identifierR0C4 [label = <X<br/>ALT <br/>fi ["propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C4 [label = <Y<br/>T "propertyWrapperProjection"<br/>fi ["propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR2C4 [label = <Z<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "&amp;&amp;", "(", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "Any", "Self", "[", "]", "actor", "as", "assignment", "associatedtype", "associativity", "async", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dotOperator", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "higherThan", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "is", "lazy", "let", "lowerThan", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "self", "set", "some", "static", "struct", "subscript", "switch", "throw", "throws", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "||", "}"]<br/>am []<br/>>]
    identifierR1C4 -> identifierR2C4 [weight=100000000]
    identifierR0C4 -> identifierR1C4 [weight=100000000]
    rank = same {identifierR0C3 -> identifierR0C4}
    rank = same {identifierR0C2 -> identifierR0C3}
    rank = same {identifierR0C1 -> identifierR0C2}
    rank = same {identifierR0C0 -> identifierR0C1}
    node [style = invis]
    edge [style = invis]
    identifierR0C0 -> identifierR1C0 [weight=100000000]
    rank = same {identifierR1C0 -> identifierR1C1}
    identifierR1C0 -> identifierR2C0 [weight=100000000]
    rank = same {identifierR2C0 -> identifierR2C1}
  }
  subgraph clustermacroFunctionSignatureResult {
    node [shape = box]
    label = <macroFunctionSignatureResult = "&gt;" type .>
    labeljust = l
    macroFunctionSignatureResultR0C0 [label = <DVN<br/>N macroFunctionSignatureResult<br/>fi ["&gt;"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroFunctionSignatureResultR0C1 [label = <DVJ<br/>ALT <br/>fi ["&gt;"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroFunctionSignatureResultR1C1 [label = <DVK<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["(", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where"]<br/>am []<br/>>]
    macroFunctionSignatureResultR2C1 [label = <DVL<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroFunctionSignatureResultR3C1 [label = <DVM<br/>END <br/>fi [""]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroFunctionSignatureResultR2C1 -> macroFunctionSignatureResultR3C1 [weight=100000000]
    macroFunctionSignatureResultR1C1 -> macroFunctionSignatureResultR2C1 [weight=100000000]
    macroFunctionSignatureResultR0C1 -> macroFunctionSignatureResultR1C1 [weight=100000000]
    rank = same {macroFunctionSignatureResultR0C0 -> macroFunctionSignatureResultR0C1}
    node [style = invis]
    edge [style = invis]
    macroFunctionSignatureResultR0C0 -> macroFunctionSignatureResultR1C0 [weight=100000000]
    rank = same {macroFunctionSignatureResultR1C0 -> macroFunctionSignatureResultR1C1}
    macroFunctionSignatureResultR1C0 -> macroFunctionSignatureResultR2C0 [weight=100000000]
    rank = same {macroFunctionSignatureResultR2C0 -> macroFunctionSignatureResultR2C1}
    macroFunctionSignatureResultR2C0 -> macroFunctionSignatureResultR3C0 [weight=100000000]
    rank = same {macroFunctionSignatureResultR3C0 -> macroFunctionSignatureResultR3C1}
  }
  subgraph clusterexplicitMemberExpression {
    node [shape = box]
    label = <explicitMemberExpression = postfixExpression "." "decimalDigits" | postfixExpression "." identifier [ genericArgumentClause ] | postfixExpression "." identifier "(" argumentNames ")" | postfixExpression conditionalCompilationBlock .>
    labeljust = l
    explicitMemberExpressionR0C0 [label = <ASK<br/>N explicitMemberExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>>]
    explicitMemberExpressionR0C1 [label = <ASF<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR1C1 [label = <ASG<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    explicitMemberExpressionR2C1 [label = <ASH<br/>T "."<br/>fi ["."]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    explicitMemberExpressionR3C1 [label = <ASI<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR4C1 [label = <ASJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR3C1 -> explicitMemberExpressionR4C1 [weight=100000000]
    explicitMemberExpressionR2C1 -> explicitMemberExpressionR3C1 [weight=100000000]
    explicitMemberExpressionR1C1 -> explicitMemberExpressionR2C1 [weight=100000000]
    explicitMemberExpressionR0C1 -> explicitMemberExpressionR1C1 [weight=100000000]
    explicitMemberExpressionR0C2 [label = <ASL<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR1C2 [label = <ASM<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    explicitMemberExpressionR2C2 [label = <ASN<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    explicitMemberExpressionR3C2 [label = <ASO<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR4C2 [label = <ASS<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR5C2 [label = <AST<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR4C2 -> explicitMemberExpressionR5C2 [weight=100000000]
    explicitMemberExpressionR4C3 [label = <ASQ<br/>ALT <br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR5C3 [label = <ASP<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR6C3 [label = <ASR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR5C3 -> explicitMemberExpressionR6C3 [weight=100000000]
    explicitMemberExpressionR4C3 -> explicitMemberExpressionR5C3 [weight=100000000]
    rank = same {explicitMemberExpressionR4C2 -> explicitMemberExpressionR4C3}
    explicitMemberExpressionR3C2 -> explicitMemberExpressionR4C2 [weight=100000000]
    explicitMemberExpressionR2C2 -> explicitMemberExpressionR3C2 [weight=100000000]
    explicitMemberExpressionR1C2 -> explicitMemberExpressionR2C2 [weight=100000000]
    explicitMemberExpressionR0C2 -> explicitMemberExpressionR1C2 [weight=100000000]
    explicitMemberExpressionR0C4 [label = <ASU<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR1C4 [label = <ASV<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    explicitMemberExpressionR2C4 [label = <ASW<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    explicitMemberExpressionR3C4 [label = <ASX<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["("]<br/>am []<br/>>]
    explicitMemberExpressionR4C4 [label = <ASY<br/>T "("<br/>fi ["("]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    explicitMemberExpressionR5C4 [label = <ASZ<br/>N argumentNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    explicitMemberExpressionR6C4 [label = <ATA<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR7C4 [label = <ATB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR6C4 -> explicitMemberExpressionR7C4 [weight=100000000]
    explicitMemberExpressionR5C4 -> explicitMemberExpressionR6C4 [weight=100000000]
    explicitMemberExpressionR4C4 -> explicitMemberExpressionR5C4 [weight=100000000]
    explicitMemberExpressionR3C4 -> explicitMemberExpressionR4C4 [weight=100000000]
    explicitMemberExpressionR2C4 -> explicitMemberExpressionR3C4 [weight=100000000]
    explicitMemberExpressionR1C4 -> explicitMemberExpressionR2C4 [weight=100000000]
    explicitMemberExpressionR0C4 -> explicitMemberExpressionR1C4 [weight=100000000]
    explicitMemberExpressionR0C5 [label = <ATC<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR1C5 [label = <ATD<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["#if"]<br/>am []<br/>>]
    explicitMemberExpressionR2C5 [label = <ATE<br/>N conditionalCompilationBlock<br/>fi ["#if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR3C5 [label = <ATF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    explicitMemberExpressionR2C5 -> explicitMemberExpressionR3C5 [weight=100000000]
    explicitMemberExpressionR1C5 -> explicitMemberExpressionR2C5 [weight=100000000]
    explicitMemberExpressionR0C5 -> explicitMemberExpressionR1C5 [weight=100000000]
    rank = same {explicitMemberExpressionR0C4 -> explicitMemberExpressionR0C5}
    rank = same {explicitMemberExpressionR0C2 -> explicitMemberExpressionR0C4}
    rank = same {explicitMemberExpressionR0C1 -> explicitMemberExpressionR0C2}
    rank = same {explicitMemberExpressionR0C0 -> explicitMemberExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    explicitMemberExpressionR0C0 -> explicitMemberExpressionR1C0 [weight=100000000]
    rank = same {explicitMemberExpressionR1C0 -> explicitMemberExpressionR1C1}
    rank = same {explicitMemberExpressionR1C2 -> explicitMemberExpressionR1C3}
    rank = same {explicitMemberExpressionR1C3 -> explicitMemberExpressionR1C4}
    explicitMemberExpressionR1C0 -> explicitMemberExpressionR2C0 [weight=100000000]
    rank = same {explicitMemberExpressionR2C0 -> explicitMemberExpressionR2C1}
    explicitMemberExpressionR1C3 -> explicitMemberExpressionR2C3 [weight=100000000]
    rank = same {explicitMemberExpressionR2C2 -> explicitMemberExpressionR2C3}
    rank = same {explicitMemberExpressionR2C3 -> explicitMemberExpressionR2C4}
    explicitMemberExpressionR2C0 -> explicitMemberExpressionR3C0 [weight=100000000]
    rank = same {explicitMemberExpressionR3C0 -> explicitMemberExpressionR3C1}
    explicitMemberExpressionR2C3 -> explicitMemberExpressionR3C3 [weight=100000000]
    rank = same {explicitMemberExpressionR3C2 -> explicitMemberExpressionR3C3}
    rank = same {explicitMemberExpressionR3C3 -> explicitMemberExpressionR3C4}
    explicitMemberExpressionR3C0 -> explicitMemberExpressionR4C0 [weight=100000000]
    rank = same {explicitMemberExpressionR4C0 -> explicitMemberExpressionR4C1}
    explicitMemberExpressionR3C3 -> explicitMemberExpressionR4C3 [weight=100000000]
    explicitMemberExpressionR3C5 -> explicitMemberExpressionR4C5 [weight=100000000]
    rank = same {explicitMemberExpressionR4C4 -> explicitMemberExpressionR4C5}
    explicitMemberExpressionR4C0 -> explicitMemberExpressionR5C0 [weight=100000000]
    explicitMemberExpressionR4C1 -> explicitMemberExpressionR5C1 [weight=100000000]
    rank = same {explicitMemberExpressionR5C0 -> explicitMemberExpressionR5C1}
    rank = same {explicitMemberExpressionR5C1 -> explicitMemberExpressionR5C2}
    explicitMemberExpressionR4C5 -> explicitMemberExpressionR5C5 [weight=100000000]
    rank = same {explicitMemberExpressionR5C4 -> explicitMemberExpressionR5C5}
    explicitMemberExpressionR5C0 -> explicitMemberExpressionR6C0 [weight=100000000]
    explicitMemberExpressionR5C1 -> explicitMemberExpressionR6C1 [weight=100000000]
    rank = same {explicitMemberExpressionR6C0 -> explicitMemberExpressionR6C1}
    explicitMemberExpressionR5C2 -> explicitMemberExpressionR6C2 [weight=100000000]
    rank = same {explicitMemberExpressionR6C1 -> explicitMemberExpressionR6C2}
    rank = same {explicitMemberExpressionR6C2 -> explicitMemberExpressionR6C3}
    explicitMemberExpressionR5C5 -> explicitMemberExpressionR6C5 [weight=100000000]
    rank = same {explicitMemberExpressionR6C4 -> explicitMemberExpressionR6C5}
    explicitMemberExpressionR6C0 -> explicitMemberExpressionR7C0 [weight=100000000]
    explicitMemberExpressionR6C1 -> explicitMemberExpressionR7C1 [weight=100000000]
    rank = same {explicitMemberExpressionR7C0 -> explicitMemberExpressionR7C1}
    explicitMemberExpressionR6C2 -> explicitMemberExpressionR7C2 [weight=100000000]
    rank = same {explicitMemberExpressionR7C1 -> explicitMemberExpressionR7C2}
    explicitMemberExpressionR6C3 -> explicitMemberExpressionR7C3 [weight=100000000]
    rank = same {explicitMemberExpressionR7C2 -> explicitMemberExpressionR7C3}
    rank = same {explicitMemberExpressionR7C3 -> explicitMemberExpressionR7C4}
    explicitMemberExpressionR6C5 -> explicitMemberExpressionR7C5 [weight=100000000]
    rank = same {explicitMemberExpressionR7C4 -> explicitMemberExpressionR7C5}
  }
  subgraph clusterrawValueStyleEnumMember {
    node [shape = box]
    label = <rawValueStyleEnumMember = declaration | rawValueStyleEnumCaseClause | compilerControlStatement .>
    labeljust = l
    rawValueStyleEnumMemberR0C0 [label = <CXU<br/>N rawValueStyleEnumMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    rawValueStyleEnumMemberR0C1 [label = <CXL<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    rawValueStyleEnumMemberR1C1 [label = <CXM<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    rawValueStyleEnumMemberR2C1 [label = <CXN<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumMemberR1C1 -> rawValueStyleEnumMemberR2C1 [weight=100000000]
    rawValueStyleEnumMemberR0C1 -> rawValueStyleEnumMemberR1C1 [weight=100000000]
    rawValueStyleEnumMemberR0C2 [label = <CXO<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    rawValueStyleEnumMemberR1C2 [label = <CXP<br/>N rawValueStyleEnumCaseClause<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    rawValueStyleEnumMemberR2C2 [label = <CXQ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumMemberR1C2 -> rawValueStyleEnumMemberR2C2 [weight=100000000]
    rawValueStyleEnumMemberR0C2 -> rawValueStyleEnumMemberR1C2 [weight=100000000]
    rawValueStyleEnumMemberR0C3 [label = <CXR<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumMemberR1C3 [label = <CXS<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumMemberR2C3 [label = <CXT<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumMemberR1C3 -> rawValueStyleEnumMemberR2C3 [weight=100000000]
    rawValueStyleEnumMemberR0C3 -> rawValueStyleEnumMemberR1C3 [weight=100000000]
    rank = same {rawValueStyleEnumMemberR0C2 -> rawValueStyleEnumMemberR0C3}
    rank = same {rawValueStyleEnumMemberR0C1 -> rawValueStyleEnumMemberR0C2}
    rank = same {rawValueStyleEnumMemberR0C0 -> rawValueStyleEnumMemberR0C1}
    node [style = invis]
    edge [style = invis]
    rawValueStyleEnumMemberR0C0 -> rawValueStyleEnumMemberR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumMemberR1C0 -> rawValueStyleEnumMemberR1C1}
    rawValueStyleEnumMemberR1C0 -> rawValueStyleEnumMemberR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumMemberR2C0 -> rawValueStyleEnumMemberR2C1}
  }
  subgraph clusterfunctionCallArgument {
    node [shape = box]
    label = <functionCallArgument = expression | identifier ":" expression | Operator | identifier ":" Operator .>
    labeljust = l
    functionCallArgumentR0C0 [label = <AQM<br/>N functionCallArgument<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", ",", "]"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    functionCallArgumentR0C1 [label = <AQE<br/>ALT <br/>fi ["", "try"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C1 [label = <AQF<br/>N expression<br/>fi ["", "try"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR2C1 [label = <AQG<br/>END <br/>fi [""]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C1 -> functionCallArgumentR2C1 [weight=100000000]
    functionCallArgumentR0C1 -> functionCallArgumentR1C1 [weight=100000000]
    functionCallArgumentR0C2 [label = <AQH<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C2 [label = <AQI<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    functionCallArgumentR2C2 [label = <AQJ<br/>T ":"<br/>fi [":"]<br/>fo [")", ",", "]", "try"]<br/>am []<br/>>]
    functionCallArgumentR3C2 [label = <AQK<br/>N expression<br/>fi ["", "try"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR4C2 [label = <AQL<br/>END <br/>fi [""]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR3C2 -> functionCallArgumentR4C2 [weight=100000000]
    functionCallArgumentR2C2 -> functionCallArgumentR3C2 [weight=100000000]
    functionCallArgumentR1C2 -> functionCallArgumentR2C2 [weight=100000000]
    functionCallArgumentR0C2 -> functionCallArgumentR1C2 [weight=100000000]
    functionCallArgumentR0C3 [label = <AQN<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C3 [label = <AQO<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR2C3 [label = <AQP<br/>END <br/>fi [""]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C3 -> functionCallArgumentR2C3 [weight=100000000]
    functionCallArgumentR0C3 -> functionCallArgumentR1C3 [weight=100000000]
    functionCallArgumentR0C4 [label = <AQQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR1C4 [label = <AQR<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    functionCallArgumentR2C4 [label = <AQS<br/>T ":"<br/>fi [":"]<br/>fo ["dotOperator", "plainOperator"]<br/>am []<br/>>]
    functionCallArgumentR3C4 [label = <AQT<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR4C4 [label = <AQU<br/>END <br/>fi [""]<br/>fo [")", ",", "]"]<br/>am []<br/>>]
    functionCallArgumentR3C4 -> functionCallArgumentR4C4 [weight=100000000]
    functionCallArgumentR2C4 -> functionCallArgumentR3C4 [weight=100000000]
    functionCallArgumentR1C4 -> functionCallArgumentR2C4 [weight=100000000]
    functionCallArgumentR0C4 -> functionCallArgumentR1C4 [weight=100000000]
    rank = same {functionCallArgumentR0C3 -> functionCallArgumentR0C4}
    rank = same {functionCallArgumentR0C2 -> functionCallArgumentR0C3}
    rank = same {functionCallArgumentR0C1 -> functionCallArgumentR0C2}
    rank = same {functionCallArgumentR0C0 -> functionCallArgumentR0C1}
    node [style = invis]
    edge [style = invis]
    functionCallArgumentR0C0 -> functionCallArgumentR1C0 [weight=100000000]
    rank = same {functionCallArgumentR1C0 -> functionCallArgumentR1C1}
    functionCallArgumentR1C0 -> functionCallArgumentR2C0 [weight=100000000]
    rank = same {functionCallArgumentR2C0 -> functionCallArgumentR2C1}
    functionCallArgumentR2C0 -> functionCallArgumentR3C0 [weight=100000000]
    functionCallArgumentR2C1 -> functionCallArgumentR3C1 [weight=100000000]
    rank = same {functionCallArgumentR3C0 -> functionCallArgumentR3C1}
    rank = same {functionCallArgumentR3C1 -> functionCallArgumentR3C2}
    functionCallArgumentR2C3 -> functionCallArgumentR3C3 [weight=100000000]
    rank = same {functionCallArgumentR3C2 -> functionCallArgumentR3C3}
    rank = same {functionCallArgumentR3C3 -> functionCallArgumentR3C4}
    functionCallArgumentR3C0 -> functionCallArgumentR4C0 [weight=100000000]
    functionCallArgumentR3C1 -> functionCallArgumentR4C1 [weight=100000000]
    rank = same {functionCallArgumentR4C0 -> functionCallArgumentR4C1}
    rank = same {functionCallArgumentR4C1 -> functionCallArgumentR4C2}
    functionCallArgumentR3C3 -> functionCallArgumentR4C3 [weight=100000000]
    rank = same {functionCallArgumentR4C2 -> functionCallArgumentR4C3}
    rank = same {functionCallArgumentR4C3 -> functionCallArgumentR4C4}
  }
  subgraph clustersubscriptHead {
    node [shape = box]
    label = <subscriptHead = [ attributes ] [ declarationModifiers ] "subscript" [ genericParameterClause ] parameterClause .>
    labeljust = l
    subscriptHeadR0C0 [label = <DTQ<br/>N subscriptHead<br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptHeadR0C1 [label = <DTA<br/>ALT <br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptHeadR1C1 [label = <DTE<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "weak"]<br/>am []<br/>>]
    subscriptHeadR2C1 [label = <DTI<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["subscript"]<br/>am []<br/>>]
    subscriptHeadR3C1 [label = <DTJ<br/>T "subscript"<br/>fi ["subscript"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    subscriptHeadR4C1 [label = <DTN<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    subscriptHeadR5C1 [label = <DTO<br/>N parameterClause<br/>fi ["("]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptHeadR6C1 [label = <DTP<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptHeadR5C1 -> subscriptHeadR6C1 [weight=100000000]
    subscriptHeadR4C1 -> subscriptHeadR5C1 [weight=100000000]
    subscriptHeadR4C2 [label = <DTL<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    subscriptHeadR5C2 [label = <DTK<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    subscriptHeadR6C2 [label = <DTM<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    subscriptHeadR5C2 -> subscriptHeadR6C2 [weight=100000000]
    subscriptHeadR4C2 -> subscriptHeadR5C2 [weight=100000000]
    rank = same {subscriptHeadR4C1 -> subscriptHeadR4C2}
    subscriptHeadR3C1 -> subscriptHeadR4C1 [weight=100000000]
    subscriptHeadR2C1 -> subscriptHeadR3C1 [weight=100000000]
    subscriptHeadR2C3 [label = <DTG<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["subscript"]<br/>am []<br/>>]
    subscriptHeadR3C3 [label = <DTF<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["subscript"]<br/>am []<br/>>]
    subscriptHeadR4C3 [label = <DTH<br/>END <br/>fi [""]<br/>fo ["subscript"]<br/>am []<br/>>]
    subscriptHeadR3C3 -> subscriptHeadR4C3 [weight=100000000]
    subscriptHeadR2C3 -> subscriptHeadR3C3 [weight=100000000]
    rank = same {subscriptHeadR2C1 -> subscriptHeadR2C3}
    subscriptHeadR1C1 -> subscriptHeadR2C1 [weight=100000000]
    subscriptHeadR1C4 [label = <DTC<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "weak"]<br/>am []<br/>>]
    subscriptHeadR2C4 [label = <DTB<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "weak"]<br/>am []<br/>>]
    subscriptHeadR3C4 [label = <DTD<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "weak"]<br/>am []<br/>>]
    subscriptHeadR2C4 -> subscriptHeadR3C4 [weight=100000000]
    subscriptHeadR1C4 -> subscriptHeadR2C4 [weight=100000000]
    rank = same {subscriptHeadR1C1 -> subscriptHeadR1C4}
    subscriptHeadR0C1 -> subscriptHeadR1C1 [weight=100000000]
    rank = same {subscriptHeadR0C0 -> subscriptHeadR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {subscriptHeadR0C1 -> subscriptHeadR0C2}
    rank = same {subscriptHeadR0C2 -> subscriptHeadR0C3}
    rank = same {subscriptHeadR0C3 -> subscriptHeadR0C4}
    subscriptHeadR0C0 -> subscriptHeadR1C0 [weight=100000000]
    rank = same {subscriptHeadR1C0 -> subscriptHeadR1C1}
    subscriptHeadR0C4 -> subscriptHeadR1C4 [weight=100000000]
    subscriptHeadR1C0 -> subscriptHeadR2C0 [weight=100000000]
    rank = same {subscriptHeadR2C0 -> subscriptHeadR2C1}
    subscriptHeadR2C0 -> subscriptHeadR3C0 [weight=100000000]
    rank = same {subscriptHeadR3C0 -> subscriptHeadR3C1}
    rank = same {subscriptHeadR3C1 -> subscriptHeadR3C2}
    rank = same {subscriptHeadR3C2 -> subscriptHeadR3C3}
    subscriptHeadR3C0 -> subscriptHeadR4C0 [weight=100000000]
    rank = same {subscriptHeadR4C0 -> subscriptHeadR4C1}
    subscriptHeadR3C2 -> subscriptHeadR4C2 [weight=100000000]
    subscriptHeadR3C4 -> subscriptHeadR4C4 [weight=100000000]
    rank = same {subscriptHeadR4C3 -> subscriptHeadR4C4}
    subscriptHeadR4C0 -> subscriptHeadR5C0 [weight=100000000]
    rank = same {subscriptHeadR5C0 -> subscriptHeadR5C1}
    subscriptHeadR4C3 -> subscriptHeadR5C3 [weight=100000000]
    rank = same {subscriptHeadR5C2 -> subscriptHeadR5C3}
    subscriptHeadR4C4 -> subscriptHeadR5C4 [weight=100000000]
    rank = same {subscriptHeadR5C3 -> subscriptHeadR5C4}
    subscriptHeadR5C0 -> subscriptHeadR6C0 [weight=100000000]
    rank = same {subscriptHeadR6C0 -> subscriptHeadR6C1}
    subscriptHeadR5C3 -> subscriptHeadR6C3 [weight=100000000]
    rank = same {subscriptHeadR6C2 -> subscriptHeadR6C3}
    subscriptHeadR5C4 -> subscriptHeadR6C4 [weight=100000000]
    rank = same {subscriptHeadR6C3 -> subscriptHeadR6C4}
  }
  subgraph clustertypeName {
    node [shape = box]
    label = <typeName = identifier .>
    labeljust = l
    typeNameR0C0 [label = <GV<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeNameR0C1 [label = <GS<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeNameR1C1 [label = <GT<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeNameR2C1 [label = <GU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeNameR1C1 -> typeNameR2C1 [weight=100000000]
    typeNameR0C1 -> typeNameR1C1 [weight=100000000]
    rank = same {typeNameR0C0 -> typeNameR0C1}
    node [style = invis]
    edge [style = invis]
    typeNameR0C0 -> typeNameR1C0 [weight=100000000]
    rank = same {typeNameR1C0 -> typeNameR1C1}
    typeNameR1C0 -> typeNameR2C0 [weight=100000000]
    rank = same {typeNameR2C0 -> typeNameR2C1}
  }
  subgraph clusterfunctionResult {
    node [shape = box]
    label = <functionResult = "&gt;" [ attributes ] type .>
    labeljust = l
    functionResultR0C0 [label = <COY<br/>N functionResult<br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR0C1 [label = <COQ<br/>ALT <br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR1C1 [label = <COR<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR2C1 [label = <COV<br/>OPT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    functionResultR3C1 [label = <COW<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    functionResultR4C1 [label = <COX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR3C1 -> functionResultR4C1 [weight=100000000]
    functionResultR2C1 -> functionResultR3C1 [weight=100000000]
    functionResultR2C2 [label = <COT<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR3C2 [label = <COS<br/>N attributes<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR4C2 [label = <COU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionResultR3C2 -> functionResultR4C2 [weight=100000000]
    functionResultR2C2 -> functionResultR3C2 [weight=100000000]
    rank = same {functionResultR2C1 -> functionResultR2C2}
    functionResultR1C1 -> functionResultR2C1 [weight=100000000]
    functionResultR0C1 -> functionResultR1C1 [weight=100000000]
    rank = same {functionResultR0C0 -> functionResultR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionResultR0C1 -> functionResultR0C2}
    functionResultR0C0 -> functionResultR1C0 [weight=100000000]
    rank = same {functionResultR1C0 -> functionResultR1C1}
    functionResultR0C2 -> functionResultR1C2 [weight=100000000]
    rank = same {functionResultR1C1 -> functionResultR1C2}
    functionResultR1C0 -> functionResultR2C0 [weight=100000000]
    rank = same {functionResultR2C0 -> functionResultR2C1}
    functionResultR1C2 -> functionResultR2C2 [weight=100000000]
    functionResultR2C0 -> functionResultR3C0 [weight=100000000]
    rank = same {functionResultR3C0 -> functionResultR3C1}
    functionResultR3C0 -> functionResultR4C0 [weight=100000000]
    rank = same {functionResultR4C0 -> functionResultR4C1}
  }
  subgraph clustergetterSetterKeywordBlock {
    node [shape = box]
    label = <getterSetterKeywordBlock = "{" getterKeywordClause [ setterKeywordClause ] "}" | "{" setterKeywordClause getterKeywordClause "}" .>
    labeljust = l
    getterSetterKeywordBlockR0C0 [label = <CIE<br/>N getterSetterKeywordBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["{"]<br/>>]
    getterSetterKeywordBlockR0C1 [label = <CHV<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR1C1 [label = <CHW<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR2C1 [label = <CHX<br/>N getterKeywordClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterSetterKeywordBlockR3C1 [label = <CIB<br/>OPT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C1 [label = <CIC<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR5C1 [label = <CID<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C1 -> getterSetterKeywordBlockR5C1 [weight=100000000]
    getterSetterKeywordBlockR3C1 -> getterSetterKeywordBlockR4C1 [weight=100000000]
    getterSetterKeywordBlockR3C2 [label = <CHZ<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C2 [label = <CHY<br/>N setterKeywordClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR5C2 [label = <CIA<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C2 -> getterSetterKeywordBlockR5C2 [weight=100000000]
    getterSetterKeywordBlockR3C2 -> getterSetterKeywordBlockR4C2 [weight=100000000]
    rank = same {getterSetterKeywordBlockR3C1 -> getterSetterKeywordBlockR3C2}
    getterSetterKeywordBlockR2C1 -> getterSetterKeywordBlockR3C1 [weight=100000000]
    getterSetterKeywordBlockR1C1 -> getterSetterKeywordBlockR2C1 [weight=100000000]
    getterSetterKeywordBlockR0C1 -> getterSetterKeywordBlockR1C1 [weight=100000000]
    getterSetterKeywordBlockR0C3 [label = <CIF<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR1C3 [label = <CIG<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR2C3 [label = <CIH<br/>N setterKeywordClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterSetterKeywordBlockR3C3 [label = <CII<br/>N getterKeywordClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C3 [label = <CIJ<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR5C3 [label = <CIK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterKeywordBlockR4C3 -> getterSetterKeywordBlockR5C3 [weight=100000000]
    getterSetterKeywordBlockR3C3 -> getterSetterKeywordBlockR4C3 [weight=100000000]
    getterSetterKeywordBlockR2C3 -> getterSetterKeywordBlockR3C3 [weight=100000000]
    getterSetterKeywordBlockR1C3 -> getterSetterKeywordBlockR2C3 [weight=100000000]
    getterSetterKeywordBlockR0C3 -> getterSetterKeywordBlockR1C3 [weight=100000000]
    rank = same {getterSetterKeywordBlockR0C1 -> getterSetterKeywordBlockR0C3}
    rank = same {getterSetterKeywordBlockR0C0 -> getterSetterKeywordBlockR0C1}
    node [style = invis]
    edge [style = invis]
    getterSetterKeywordBlockR0C0 -> getterSetterKeywordBlockR1C0 [weight=100000000]
    rank = same {getterSetterKeywordBlockR1C0 -> getterSetterKeywordBlockR1C1}
    rank = same {getterSetterKeywordBlockR1C1 -> getterSetterKeywordBlockR1C2}
    rank = same {getterSetterKeywordBlockR1C2 -> getterSetterKeywordBlockR1C3}
    getterSetterKeywordBlockR1C0 -> getterSetterKeywordBlockR2C0 [weight=100000000]
    rank = same {getterSetterKeywordBlockR2C0 -> getterSetterKeywordBlockR2C1}
    getterSetterKeywordBlockR1C2 -> getterSetterKeywordBlockR2C2 [weight=100000000]
    rank = same {getterSetterKeywordBlockR2C1 -> getterSetterKeywordBlockR2C2}
    rank = same {getterSetterKeywordBlockR2C2 -> getterSetterKeywordBlockR2C3}
    getterSetterKeywordBlockR2C0 -> getterSetterKeywordBlockR3C0 [weight=100000000]
    rank = same {getterSetterKeywordBlockR3C0 -> getterSetterKeywordBlockR3C1}
    getterSetterKeywordBlockR2C2 -> getterSetterKeywordBlockR3C2 [weight=100000000]
    getterSetterKeywordBlockR3C0 -> getterSetterKeywordBlockR4C0 [weight=100000000]
    rank = same {getterSetterKeywordBlockR4C0 -> getterSetterKeywordBlockR4C1}
    getterSetterKeywordBlockR4C0 -> getterSetterKeywordBlockR5C0 [weight=100000000]
    rank = same {getterSetterKeywordBlockR5C0 -> getterSetterKeywordBlockR5C1}
  }
  subgraph clusterenumCaseName {
    node [shape = box]
    label = <enumCaseName = identifier .>
    labeljust = l
    enumCaseNameR0C0 [label = <CWL<br/>N enumCaseName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCaseNameR0C1 [label = <CWI<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCaseNameR1C1 [label = <CWJ<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCaseNameR2C1 [label = <CWK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCaseNameR1C1 -> enumCaseNameR2C1 [weight=100000000]
    enumCaseNameR0C1 -> enumCaseNameR1C1 [weight=100000000]
    rank = same {enumCaseNameR0C0 -> enumCaseNameR0C1}
    node [style = invis]
    edge [style = invis]
    enumCaseNameR0C0 -> enumCaseNameR1C0 [weight=100000000]
    rank = same {enumCaseNameR1C0 -> enumCaseNameR1C1}
    enumCaseNameR1C0 -> enumCaseNameR2C0 [weight=100000000]
    rank = same {enumCaseNameR2C0 -> enumCaseNameR2C1}
  }
  subgraph clustertuplePattern {
    node [shape = box]
    label = <tuplePattern = "(" [ tuplePatternElementList ] ")" .>
    labeljust = l
    tuplePatternR0C0 [label = <ELF<br/>N tuplePattern<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tuplePatternR0C1 [label = <EKX<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tuplePatternR1C1 [label = <EKY<br/>T "("<br/>fi ["("]<br/>fo ["(", ")", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    tuplePatternR2C1 [label = <ELC<br/>OPT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternR3C1 [label = <ELD<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tuplePatternR4C1 [label = <ELE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tuplePatternR3C1 -> tuplePatternR4C1 [weight=100000000]
    tuplePatternR2C1 -> tuplePatternR3C1 [weight=100000000]
    tuplePatternR2C2 [label = <ELA<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternR3C2 [label = <EKZ<br/>N tuplePatternElementList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternR4C2 [label = <ELB<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternR3C2 -> tuplePatternR4C2 [weight=100000000]
    tuplePatternR2C2 -> tuplePatternR3C2 [weight=100000000]
    rank = same {tuplePatternR2C1 -> tuplePatternR2C2}
    tuplePatternR1C1 -> tuplePatternR2C1 [weight=100000000]
    tuplePatternR0C1 -> tuplePatternR1C1 [weight=100000000]
    rank = same {tuplePatternR0C0 -> tuplePatternR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {tuplePatternR0C1 -> tuplePatternR0C2}
    tuplePatternR0C0 -> tuplePatternR1C0 [weight=100000000]
    rank = same {tuplePatternR1C0 -> tuplePatternR1C1}
    tuplePatternR0C2 -> tuplePatternR1C2 [weight=100000000]
    rank = same {tuplePatternR1C1 -> tuplePatternR1C2}
    tuplePatternR1C0 -> tuplePatternR2C0 [weight=100000000]
    rank = same {tuplePatternR2C0 -> tuplePatternR2C1}
    tuplePatternR1C2 -> tuplePatternR2C2 [weight=100000000]
    tuplePatternR2C0 -> tuplePatternR3C0 [weight=100000000]
    rank = same {tuplePatternR3C0 -> tuplePatternR3C1}
    tuplePatternR3C0 -> tuplePatternR4C0 [weight=100000000]
    rank = same {tuplePatternR4C0 -> tuplePatternR4C1}
  }
  subgraph clustertuplePatternElement {
    node [shape = box]
    label = <tuplePatternElement = pattern | identifier ":" pattern .>
    labeljust = l
    tuplePatternElementR0C0 [label = <ELX<br/>N tuplePatternElement<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")", ","]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    tuplePatternElementR0C1 [label = <ELP<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR1C1 [label = <ELQ<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR2C1 [label = <ELR<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR1C1 -> tuplePatternElementR2C1 [weight=100000000]
    tuplePatternElementR0C1 -> tuplePatternElementR1C1 [weight=100000000]
    tuplePatternElementR0C2 [label = <ELS<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR1C2 [label = <ELT<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    tuplePatternElementR2C2 [label = <ELU<br/>T ":"<br/>fi [":"]<br/>fo ["(", ")", ",", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    tuplePatternElementR3C2 [label = <ELV<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR4C2 [label = <ELW<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tuplePatternElementR3C2 -> tuplePatternElementR4C2 [weight=100000000]
    tuplePatternElementR2C2 -> tuplePatternElementR3C2 [weight=100000000]
    tuplePatternElementR1C2 -> tuplePatternElementR2C2 [weight=100000000]
    tuplePatternElementR0C2 -> tuplePatternElementR1C2 [weight=100000000]
    rank = same {tuplePatternElementR0C1 -> tuplePatternElementR0C2}
    rank = same {tuplePatternElementR0C0 -> tuplePatternElementR0C1}
    node [style = invis]
    edge [style = invis]
    tuplePatternElementR0C0 -> tuplePatternElementR1C0 [weight=100000000]
    rank = same {tuplePatternElementR1C0 -> tuplePatternElementR1C1}
    tuplePatternElementR1C0 -> tuplePatternElementR2C0 [weight=100000000]
    rank = same {tuplePatternElementR2C0 -> tuplePatternElementR2C1}
    tuplePatternElementR2C0 -> tuplePatternElementR3C0 [weight=100000000]
    tuplePatternElementR2C1 -> tuplePatternElementR3C1 [weight=100000000]
    rank = same {tuplePatternElementR3C0 -> tuplePatternElementR3C1}
    rank = same {tuplePatternElementR3C1 -> tuplePatternElementR3C2}
    tuplePatternElementR3C0 -> tuplePatternElementR4C0 [weight=100000000]
    tuplePatternElementR3C1 -> tuplePatternElementR4C1 [weight=100000000]
    rank = same {tuplePatternElementR4C0 -> tuplePatternElementR4C1}
    rank = same {tuplePatternElementR4C1 -> tuplePatternElementR4C2}
  }
  subgraph clusterloopStatement {
    node [shape = box]
    label = <loopStatement = forInStatement | whileStatement | repeatWhileStatement .>
    labeljust = l
    loopStatementR0C0 [label = <AXJ<br/>N loopStatement<br/>fi ["for", "repeat", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR0C1 [label = <AXG<br/>ALT <br/>fi ["for"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C1 [label = <AXH<br/>N forInStatement<br/>fi ["for"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR2C1 [label = <AXI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C1 -> loopStatementR2C1 [weight=100000000]
    loopStatementR0C1 -> loopStatementR1C1 [weight=100000000]
    loopStatementR0C2 [label = <AXK<br/>ALT <br/>fi ["while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C2 [label = <AXL<br/>N whileStatement<br/>fi ["while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR2C2 [label = <AXM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C2 -> loopStatementR2C2 [weight=100000000]
    loopStatementR0C2 -> loopStatementR1C2 [weight=100000000]
    loopStatementR0C3 [label = <AXN<br/>ALT <br/>fi ["repeat"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C3 [label = <AXO<br/>N repeatWhileStatement<br/>fi ["repeat"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR2C3 [label = <AXP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    loopStatementR1C3 -> loopStatementR2C3 [weight=100000000]
    loopStatementR0C3 -> loopStatementR1C3 [weight=100000000]
    rank = same {loopStatementR0C2 -> loopStatementR0C3}
    rank = same {loopStatementR0C1 -> loopStatementR0C2}
    rank = same {loopStatementR0C0 -> loopStatementR0C1}
    node [style = invis]
    edge [style = invis]
    loopStatementR0C0 -> loopStatementR1C0 [weight=100000000]
    rank = same {loopStatementR1C0 -> loopStatementR1C1}
    loopStatementR1C0 -> loopStatementR2C0 [weight=100000000]
    rank = same {loopStatementR2C0 -> loopStatementR2C1}
  }
  subgraph clusterswitchElseDirectiveClause {
    node [shape = box]
    label = <switchElseDirectiveClause = elseDirective [ switchCases ] .>
    labeljust = l
    switchElseDirectiveClauseR0C0 [label = <BGO<br/>N switchElseDirectiveClause<br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR0C1 [label = <BGH<br/>ALT <br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR1C1 [label = <BGI<br/>N elseDirective<br/>fi ["#else"]<br/>fo ["#endif", "#if", "@"]<br/>am []<br/>>]
    switchElseDirectiveClauseR2C1 [label = <BGM<br/>OPT <br/>fi ["", "#if", "@"]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR3C1 [label = <BGN<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR2C1 -> switchElseDirectiveClauseR3C1 [weight=100000000]
    switchElseDirectiveClauseR2C2 [label = <BGK<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR3C2 [label = <BGJ<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR4C2 [label = <BGL<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    switchElseDirectiveClauseR3C2 -> switchElseDirectiveClauseR4C2 [weight=100000000]
    switchElseDirectiveClauseR2C2 -> switchElseDirectiveClauseR3C2 [weight=100000000]
    rank = same {switchElseDirectiveClauseR2C1 -> switchElseDirectiveClauseR2C2}
    switchElseDirectiveClauseR1C1 -> switchElseDirectiveClauseR2C1 [weight=100000000]
    switchElseDirectiveClauseR0C1 -> switchElseDirectiveClauseR1C1 [weight=100000000]
    rank = same {switchElseDirectiveClauseR0C0 -> switchElseDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchElseDirectiveClauseR0C1 -> switchElseDirectiveClauseR0C2}
    switchElseDirectiveClauseR0C0 -> switchElseDirectiveClauseR1C0 [weight=100000000]
    rank = same {switchElseDirectiveClauseR1C0 -> switchElseDirectiveClauseR1C1}
    switchElseDirectiveClauseR0C2 -> switchElseDirectiveClauseR1C2 [weight=100000000]
    rank = same {switchElseDirectiveClauseR1C1 -> switchElseDirectiveClauseR1C2}
    switchElseDirectiveClauseR1C0 -> switchElseDirectiveClauseR2C0 [weight=100000000]
    rank = same {switchElseDirectiveClauseR2C0 -> switchElseDirectiveClauseR2C1}
    switchElseDirectiveClauseR1C2 -> switchElseDirectiveClauseR2C2 [weight=100000000]
    switchElseDirectiveClauseR2C0 -> switchElseDirectiveClauseR3C0 [weight=100000000]
    rank = same {switchElseDirectiveClauseR3C0 -> switchElseDirectiveClauseR3C1}
    switchElseDirectiveClauseR3C0 -> switchElseDirectiveClauseR4C0 [weight=100000000]
    switchElseDirectiveClauseR3C1 -> switchElseDirectiveClauseR4C1 [weight=100000000]
    rank = same {switchElseDirectiveClauseR4C0 -> switchElseDirectiveClauseR4C1}
    rank = same {switchElseDirectiveClauseR4C1 -> switchElseDirectiveClauseR4C2}
  }
  subgraph clustermacroDeclaration {
    node [shape = box]
    label = <macroDeclaration = macroHead identifier [ genericParameterClause ] macroSignature [ macroDefinition ] genericWhereClause .>
    labeljust = l
    macroDeclarationR0C0 [label = <DUO<br/>N macroDeclaration<br/>fi ["", "@"]<br/>fo []<br/>am []<br/>>]
    macroDeclarationR0C1 [label = <DUA<br/>ALT <br/>fi ["", "@"]<br/>fo []<br/>am []<br/>>]
    macroDeclarationR1C1 [label = <DUB<br/>N macroHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroDeclarationR2C1 [label = <DUC<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    macroDeclarationR3C1 [label = <DUG<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    macroDeclarationR4C1 [label = <DUH<br/>N macroSignature<br/>fi ["("]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroDeclarationR5C1 [label = <DUL<br/>OPT <br/>fi ["", "="]<br/>fo ["where"]<br/>am []<br/>>]
    macroDeclarationR6C1 [label = <DUM<br/>N genericWhereClause<br/>fi ["where"]<br/>fo []<br/>am []<br/>>]
    macroDeclarationR7C1 [label = <DUN<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    macroDeclarationR6C1 -> macroDeclarationR7C1 [weight=100000000]
    macroDeclarationR5C1 -> macroDeclarationR6C1 [weight=100000000]
    macroDeclarationR5C2 [label = <DUJ<br/>ALT <br/>fi ["="]<br/>fo ["where"]<br/>am []<br/>>]
    macroDeclarationR6C2 [label = <DUI<br/>N macroDefinition<br/>fi ["="]<br/>fo ["where"]<br/>am []<br/>>]
    macroDeclarationR7C2 [label = <DUK<br/>END <br/>fi [""]<br/>fo ["where"]<br/>am []<br/>>]
    macroDeclarationR6C2 -> macroDeclarationR7C2 [weight=100000000]
    macroDeclarationR5C2 -> macroDeclarationR6C2 [weight=100000000]
    rank = same {macroDeclarationR5C1 -> macroDeclarationR5C2}
    macroDeclarationR4C1 -> macroDeclarationR5C1 [weight=100000000]
    macroDeclarationR3C1 -> macroDeclarationR4C1 [weight=100000000]
    macroDeclarationR3C3 [label = <DUE<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    macroDeclarationR4C3 [label = <DUD<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    macroDeclarationR5C3 [label = <DUF<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    macroDeclarationR4C3 -> macroDeclarationR5C3 [weight=100000000]
    macroDeclarationR3C3 -> macroDeclarationR4C3 [weight=100000000]
    rank = same {macroDeclarationR3C1 -> macroDeclarationR3C3}
    macroDeclarationR2C1 -> macroDeclarationR3C1 [weight=100000000]
    macroDeclarationR1C1 -> macroDeclarationR2C1 [weight=100000000]
    macroDeclarationR0C1 -> macroDeclarationR1C1 [weight=100000000]
    rank = same {macroDeclarationR0C0 -> macroDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {macroDeclarationR0C1 -> macroDeclarationR0C2}
    rank = same {macroDeclarationR0C2 -> macroDeclarationR0C3}
    macroDeclarationR0C0 -> macroDeclarationR1C0 [weight=100000000]
    rank = same {macroDeclarationR1C0 -> macroDeclarationR1C1}
    macroDeclarationR0C2 -> macroDeclarationR1C2 [weight=100000000]
    rank = same {macroDeclarationR1C1 -> macroDeclarationR1C2}
    macroDeclarationR0C3 -> macroDeclarationR1C3 [weight=100000000]
    rank = same {macroDeclarationR1C2 -> macroDeclarationR1C3}
    macroDeclarationR1C0 -> macroDeclarationR2C0 [weight=100000000]
    rank = same {macroDeclarationR2C0 -> macroDeclarationR2C1}
    macroDeclarationR1C2 -> macroDeclarationR2C2 [weight=100000000]
    rank = same {macroDeclarationR2C1 -> macroDeclarationR2C2}
    macroDeclarationR1C3 -> macroDeclarationR2C3 [weight=100000000]
    rank = same {macroDeclarationR2C2 -> macroDeclarationR2C3}
    macroDeclarationR2C0 -> macroDeclarationR3C0 [weight=100000000]
    rank = same {macroDeclarationR3C0 -> macroDeclarationR3C1}
    macroDeclarationR2C3 -> macroDeclarationR3C3 [weight=100000000]
    macroDeclarationR3C0 -> macroDeclarationR4C0 [weight=100000000]
    rank = same {macroDeclarationR4C0 -> macroDeclarationR4C1}
    rank = same {macroDeclarationR4C1 -> macroDeclarationR4C2}
    rank = same {macroDeclarationR4C2 -> macroDeclarationR4C3}
    macroDeclarationR4C0 -> macroDeclarationR5C0 [weight=100000000]
    rank = same {macroDeclarationR5C0 -> macroDeclarationR5C1}
    macroDeclarationR4C2 -> macroDeclarationR5C2 [weight=100000000]
    macroDeclarationR5C0 -> macroDeclarationR6C0 [weight=100000000]
    rank = same {macroDeclarationR6C0 -> macroDeclarationR6C1}
    macroDeclarationR5C3 -> macroDeclarationR6C3 [weight=100000000]
    rank = same {macroDeclarationR6C2 -> macroDeclarationR6C3}
    macroDeclarationR6C0 -> macroDeclarationR7C0 [weight=100000000]
    rank = same {macroDeclarationR7C0 -> macroDeclarationR7C1}
    macroDeclarationR6C3 -> macroDeclarationR7C3 [weight=100000000]
    rank = same {macroDeclarationR7C2 -> macroDeclarationR7C3}
  }
  subgraph clusterfunctionHead {
    node [shape = box]
    label = <functionHead = [ attributes ] [ declarationModifiers ] "func" .>
    labeljust = l
    functionHeadR0C0 [label = <CNG<br/>N functionHead<br/>fi ["", "@"]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionHeadR0C1 [label = <CMV<br/>ALT <br/>fi ["", "@"]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionHeadR1C1 [label = <CMZ<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    functionHeadR2C1 [label = <CND<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func"]<br/>am []<br/>>]
    functionHeadR3C1 [label = <CNE<br/>T "func"<br/>fi ["func"]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionHeadR4C1 [label = <CNF<br/>END <br/>fi [""]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionHeadR3C1 -> functionHeadR4C1 [weight=100000000]
    functionHeadR2C1 -> functionHeadR3C1 [weight=100000000]
    functionHeadR2C2 [label = <CNB<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func"]<br/>am []<br/>>]
    functionHeadR3C2 [label = <CNA<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["func"]<br/>am []<br/>>]
    functionHeadR4C2 [label = <CNC<br/>END <br/>fi [""]<br/>fo ["func"]<br/>am []<br/>>]
    functionHeadR3C2 -> functionHeadR4C2 [weight=100000000]
    functionHeadR2C2 -> functionHeadR3C2 [weight=100000000]
    rank = same {functionHeadR2C1 -> functionHeadR2C2}
    functionHeadR1C1 -> functionHeadR2C1 [weight=100000000]
    functionHeadR1C3 [label = <CMX<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    functionHeadR2C3 [label = <CMW<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    functionHeadR3C3 [label = <CMY<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    functionHeadR2C3 -> functionHeadR3C3 [weight=100000000]
    functionHeadR1C3 -> functionHeadR2C3 [weight=100000000]
    rank = same {functionHeadR1C1 -> functionHeadR1C3}
    functionHeadR0C1 -> functionHeadR1C1 [weight=100000000]
    rank = same {functionHeadR0C0 -> functionHeadR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionHeadR0C1 -> functionHeadR0C2}
    rank = same {functionHeadR0C2 -> functionHeadR0C3}
    functionHeadR0C0 -> functionHeadR1C0 [weight=100000000]
    rank = same {functionHeadR1C0 -> functionHeadR1C1}
    functionHeadR0C3 -> functionHeadR1C3 [weight=100000000]
    functionHeadR1C0 -> functionHeadR2C0 [weight=100000000]
    rank = same {functionHeadR2C0 -> functionHeadR2C1}
    functionHeadR2C0 -> functionHeadR3C0 [weight=100000000]
    rank = same {functionHeadR3C0 -> functionHeadR3C1}
    functionHeadR3C0 -> functionHeadR4C0 [weight=100000000]
    rank = same {functionHeadR4C0 -> functionHeadR4C1}
    functionHeadR3C3 -> functionHeadR4C3 [weight=100000000]
    rank = same {functionHeadR4C2 -> functionHeadR4C3}
  }
  subgraph clustercaptureSpecifier {
    node [shape = box]
    label = <captureSpecifier = "weak" | "unowned" | "unowned(safe)" | "unowned(unsafe)" .>
    labeljust = l
    captureSpecifierR0C0 [label = <AIB<br/>N captureSpecifier<br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR0C1 [label = <AHP<br/>ALT <br/>fi ["weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C1 [label = <AHQ<br/>T "weak"<br/>fi ["weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR2C1 [label = <AHR<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C1 -> captureSpecifierR2C1 [weight=100000000]
    captureSpecifierR0C1 -> captureSpecifierR1C1 [weight=100000000]
    captureSpecifierR0C2 [label = <AHS<br/>ALT <br/>fi ["unowned"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C2 [label = <AHT<br/>T "unowned"<br/>fi ["unowned"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR2C2 [label = <AHU<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C2 -> captureSpecifierR2C2 [weight=100000000]
    captureSpecifierR0C2 -> captureSpecifierR1C2 [weight=100000000]
    captureSpecifierR0C3 [label = <AHV<br/>ALT <br/>fi ["unowned(safe)"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C3 [label = <AHW<br/>T "unowned(safe)"<br/>fi ["unowned(safe)"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR2C3 [label = <AHX<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C3 -> captureSpecifierR2C3 [weight=100000000]
    captureSpecifierR0C3 -> captureSpecifierR1C3 [weight=100000000]
    captureSpecifierR0C4 [label = <AHY<br/>ALT <br/>fi ["unowned(unsafe)"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C4 [label = <AHZ<br/>T "unowned(unsafe)"<br/>fi ["unowned(unsafe)"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR2C4 [label = <AIA<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    captureSpecifierR1C4 -> captureSpecifierR2C4 [weight=100000000]
    captureSpecifierR0C4 -> captureSpecifierR1C4 [weight=100000000]
    rank = same {captureSpecifierR0C3 -> captureSpecifierR0C4}
    rank = same {captureSpecifierR0C2 -> captureSpecifierR0C3}
    rank = same {captureSpecifierR0C1 -> captureSpecifierR0C2}
    rank = same {captureSpecifierR0C0 -> captureSpecifierR0C1}
    node [style = invis]
    edge [style = invis]
    captureSpecifierR0C0 -> captureSpecifierR1C0 [weight=100000000]
    rank = same {captureSpecifierR1C0 -> captureSpecifierR1C1}
    captureSpecifierR1C0 -> captureSpecifierR2C0 [weight=100000000]
    rank = same {captureSpecifierR2C0 -> captureSpecifierR2C1}
  }
  subgraph clusterconditionalExpression {
    node [shape = box]
    label = <conditionalExpression = ifExpression | switchExpression .>
    labeljust = l
    conditionalExpressionR0C0 [label = <ABF<br/>N conditionalExpression<br/>fi ["if", "switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR0C1 [label = <AAZ<br/>ALT <br/>fi ["if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR1C1 [label = <ABA<br/>N ifExpression<br/>fi ["if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR2C1 [label = <ABB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR1C1 -> conditionalExpressionR2C1 [weight=100000000]
    conditionalExpressionR0C1 -> conditionalExpressionR1C1 [weight=100000000]
    conditionalExpressionR0C2 [label = <ABC<br/>ALT <br/>fi ["switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR1C2 [label = <ABD<br/>N switchExpression<br/>fi ["switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR2C2 [label = <ABE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalExpressionR1C2 -> conditionalExpressionR2C2 [weight=100000000]
    conditionalExpressionR0C2 -> conditionalExpressionR1C2 [weight=100000000]
    rank = same {conditionalExpressionR0C1 -> conditionalExpressionR0C2}
    rank = same {conditionalExpressionR0C0 -> conditionalExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    conditionalExpressionR0C0 -> conditionalExpressionR1C0 [weight=100000000]
    rank = same {conditionalExpressionR1C0 -> conditionalExpressionR1C1}
    conditionalExpressionR1C0 -> conditionalExpressionR2C0 [weight=100000000]
    rank = same {conditionalExpressionR2C0 -> conditionalExpressionR2C1}
  }
  subgraph clusterifStatement {
    node [shape = box]
    label = <ifStatement = "if" conditionList codeBlock [ elseClause ] .>
    labeljust = l
    ifStatementR0C0 [label = <BBF<br/>N ifStatement<br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR0C1 [label = <BAW<br/>ALT <br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR1C1 [label = <BAX<br/>T "if"<br/>fi ["if"]<br/>fo ["#available", "#unavailable", "case", "let", "try", "var", "{"]<br/>am []<br/>>]
    ifStatementR2C1 [label = <BAY<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    ifStatementR3C1 [label = <BAZ<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR4C1 [label = <BBD<br/>OPT <br/>fi ["", "else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR5C1 [label = <BBE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR4C1 -> ifStatementR5C1 [weight=100000000]
    ifStatementR4C2 [label = <BBB<br/>ALT <br/>fi ["else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR5C2 [label = <BBA<br/>N elseClause<br/>fi ["else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR6C2 [label = <BBC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifStatementR5C2 -> ifStatementR6C2 [weight=100000000]
    ifStatementR4C2 -> ifStatementR5C2 [weight=100000000]
    rank = same {ifStatementR4C1 -> ifStatementR4C2}
    ifStatementR3C1 -> ifStatementR4C1 [weight=100000000]
    ifStatementR2C1 -> ifStatementR3C1 [weight=100000000]
    ifStatementR1C1 -> ifStatementR2C1 [weight=100000000]
    ifStatementR0C1 -> ifStatementR1C1 [weight=100000000]
    rank = same {ifStatementR0C0 -> ifStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {ifStatementR0C1 -> ifStatementR0C2}
    ifStatementR0C0 -> ifStatementR1C0 [weight=100000000]
    rank = same {ifStatementR1C0 -> ifStatementR1C1}
    ifStatementR0C2 -> ifStatementR1C2 [weight=100000000]
    rank = same {ifStatementR1C1 -> ifStatementR1C2}
    ifStatementR1C0 -> ifStatementR2C0 [weight=100000000]
    rank = same {ifStatementR2C0 -> ifStatementR2C1}
    ifStatementR1C2 -> ifStatementR2C2 [weight=100000000]
    rank = same {ifStatementR2C1 -> ifStatementR2C2}
    ifStatementR2C0 -> ifStatementR3C0 [weight=100000000]
    rank = same {ifStatementR3C0 -> ifStatementR3C1}
    ifStatementR2C2 -> ifStatementR3C2 [weight=100000000]
    rank = same {ifStatementR3C1 -> ifStatementR3C2}
    ifStatementR3C0 -> ifStatementR4C0 [weight=100000000]
    rank = same {ifStatementR4C0 -> ifStatementR4C1}
    ifStatementR3C2 -> ifStatementR4C2 [weight=100000000]
    ifStatementR4C0 -> ifStatementR5C0 [weight=100000000]
    rank = same {ifStatementR5C0 -> ifStatementR5C1}
    ifStatementR5C0 -> ifStatementR6C0 [weight=100000000]
    ifStatementR5C1 -> ifStatementR6C1 [weight=100000000]
    rank = same {ifStatementR6C0 -> ifStatementR6C1}
    rank = same {ifStatementR6C1 -> ifStatementR6C2}
  }
  subgraph clusterclassMembers {
    node [shape = box]
    label = <classMembers = classMember [ classMembers ] .>
    labeljust = l
    classMembersR0C0 [label = <DEK<br/>N classMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR0C1 [label = <DED<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR1C1 [label = <DEE<br/>N classMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    classMembersR2C1 [label = <DEI<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR3C1 [label = <DEJ<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR2C1 -> classMembersR3C1 [weight=100000000]
    classMembersR2C2 [label = <DEG<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR3C2 [label = <DEF<br/>N classMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR4C2 [label = <DEH<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    classMembersR3C2 -> classMembersR4C2 [weight=100000000]
    classMembersR2C2 -> classMembersR3C2 [weight=100000000]
    rank = same {classMembersR2C1 -> classMembersR2C2}
    classMembersR1C1 -> classMembersR2C1 [weight=100000000]
    classMembersR0C1 -> classMembersR1C1 [weight=100000000]
    rank = same {classMembersR0C0 -> classMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {classMembersR0C1 -> classMembersR0C2}
    classMembersR0C0 -> classMembersR1C0 [weight=100000000]
    rank = same {classMembersR1C0 -> classMembersR1C1}
    classMembersR0C2 -> classMembersR1C2 [weight=100000000]
    rank = same {classMembersR1C1 -> classMembersR1C2}
    classMembersR1C0 -> classMembersR2C0 [weight=100000000]
    rank = same {classMembersR2C0 -> classMembersR2C1}
    classMembersR1C2 -> classMembersR2C2 [weight=100000000]
    classMembersR2C0 -> classMembersR3C0 [weight=100000000]
    rank = same {classMembersR3C0 -> classMembersR3C1}
    classMembersR3C0 -> classMembersR4C0 [weight=100000000]
    classMembersR3C1 -> classMembersR4C1 [weight=100000000]
    rank = same {classMembersR4C0 -> classMembersR4C1}
    rank = same {classMembersR4C1 -> classMembersR4C2}
  }
  subgraph clusterexpressionPattern {
    node [shape = box]
    label = <expressionPattern = expression .>
    labeljust = l
    expressionPatternR0C0 [label = <ENL<br/>N expressionPattern<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionPatternR0C1 [label = <ENI<br/>ALT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionPatternR1C1 [label = <ENJ<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    expressionPatternR2C1 [label = <ENK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    expressionPatternR1C1 -> expressionPatternR2C1 [weight=100000000]
    expressionPatternR0C1 -> expressionPatternR1C1 [weight=100000000]
    rank = same {expressionPatternR0C0 -> expressionPatternR0C1}
    node [style = invis]
    edge [style = invis]
    expressionPatternR0C0 -> expressionPatternR1C0 [weight=100000000]
    rank = same {expressionPatternR1C0 -> expressionPatternR1C1}
    expressionPatternR1C0 -> expressionPatternR2C0 [weight=100000000]
    rank = same {expressionPatternR2C0 -> expressionPatternR2C1}
  }
  subgraph clusterclosureExpression {
    node [shape = box]
    label = <closureExpression = "{" [ attributes ] [ closureSignature ] [ statements ] "}" .>
    labeljust = l
    closureExpressionR0C0 [label = <ADP<br/>N closureExpression<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    closureExpressionR0C1 [label = <ACZ<br/>ALT <br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    closureExpressionR1C1 [label = <ADA<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR2C1 [label = <ADE<br/>OPT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    closureExpressionR3C1 [label = <ADI<br/>OPT <br/>fi ["", "["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR4C1 [label = <ADM<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    closureExpressionR5C1 [label = <ADN<br/>T "}"<br/>fi ["}"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    closureExpressionR6C1 [label = <ADO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    closureExpressionR5C1 -> closureExpressionR6C1 [weight=100000000]
    closureExpressionR4C1 -> closureExpressionR5C1 [weight=100000000]
    closureExpressionR4C2 [label = <ADK<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    closureExpressionR5C2 [label = <ADJ<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    closureExpressionR6C2 [label = <ADL<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    closureExpressionR5C2 -> closureExpressionR6C2 [weight=100000000]
    closureExpressionR4C2 -> closureExpressionR5C2 [weight=100000000]
    rank = same {closureExpressionR4C1 -> closureExpressionR4C2}
    closureExpressionR3C1 -> closureExpressionR4C1 [weight=100000000]
    closureExpressionR3C3 [label = <ADG<br/>ALT <br/>fi ["", "["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR4C3 [label = <ADF<br/>N closureSignature<br/>fi ["", "["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR5C3 [label = <ADH<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR4C3 -> closureExpressionR5C3 [weight=100000000]
    closureExpressionR3C3 -> closureExpressionR4C3 [weight=100000000]
    rank = same {closureExpressionR3C1 -> closureExpressionR3C3}
    closureExpressionR2C1 -> closureExpressionR3C1 [weight=100000000]
    closureExpressionR2C4 [label = <ADC<br/>ALT <br/>fi ["@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR3C4 [label = <ADB<br/>N attributes<br/>fi ["@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR4C4 [label = <ADD<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureExpressionR3C4 -> closureExpressionR4C4 [weight=100000000]
    closureExpressionR2C4 -> closureExpressionR3C4 [weight=100000000]
    rank = same {closureExpressionR2C1 -> closureExpressionR2C4}
    closureExpressionR1C1 -> closureExpressionR2C1 [weight=100000000]
    closureExpressionR0C1 -> closureExpressionR1C1 [weight=100000000]
    rank = same {closureExpressionR0C0 -> closureExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {closureExpressionR0C1 -> closureExpressionR0C2}
    rank = same {closureExpressionR0C2 -> closureExpressionR0C3}
    rank = same {closureExpressionR0C3 -> closureExpressionR0C4}
    closureExpressionR0C0 -> closureExpressionR1C0 [weight=100000000]
    rank = same {closureExpressionR1C0 -> closureExpressionR1C1}
    closureExpressionR0C2 -> closureExpressionR1C2 [weight=100000000]
    rank = same {closureExpressionR1C1 -> closureExpressionR1C2}
    closureExpressionR0C3 -> closureExpressionR1C3 [weight=100000000]
    rank = same {closureExpressionR1C2 -> closureExpressionR1C3}
    closureExpressionR0C4 -> closureExpressionR1C4 [weight=100000000]
    rank = same {closureExpressionR1C3 -> closureExpressionR1C4}
    closureExpressionR1C0 -> closureExpressionR2C0 [weight=100000000]
    rank = same {closureExpressionR2C0 -> closureExpressionR2C1}
    closureExpressionR1C4 -> closureExpressionR2C4 [weight=100000000]
    closureExpressionR2C0 -> closureExpressionR3C0 [weight=100000000]
    rank = same {closureExpressionR3C0 -> closureExpressionR3C1}
    closureExpressionR3C0 -> closureExpressionR4C0 [weight=100000000]
    rank = same {closureExpressionR4C0 -> closureExpressionR4C1}
    closureExpressionR4C0 -> closureExpressionR5C0 [weight=100000000]
    rank = same {closureExpressionR5C0 -> closureExpressionR5C1}
    closureExpressionR4C4 -> closureExpressionR5C4 [weight=100000000]
    rank = same {closureExpressionR5C3 -> closureExpressionR5C4}
    closureExpressionR5C0 -> closureExpressionR6C0 [weight=100000000]
    rank = same {closureExpressionR6C0 -> closureExpressionR6C1}
    closureExpressionR5C3 -> closureExpressionR6C3 [weight=100000000]
    rank = same {closureExpressionR6C2 -> closureExpressionR6C3}
    closureExpressionR5C4 -> closureExpressionR6C4 [weight=100000000]
    rank = same {closureExpressionR6C3 -> closureExpressionR6C4}
  }
  subgraph clusterreturnStatement {
    node [shape = box]
    label = <returnStatement = "return" [ expression ] .>
    labeljust = l
    returnStatementR0C0 [label = <BJG<br/>N returnStatement<br/>fi ["return"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    returnStatementR0C1 [label = <BIZ<br/>ALT <br/>fi ["return"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    returnStatementR1C1 [label = <BJA<br/>T "return"<br/>fi ["return"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    returnStatementR2C1 [label = <BJE<br/>OPT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    returnStatementR3C1 [label = <BJF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    returnStatementR2C1 -> returnStatementR3C1 [weight=100000000]
    returnStatementR2C2 [label = <BJC<br/>ALT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    returnStatementR3C2 [label = <BJB<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    returnStatementR4C2 [label = <BJD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    returnStatementR3C2 -> returnStatementR4C2 [weight=100000000]
    returnStatementR2C2 -> returnStatementR3C2 [weight=100000000]
    rank = same {returnStatementR2C1 -> returnStatementR2C2}
    returnStatementR1C1 -> returnStatementR2C1 [weight=100000000]
    returnStatementR0C1 -> returnStatementR1C1 [weight=100000000]
    rank = same {returnStatementR0C0 -> returnStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {returnStatementR0C1 -> returnStatementR0C2}
    returnStatementR0C0 -> returnStatementR1C0 [weight=100000000]
    rank = same {returnStatementR1C0 -> returnStatementR1C1}
    returnStatementR0C2 -> returnStatementR1C2 [weight=100000000]
    rank = same {returnStatementR1C1 -> returnStatementR1C2}
    returnStatementR1C0 -> returnStatementR2C0 [weight=100000000]
    rank = same {returnStatementR2C0 -> returnStatementR2C1}
    returnStatementR1C2 -> returnStatementR2C2 [weight=100000000]
    returnStatementR2C0 -> returnStatementR3C0 [weight=100000000]
    rank = same {returnStatementR3C0 -> returnStatementR3C1}
    returnStatementR3C0 -> returnStatementR4C0 [weight=100000000]
    returnStatementR3C1 -> returnStatementR4C1 [weight=100000000]
    rank = same {returnStatementR4C0 -> returnStatementR4C1}
    rank = same {returnStatementR4C1 -> returnStatementR4C2}
  }
  subgraph clusterinfixOperator {
    node [shape = box]
    label = <infixOperator = Operator .>
    labeljust = l
    infixOperatorR0C0 [label = <DP<br/>N infixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixOperatorR0C1 [label = <DM<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixOperatorR1C1 [label = <DN<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixOperatorR2C1 [label = <DO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixOperatorR1C1 -> infixOperatorR2C1 [weight=100000000]
    infixOperatorR0C1 -> infixOperatorR1C1 [weight=100000000]
    rank = same {infixOperatorR0C0 -> infixOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    infixOperatorR0C0 -> infixOperatorR1C0 [weight=100000000]
    rank = same {infixOperatorR1C0 -> infixOperatorR1C1}
    infixOperatorR1C0 -> infixOperatorR2C0 [weight=100000000]
    rank = same {infixOperatorR2C0 -> infixOperatorR2C1}
  }
  subgraph clusterliteralExpression {
    node [shape = box]
    label = <literalExpression = literal | arrayLiteral | dictionaryLiteral | playgroundLiteral .>
    labeljust = l
    literalExpressionR0C0 [label = <UR<br/>N literalExpression<br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral", "[", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["["]<br/>>]
    literalExpressionR0C1 [label = <UO<br/>ALT <br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C1 [label = <UP<br/>N literal<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR2C1 [label = <UQ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C1 -> literalExpressionR2C1 [weight=100000000]
    literalExpressionR0C1 -> literalExpressionR1C1 [weight=100000000]
    literalExpressionR0C2 [label = <US<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C2 [label = <UT<br/>N arrayLiteral<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR2C2 [label = <UU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C2 -> literalExpressionR2C2 [weight=100000000]
    literalExpressionR0C2 -> literalExpressionR1C2 [weight=100000000]
    literalExpressionR0C3 [label = <UV<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C3 [label = <UW<br/>N dictionaryLiteral<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR2C3 [label = <UX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C3 -> literalExpressionR2C3 [weight=100000000]
    literalExpressionR0C3 -> literalExpressionR1C3 [weight=100000000]
    literalExpressionR0C4 [label = <UY<br/>ALT <br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C4 [label = <UZ<br/>N playgroundLiteral<br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR2C4 [label = <VA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalExpressionR1C4 -> literalExpressionR2C4 [weight=100000000]
    literalExpressionR0C4 -> literalExpressionR1C4 [weight=100000000]
    rank = same {literalExpressionR0C3 -> literalExpressionR0C4}
    rank = same {literalExpressionR0C2 -> literalExpressionR0C3}
    rank = same {literalExpressionR0C1 -> literalExpressionR0C2}
    rank = same {literalExpressionR0C0 -> literalExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    literalExpressionR0C0 -> literalExpressionR1C0 [weight=100000000]
    rank = same {literalExpressionR1C0 -> literalExpressionR1C1}
    literalExpressionR1C0 -> literalExpressionR2C0 [weight=100000000]
    rank = same {literalExpressionR2C0 -> literalExpressionR2C1}
  }
  subgraph clusterdeclarationModifier {
    node [shape = box]
    label = <declarationModifier = "class" | "convenience" | "dynamic" | "final" | "infix" | "lazy" | "optional" | "override" | "postfix" | "prefix" | "required" | "static" | "unowned" | "unowned" "(" "safe" ")" | "unowned" "(" "unsafe" ")" | "weak" | accessLevelModifier | mutationModifier | actorIsolationModifier .>
    labeljust = l
    declarationModifierR0C0 [label = <ECD<br/>N declarationModifier<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am ["unowned"]<br/>>]
    declarationModifierR0C1 [label = <EAB<br/>ALT <br/>fi ["class"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C1 [label = <EAC<br/>T "class"<br/>fi ["class"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C1 [label = <EAD<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C1 -> declarationModifierR2C1 [weight=100000000]
    declarationModifierR0C1 -> declarationModifierR1C1 [weight=100000000]
    declarationModifierR0C2 [label = <EAE<br/>ALT <br/>fi ["convenience"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C2 [label = <EAF<br/>T "convenience"<br/>fi ["convenience"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C2 [label = <EAG<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C2 -> declarationModifierR2C2 [weight=100000000]
    declarationModifierR0C2 -> declarationModifierR1C2 [weight=100000000]
    declarationModifierR0C3 [label = <EAH<br/>ALT <br/>fi ["dynamic"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C3 [label = <EAI<br/>T "dynamic"<br/>fi ["dynamic"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C3 [label = <EAJ<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C3 -> declarationModifierR2C3 [weight=100000000]
    declarationModifierR0C3 -> declarationModifierR1C3 [weight=100000000]
    declarationModifierR0C4 [label = <EAK<br/>ALT <br/>fi ["final"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C4 [label = <EAL<br/>T "final"<br/>fi ["final"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C4 [label = <EAM<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C4 -> declarationModifierR2C4 [weight=100000000]
    declarationModifierR0C4 -> declarationModifierR1C4 [weight=100000000]
    declarationModifierR0C5 [label = <EAN<br/>ALT <br/>fi ["infix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C5 [label = <EAO<br/>T "infix"<br/>fi ["infix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C5 [label = <EAP<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C5 -> declarationModifierR2C5 [weight=100000000]
    declarationModifierR0C5 -> declarationModifierR1C5 [weight=100000000]
    declarationModifierR0C6 [label = <EAQ<br/>ALT <br/>fi ["lazy"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C6 [label = <EAR<br/>T "lazy"<br/>fi ["lazy"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C6 [label = <EAS<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C6 -> declarationModifierR2C6 [weight=100000000]
    declarationModifierR0C6 -> declarationModifierR1C6 [weight=100000000]
    declarationModifierR0C7 [label = <EAT<br/>ALT <br/>fi ["optional"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C7 [label = <EAU<br/>T "optional"<br/>fi ["optional"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C7 [label = <EAV<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C7 -> declarationModifierR2C7 [weight=100000000]
    declarationModifierR0C7 -> declarationModifierR1C7 [weight=100000000]
    declarationModifierR0C8 [label = <EAW<br/>ALT <br/>fi ["override"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C8 [label = <EAX<br/>T "override"<br/>fi ["override"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C8 [label = <EAY<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C8 -> declarationModifierR2C8 [weight=100000000]
    declarationModifierR0C8 -> declarationModifierR1C8 [weight=100000000]
    declarationModifierR0C9 [label = <EAZ<br/>ALT <br/>fi ["postfix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C9 [label = <EBA<br/>T "postfix"<br/>fi ["postfix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C9 [label = <EBB<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C9 -> declarationModifierR2C9 [weight=100000000]
    declarationModifierR0C9 -> declarationModifierR1C9 [weight=100000000]
    declarationModifierR0C10 [label = <EBC<br/>ALT <br/>fi ["prefix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C10 [label = <EBD<br/>T "prefix"<br/>fi ["prefix"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C10 [label = <EBE<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C10 -> declarationModifierR2C10 [weight=100000000]
    declarationModifierR0C10 -> declarationModifierR1C10 [weight=100000000]
    declarationModifierR0C11 [label = <EBF<br/>ALT <br/>fi ["required"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C11 [label = <EBG<br/>T "required"<br/>fi ["required"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C11 [label = <EBH<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C11 -> declarationModifierR2C11 [weight=100000000]
    declarationModifierR0C11 -> declarationModifierR1C11 [weight=100000000]
    declarationModifierR0C12 [label = <EBI<br/>ALT <br/>fi ["static"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C12 [label = <EBJ<br/>T "static"<br/>fi ["static"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C12 [label = <EBK<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C12 -> declarationModifierR2C12 [weight=100000000]
    declarationModifierR0C12 -> declarationModifierR1C12 [weight=100000000]
    declarationModifierR0C13 [label = <EBL<br/>ALT <br/>fi ["unowned"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C13 [label = <EBM<br/>T "unowned"<br/>fi ["unowned"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C13 [label = <EBN<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C13 -> declarationModifierR2C13 [weight=100000000]
    declarationModifierR0C13 -> declarationModifierR1C13 [weight=100000000]
    declarationModifierR0C14 [label = <EBO<br/>ALT <br/>fi ["unowned"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C14 [label = <EBP<br/>T "unowned"<br/>fi ["unowned"]<br/>fo ["("]<br/>am []<br/>>]
    declarationModifierR2C14 [label = <EBQ<br/>T "("<br/>fi ["("]<br/>fo ["safe"]<br/>am []<br/>>]
    declarationModifierR3C14 [label = <EBR<br/>T "safe"<br/>fi ["safe"]<br/>fo [")"]<br/>am []<br/>>]
    declarationModifierR4C14 [label = <EBS<br/>T ")"<br/>fi [")"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR5C14 [label = <EBT<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR4C14 -> declarationModifierR5C14 [weight=100000000]
    declarationModifierR3C14 -> declarationModifierR4C14 [weight=100000000]
    declarationModifierR2C14 -> declarationModifierR3C14 [weight=100000000]
    declarationModifierR1C14 -> declarationModifierR2C14 [weight=100000000]
    declarationModifierR0C14 -> declarationModifierR1C14 [weight=100000000]
    declarationModifierR0C15 [label = <EBU<br/>ALT <br/>fi ["unowned"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C15 [label = <EBV<br/>T "unowned"<br/>fi ["unowned"]<br/>fo ["("]<br/>am []<br/>>]
    declarationModifierR2C15 [label = <EBW<br/>T "("<br/>fi ["("]<br/>fo ["unsafe"]<br/>am []<br/>>]
    declarationModifierR3C15 [label = <EBX<br/>T "unsafe"<br/>fi ["unsafe"]<br/>fo [")"]<br/>am []<br/>>]
    declarationModifierR4C15 [label = <EBY<br/>T ")"<br/>fi [")"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR5C15 [label = <EBZ<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR4C15 -> declarationModifierR5C15 [weight=100000000]
    declarationModifierR3C15 -> declarationModifierR4C15 [weight=100000000]
    declarationModifierR2C15 -> declarationModifierR3C15 [weight=100000000]
    declarationModifierR1C15 -> declarationModifierR2C15 [weight=100000000]
    declarationModifierR0C15 -> declarationModifierR1C15 [weight=100000000]
    declarationModifierR0C16 [label = <ECA<br/>ALT <br/>fi ["weak"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C16 [label = <ECB<br/>T "weak"<br/>fi ["weak"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C16 [label = <ECC<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C16 -> declarationModifierR2C16 [weight=100000000]
    declarationModifierR0C16 -> declarationModifierR1C16 [weight=100000000]
    declarationModifierR0C17 [label = <ECE<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C17 [label = <ECF<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C17 [label = <ECG<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C17 -> declarationModifierR2C17 [weight=100000000]
    declarationModifierR0C17 -> declarationModifierR1C17 [weight=100000000]
    declarationModifierR0C18 [label = <ECH<br/>ALT <br/>fi ["mutating", "nonmutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C18 [label = <ECI<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C18 [label = <ECJ<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C18 -> declarationModifierR2C18 [weight=100000000]
    declarationModifierR0C18 -> declarationModifierR1C18 [weight=100000000]
    declarationModifierR0C19 [label = <ECK<br/>ALT <br/>fi ["nonisolated"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C19 [label = <ECL<br/>N actorIsolationModifier<br/>fi ["nonisolated"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR2C19 [label = <ECM<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    declarationModifierR1C19 -> declarationModifierR2C19 [weight=100000000]
    declarationModifierR0C19 -> declarationModifierR1C19 [weight=100000000]
    rank = same {declarationModifierR0C18 -> declarationModifierR0C19}
    rank = same {declarationModifierR0C17 -> declarationModifierR0C18}
    rank = same {declarationModifierR0C16 -> declarationModifierR0C17}
    rank = same {declarationModifierR0C15 -> declarationModifierR0C16}
    rank = same {declarationModifierR0C14 -> declarationModifierR0C15}
    rank = same {declarationModifierR0C13 -> declarationModifierR0C14}
    rank = same {declarationModifierR0C12 -> declarationModifierR0C13}
    rank = same {declarationModifierR0C11 -> declarationModifierR0C12}
    rank = same {declarationModifierR0C10 -> declarationModifierR0C11}
    rank = same {declarationModifierR0C9 -> declarationModifierR0C10}
    rank = same {declarationModifierR0C8 -> declarationModifierR0C9}
    rank = same {declarationModifierR0C7 -> declarationModifierR0C8}
    rank = same {declarationModifierR0C6 -> declarationModifierR0C7}
    rank = same {declarationModifierR0C5 -> declarationModifierR0C6}
    rank = same {declarationModifierR0C4 -> declarationModifierR0C5}
    rank = same {declarationModifierR0C3 -> declarationModifierR0C4}
    rank = same {declarationModifierR0C2 -> declarationModifierR0C3}
    rank = same {declarationModifierR0C1 -> declarationModifierR0C2}
    rank = same {declarationModifierR0C0 -> declarationModifierR0C1}
    node [style = invis]
    edge [style = invis]
    declarationModifierR0C0 -> declarationModifierR1C0 [weight=100000000]
    rank = same {declarationModifierR1C0 -> declarationModifierR1C1}
    declarationModifierR1C0 -> declarationModifierR2C0 [weight=100000000]
    rank = same {declarationModifierR2C0 -> declarationModifierR2C1}
    declarationModifierR2C0 -> declarationModifierR3C0 [weight=100000000]
    declarationModifierR2C1 -> declarationModifierR3C1 [weight=100000000]
    rank = same {declarationModifierR3C0 -> declarationModifierR3C1}
    declarationModifierR2C2 -> declarationModifierR3C2 [weight=100000000]
    rank = same {declarationModifierR3C1 -> declarationModifierR3C2}
    declarationModifierR2C3 -> declarationModifierR3C3 [weight=100000000]
    rank = same {declarationModifierR3C2 -> declarationModifierR3C3}
    declarationModifierR2C4 -> declarationModifierR3C4 [weight=100000000]
    rank = same {declarationModifierR3C3 -> declarationModifierR3C4}
    declarationModifierR2C5 -> declarationModifierR3C5 [weight=100000000]
    rank = same {declarationModifierR3C4 -> declarationModifierR3C5}
    declarationModifierR2C6 -> declarationModifierR3C6 [weight=100000000]
    rank = same {declarationModifierR3C5 -> declarationModifierR3C6}
    declarationModifierR2C7 -> declarationModifierR3C7 [weight=100000000]
    rank = same {declarationModifierR3C6 -> declarationModifierR3C7}
    declarationModifierR2C8 -> declarationModifierR3C8 [weight=100000000]
    rank = same {declarationModifierR3C7 -> declarationModifierR3C8}
    declarationModifierR2C9 -> declarationModifierR3C9 [weight=100000000]
    rank = same {declarationModifierR3C8 -> declarationModifierR3C9}
    declarationModifierR2C10 -> declarationModifierR3C10 [weight=100000000]
    rank = same {declarationModifierR3C9 -> declarationModifierR3C10}
    declarationModifierR2C11 -> declarationModifierR3C11 [weight=100000000]
    rank = same {declarationModifierR3C10 -> declarationModifierR3C11}
    declarationModifierR2C12 -> declarationModifierR3C12 [weight=100000000]
    rank = same {declarationModifierR3C11 -> declarationModifierR3C12}
    declarationModifierR2C13 -> declarationModifierR3C13 [weight=100000000]
    rank = same {declarationModifierR3C12 -> declarationModifierR3C13}
    rank = same {declarationModifierR3C13 -> declarationModifierR3C14}
    declarationModifierR2C16 -> declarationModifierR3C16 [weight=100000000]
    rank = same {declarationModifierR3C15 -> declarationModifierR3C16}
    declarationModifierR2C17 -> declarationModifierR3C17 [weight=100000000]
    rank = same {declarationModifierR3C16 -> declarationModifierR3C17}
    declarationModifierR2C18 -> declarationModifierR3C18 [weight=100000000]
    rank = same {declarationModifierR3C17 -> declarationModifierR3C18}
    declarationModifierR2C19 -> declarationModifierR3C19 [weight=100000000]
    rank = same {declarationModifierR3C18 -> declarationModifierR3C19}
    declarationModifierR3C0 -> declarationModifierR4C0 [weight=100000000]
    declarationModifierR3C1 -> declarationModifierR4C1 [weight=100000000]
    rank = same {declarationModifierR4C0 -> declarationModifierR4C1}
    declarationModifierR3C2 -> declarationModifierR4C2 [weight=100000000]
    rank = same {declarationModifierR4C1 -> declarationModifierR4C2}
    declarationModifierR3C3 -> declarationModifierR4C3 [weight=100000000]
    rank = same {declarationModifierR4C2 -> declarationModifierR4C3}
    declarationModifierR3C4 -> declarationModifierR4C4 [weight=100000000]
    rank = same {declarationModifierR4C3 -> declarationModifierR4C4}
    declarationModifierR3C5 -> declarationModifierR4C5 [weight=100000000]
    rank = same {declarationModifierR4C4 -> declarationModifierR4C5}
    declarationModifierR3C6 -> declarationModifierR4C6 [weight=100000000]
    rank = same {declarationModifierR4C5 -> declarationModifierR4C6}
    declarationModifierR3C7 -> declarationModifierR4C7 [weight=100000000]
    rank = same {declarationModifierR4C6 -> declarationModifierR4C7}
    declarationModifierR3C8 -> declarationModifierR4C8 [weight=100000000]
    rank = same {declarationModifierR4C7 -> declarationModifierR4C8}
    declarationModifierR3C9 -> declarationModifierR4C9 [weight=100000000]
    rank = same {declarationModifierR4C8 -> declarationModifierR4C9}
    declarationModifierR3C10 -> declarationModifierR4C10 [weight=100000000]
    rank = same {declarationModifierR4C9 -> declarationModifierR4C10}
    declarationModifierR3C11 -> declarationModifierR4C11 [weight=100000000]
    rank = same {declarationModifierR4C10 -> declarationModifierR4C11}
    declarationModifierR3C12 -> declarationModifierR4C12 [weight=100000000]
    rank = same {declarationModifierR4C11 -> declarationModifierR4C12}
    declarationModifierR3C13 -> declarationModifierR4C13 [weight=100000000]
    rank = same {declarationModifierR4C12 -> declarationModifierR4C13}
    rank = same {declarationModifierR4C13 -> declarationModifierR4C14}
    declarationModifierR3C16 -> declarationModifierR4C16 [weight=100000000]
    rank = same {declarationModifierR4C15 -> declarationModifierR4C16}
    declarationModifierR3C17 -> declarationModifierR4C17 [weight=100000000]
    rank = same {declarationModifierR4C16 -> declarationModifierR4C17}
    declarationModifierR3C18 -> declarationModifierR4C18 [weight=100000000]
    rank = same {declarationModifierR4C17 -> declarationModifierR4C18}
    declarationModifierR3C19 -> declarationModifierR4C19 [weight=100000000]
    rank = same {declarationModifierR4C18 -> declarationModifierR4C19}
    declarationModifierR4C0 -> declarationModifierR5C0 [weight=100000000]
    declarationModifierR4C1 -> declarationModifierR5C1 [weight=100000000]
    rank = same {declarationModifierR5C0 -> declarationModifierR5C1}
    declarationModifierR4C2 -> declarationModifierR5C2 [weight=100000000]
    rank = same {declarationModifierR5C1 -> declarationModifierR5C2}
    declarationModifierR4C3 -> declarationModifierR5C3 [weight=100000000]
    rank = same {declarationModifierR5C2 -> declarationModifierR5C3}
    declarationModifierR4C4 -> declarationModifierR5C4 [weight=100000000]
    rank = same {declarationModifierR5C3 -> declarationModifierR5C4}
    declarationModifierR4C5 -> declarationModifierR5C5 [weight=100000000]
    rank = same {declarationModifierR5C4 -> declarationModifierR5C5}
    declarationModifierR4C6 -> declarationModifierR5C6 [weight=100000000]
    rank = same {declarationModifierR5C5 -> declarationModifierR5C6}
    declarationModifierR4C7 -> declarationModifierR5C7 [weight=100000000]
    rank = same {declarationModifierR5C6 -> declarationModifierR5C7}
    declarationModifierR4C8 -> declarationModifierR5C8 [weight=100000000]
    rank = same {declarationModifierR5C7 -> declarationModifierR5C8}
    declarationModifierR4C9 -> declarationModifierR5C9 [weight=100000000]
    rank = same {declarationModifierR5C8 -> declarationModifierR5C9}
    declarationModifierR4C10 -> declarationModifierR5C10 [weight=100000000]
    rank = same {declarationModifierR5C9 -> declarationModifierR5C10}
    declarationModifierR4C11 -> declarationModifierR5C11 [weight=100000000]
    rank = same {declarationModifierR5C10 -> declarationModifierR5C11}
    declarationModifierR4C12 -> declarationModifierR5C12 [weight=100000000]
    rank = same {declarationModifierR5C11 -> declarationModifierR5C12}
    declarationModifierR4C13 -> declarationModifierR5C13 [weight=100000000]
    rank = same {declarationModifierR5C12 -> declarationModifierR5C13}
    rank = same {declarationModifierR5C13 -> declarationModifierR5C14}
    declarationModifierR4C16 -> declarationModifierR5C16 [weight=100000000]
    rank = same {declarationModifierR5C15 -> declarationModifierR5C16}
    declarationModifierR4C17 -> declarationModifierR5C17 [weight=100000000]
    rank = same {declarationModifierR5C16 -> declarationModifierR5C17}
    declarationModifierR4C18 -> declarationModifierR5C18 [weight=100000000]
    rank = same {declarationModifierR5C17 -> declarationModifierR5C18}
    declarationModifierR4C19 -> declarationModifierR5C19 [weight=100000000]
    rank = same {declarationModifierR5C18 -> declarationModifierR5C19}
  }
  subgraph clustervalueBindingPattern {
    node [shape = box]
    label = <valueBindingPattern = "var" pattern | "let" pattern .>
    labeljust = l
    valueBindingPatternR0C0 [label = <EKW<br/>N valueBindingPattern<br/>fi ["let", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR0C1 [label = <EKO<br/>ALT <br/>fi ["var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR1C1 [label = <EKP<br/>T "var"<br/>fi ["var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "_", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR2C1 [label = <EKQ<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    valueBindingPatternR3C1 [label = <EKR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR2C1 -> valueBindingPatternR3C1 [weight=100000000]
    valueBindingPatternR1C1 -> valueBindingPatternR2C1 [weight=100000000]
    valueBindingPatternR0C1 -> valueBindingPatternR1C1 [weight=100000000]
    valueBindingPatternR0C2 [label = <EKS<br/>ALT <br/>fi ["let"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR1C2 [label = <EKT<br/>T "let"<br/>fi ["let"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "_", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR2C2 [label = <EKU<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    valueBindingPatternR3C2 [label = <EKV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    valueBindingPatternR2C2 -> valueBindingPatternR3C2 [weight=100000000]
    valueBindingPatternR1C2 -> valueBindingPatternR2C2 [weight=100000000]
    valueBindingPatternR0C2 -> valueBindingPatternR1C2 [weight=100000000]
    rank = same {valueBindingPatternR0C1 -> valueBindingPatternR0C2}
    rank = same {valueBindingPatternR0C0 -> valueBindingPatternR0C1}
    node [style = invis]
    edge [style = invis]
    valueBindingPatternR0C0 -> valueBindingPatternR1C0 [weight=100000000]
    rank = same {valueBindingPatternR1C0 -> valueBindingPatternR1C1}
    valueBindingPatternR1C0 -> valueBindingPatternR2C0 [weight=100000000]
    rank = same {valueBindingPatternR2C0 -> valueBindingPatternR2C1}
    valueBindingPatternR2C0 -> valueBindingPatternR3C0 [weight=100000000]
    rank = same {valueBindingPatternR3C0 -> valueBindingPatternR3C1}
  }
  subgraph clustergenericArgumentList {
    node [shape = box]
    label = <genericArgumentList = genericArgument | genericArgument "," genericArgumentList .>
    labeljust = l
    genericArgumentListR0C0 [label = <EQP<br/>N genericArgumentList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>>]
    genericArgumentListR0C1 [label = <EQH<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR1C1 [label = <EQI<br/>N genericArgument<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR2C1 [label = <EQJ<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR1C1 -> genericArgumentListR2C1 [weight=100000000]
    genericArgumentListR0C1 -> genericArgumentListR1C1 [weight=100000000]
    genericArgumentListR0C2 [label = <EQK<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR1C2 [label = <EQL<br/>N genericArgument<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [","]<br/>am []<br/>>]
    genericArgumentListR2C2 [label = <EQM<br/>T ","<br/>fi [","]<br/>fo ["(", "&gt;", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    genericArgumentListR3C2 [label = <EQN<br/>N genericArgumentList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR4C2 [label = <EQO<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentListR3C2 -> genericArgumentListR4C2 [weight=100000000]
    genericArgumentListR2C2 -> genericArgumentListR3C2 [weight=100000000]
    genericArgumentListR1C2 -> genericArgumentListR2C2 [weight=100000000]
    genericArgumentListR0C2 -> genericArgumentListR1C2 [weight=100000000]
    rank = same {genericArgumentListR0C1 -> genericArgumentListR0C2}
    rank = same {genericArgumentListR0C0 -> genericArgumentListR0C1}
    node [style = invis]
    edge [style = invis]
    genericArgumentListR0C0 -> genericArgumentListR1C0 [weight=100000000]
    rank = same {genericArgumentListR1C0 -> genericArgumentListR1C1}
    genericArgumentListR1C0 -> genericArgumentListR2C0 [weight=100000000]
    rank = same {genericArgumentListR2C0 -> genericArgumentListR2C1}
    genericArgumentListR2C0 -> genericArgumentListR3C0 [weight=100000000]
    genericArgumentListR2C1 -> genericArgumentListR3C1 [weight=100000000]
    rank = same {genericArgumentListR3C0 -> genericArgumentListR3C1}
    rank = same {genericArgumentListR3C1 -> genericArgumentListR3C2}
    genericArgumentListR3C0 -> genericArgumentListR4C0 [weight=100000000]
    genericArgumentListR3C1 -> genericArgumentListR4C1 [weight=100000000]
    rank = same {genericArgumentListR4C0 -> genericArgumentListR4C1}
    rank = same {genericArgumentListR4C1 -> genericArgumentListR4C2}
  }
  subgraph clusterOperator {
    node [shape = box]
    label = <Operator = "plainOperator" | "dotOperator" .>
    labeljust = l
    OperatorR0C0 [label = <DL<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR0C1 [label = <DF<br/>ALT <br/>fi ["plainOperator"]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR1C1 [label = <DG<br/>T "plainOperator"<br/>fi ["plainOperator"]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR2C1 [label = <DH<br/>END <br/>fi [""]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR1C1 -> OperatorR2C1 [weight=100000000]
    OperatorR0C1 -> OperatorR1C1 [weight=100000000]
    OperatorR0C2 [label = <DI<br/>ALT <br/>fi ["dotOperator"]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR1C2 [label = <DJ<br/>T "dotOperator"<br/>fi ["dotOperator"]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR2C2 [label = <DK<br/>END <br/>fi [""]<br/>fo ["!", "#", "#colorLiteral", "#else", "#elseif", "#endif", "#error", "#fileLiteral", "#if", "#imageLiteral", "#keyPath", "#selector", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "\\", "]", "_", "as", "binaryLiteral", "break", "continue", "decimalFloatingPointLiteral", "decimalLiteral", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "false", "for", "guard", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "in", "infix", "interpolatedStringLiteral", "is", "nil", "octalLiteral", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "regularExpressionLiteral", "repeat", "return", "self", "staticStringLiteral", "super", "switch", "throw", "true", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    OperatorR1C2 -> OperatorR2C2 [weight=100000000]
    OperatorR0C2 -> OperatorR1C2 [weight=100000000]
    rank = same {OperatorR0C1 -> OperatorR0C2}
    rank = same {OperatorR0C0 -> OperatorR0C1}
    node [style = invis]
    edge [style = invis]
    OperatorR0C0 -> OperatorR1C0 [weight=100000000]
    rank = same {OperatorR1C0 -> OperatorR1C1}
    OperatorR1C0 -> OperatorR2C0 [weight=100000000]
    rank = same {OperatorR2C0 -> OperatorR2C1}
  }
  subgraph clusteridentifierPattern {
    node [shape = box]
    label = <identifierPattern = identifier .>
    labeljust = l
    identifierPatternR0C0 [label = <EKN<br/>N identifierPattern<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    identifierPatternR0C1 [label = <EKK<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    identifierPatternR1C1 [label = <EKL<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    identifierPatternR2C1 [label = <EKM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    identifierPatternR1C1 -> identifierPatternR2C1 [weight=100000000]
    identifierPatternR0C1 -> identifierPatternR1C1 [weight=100000000]
    rank = same {identifierPatternR0C0 -> identifierPatternR0C1}
    node [style = invis]
    edge [style = invis]
    identifierPatternR0C0 -> identifierPatternR1C0 [weight=100000000]
    rank = same {identifierPatternR1C0 -> identifierPatternR1C1}
    identifierPatternR1C0 -> identifierPatternR2C0 [weight=100000000]
    rank = same {identifierPatternR2C0 -> identifierPatternR2C1}
  }
  subgraph clusterswiftVersion {
    node [shape = box]
    label = <swiftVersion = "decimalDigits" [ swiftVersionContinuation ] .>
    labeljust = l
    swiftVersionR0C0 [label = <BTB<br/>N swiftVersion<br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR0C1 [label = <BSU<br/>ALT <br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR1C1 [label = <BSV<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo [")", "."]<br/>am []<br/>>]
    swiftVersionR2C1 [label = <BSZ<br/>OPT <br/>fi ["", "."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR3C1 [label = <BTA<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR2C1 -> swiftVersionR3C1 [weight=100000000]
    swiftVersionR2C2 [label = <BSX<br/>ALT <br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR3C2 [label = <BSW<br/>N swiftVersionContinuation<br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR4C2 [label = <BSY<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionR3C2 -> swiftVersionR4C2 [weight=100000000]
    swiftVersionR2C2 -> swiftVersionR3C2 [weight=100000000]
    rank = same {swiftVersionR2C1 -> swiftVersionR2C2}
    swiftVersionR1C1 -> swiftVersionR2C1 [weight=100000000]
    swiftVersionR0C1 -> swiftVersionR1C1 [weight=100000000]
    rank = same {swiftVersionR0C0 -> swiftVersionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {swiftVersionR0C1 -> swiftVersionR0C2}
    swiftVersionR0C0 -> swiftVersionR1C0 [weight=100000000]
    rank = same {swiftVersionR1C0 -> swiftVersionR1C1}
    swiftVersionR0C2 -> swiftVersionR1C2 [weight=100000000]
    rank = same {swiftVersionR1C1 -> swiftVersionR1C2}
    swiftVersionR1C0 -> swiftVersionR2C0 [weight=100000000]
    rank = same {swiftVersionR2C0 -> swiftVersionR2C1}
    swiftVersionR1C2 -> swiftVersionR2C2 [weight=100000000]
    swiftVersionR2C0 -> swiftVersionR3C0 [weight=100000000]
    rank = same {swiftVersionR3C0 -> swiftVersionR3C1}
    swiftVersionR3C0 -> swiftVersionR4C0 [weight=100000000]
    swiftVersionR3C1 -> swiftVersionR4C1 [weight=100000000]
    rank = same {swiftVersionR4C0 -> swiftVersionR4C1}
    rank = same {swiftVersionR4C1 -> swiftVersionR4C2}
  }
  subgraph clustergenericParameterClause {
    node [shape = box]
    label = <genericParameterClause = "&lt;" genericParameterList "&gt;" .>
    labeljust = l
    genericParameterClauseR0C0 [label = <ENR<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["(", ":", "=", "where", "{"]<br/>am []<br/>>]
    genericParameterClauseR0C1 [label = <ENM<br/>ALT <br/>fi ["&lt;"]<br/>fo ["(", ":", "=", "where", "{"]<br/>am []<br/>>]
    genericParameterClauseR1C1 [label = <ENN<br/>T "&lt;"<br/>fi ["&lt;"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    genericParameterClauseR2C1 [label = <ENO<br/>N genericParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterClauseR3C1 [label = <ENP<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["(", ":", "=", "where", "{"]<br/>am []<br/>>]
    genericParameterClauseR4C1 [label = <ENQ<br/>END <br/>fi [""]<br/>fo ["(", ":", "=", "where", "{"]<br/>am []<br/>>]
    genericParameterClauseR3C1 -> genericParameterClauseR4C1 [weight=100000000]
    genericParameterClauseR2C1 -> genericParameterClauseR3C1 [weight=100000000]
    genericParameterClauseR1C1 -> genericParameterClauseR2C1 [weight=100000000]
    genericParameterClauseR0C1 -> genericParameterClauseR1C1 [weight=100000000]
    rank = same {genericParameterClauseR0C0 -> genericParameterClauseR0C1}
    node [style = invis]
    edge [style = invis]
    genericParameterClauseR0C0 -> genericParameterClauseR1C0 [weight=100000000]
    rank = same {genericParameterClauseR1C0 -> genericParameterClauseR1C1}
    genericParameterClauseR1C0 -> genericParameterClauseR2C0 [weight=100000000]
    rank = same {genericParameterClauseR2C0 -> genericParameterClauseR2C1}
    genericParameterClauseR2C0 -> genericParameterClauseR3C0 [weight=100000000]
    rank = same {genericParameterClauseR3C0 -> genericParameterClauseR3C1}
    genericParameterClauseR3C0 -> genericParameterClauseR4C0 [weight=100000000]
    rank = same {genericParameterClauseR4C0 -> genericParameterClauseR4C1}
  }
  subgraph clustertupleTypeElement {
    node [shape = box]
    label = <tupleTypeElement = elementName typeAnnotation | type .>
    labeljust = l
    tupleTypeElementR0C0 [label = <HY<br/>N tupleTypeElement<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")", ","]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    tupleTypeElementR0C1 [label = <HR<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR1C1 [label = <HS<br/>N elementName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    tupleTypeElementR2C1 [label = <HT<br/>N typeAnnotation<br/>fi [":"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR3C1 [label = <HU<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR2C1 -> tupleTypeElementR3C1 [weight=100000000]
    tupleTypeElementR1C1 -> tupleTypeElementR2C1 [weight=100000000]
    tupleTypeElementR0C1 -> tupleTypeElementR1C1 [weight=100000000]
    tupleTypeElementR0C2 [label = <HV<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR1C2 [label = <HW<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR2C2 [label = <HX<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleTypeElementR1C2 -> tupleTypeElementR2C2 [weight=100000000]
    tupleTypeElementR0C2 -> tupleTypeElementR1C2 [weight=100000000]
    rank = same {tupleTypeElementR0C1 -> tupleTypeElementR0C2}
    rank = same {tupleTypeElementR0C0 -> tupleTypeElementR0C1}
    node [style = invis]
    edge [style = invis]
    tupleTypeElementR0C0 -> tupleTypeElementR1C0 [weight=100000000]
    rank = same {tupleTypeElementR1C0 -> tupleTypeElementR1C1}
    tupleTypeElementR1C0 -> tupleTypeElementR2C0 [weight=100000000]
    rank = same {tupleTypeElementR2C0 -> tupleTypeElementR2C1}
    tupleTypeElementR2C0 -> tupleTypeElementR3C0 [weight=100000000]
    rank = same {tupleTypeElementR3C0 -> tupleTypeElementR3C1}
    tupleTypeElementR2C2 -> tupleTypeElementR3C2 [weight=100000000]
    rank = same {tupleTypeElementR3C1 -> tupleTypeElementR3C2}
  }
  subgraph clustertypealiasAssignment {
    node [shape = box]
    label = <typealiasAssignment = "=" type .>
    labeljust = l
    typealiasAssignmentR0C0 [label = <CMC<br/>N typealiasAssignment<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "}"]<br/>am []<br/>>]
    typealiasAssignmentR0C1 [label = <CLY<br/>ALT <br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "}"]<br/>am []<br/>>]
    typealiasAssignmentR1C1 [label = <CLZ<br/>T "="<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "}"]<br/>am []<br/>>]
    typealiasAssignmentR2C1 [label = <CMA<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typealiasAssignmentR3C1 [label = <CMB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "}"]<br/>am []<br/>>]
    typealiasAssignmentR2C1 -> typealiasAssignmentR3C1 [weight=100000000]
    typealiasAssignmentR1C1 -> typealiasAssignmentR2C1 [weight=100000000]
    typealiasAssignmentR0C1 -> typealiasAssignmentR1C1 [weight=100000000]
    rank = same {typealiasAssignmentR0C0 -> typealiasAssignmentR0C1}
    node [style = invis]
    edge [style = invis]
    typealiasAssignmentR0C0 -> typealiasAssignmentR1C0 [weight=100000000]
    rank = same {typealiasAssignmentR1C0 -> typealiasAssignmentR1C1}
    typealiasAssignmentR1C0 -> typealiasAssignmentR2C0 [weight=100000000]
    rank = same {typealiasAssignmentR2C0 -> typealiasAssignmentR2C1}
    typealiasAssignmentR2C0 -> typealiasAssignmentR3C0 [weight=100000000]
    rank = same {typealiasAssignmentR3C0 -> typealiasAssignmentR3C1}
  }
  subgraph clusterunionStyleEnumCaseList {
    node [shape = box]
    label = <unionStyleEnumCaseList = unionStyleEnumCase | unionStyleEnumCase "," unionStyleEnumCaseList .>
    labeljust = l
    unionStyleEnumCaseListR0C0 [label = <CVV<br/>N unionStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    unionStyleEnumCaseListR0C1 [label = <CVN<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR1C1 [label = <CVO<br/>N unionStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR2C1 [label = <CVP<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR1C1 -> unionStyleEnumCaseListR2C1 [weight=100000000]
    unionStyleEnumCaseListR0C1 -> unionStyleEnumCaseListR1C1 [weight=100000000]
    unionStyleEnumCaseListR0C2 [label = <CVQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR1C2 [label = <CVR<br/>N unionStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    unionStyleEnumCaseListR2C2 [label = <CVS<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    unionStyleEnumCaseListR3C2 [label = <CVT<br/>N unionStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR4C2 [label = <CVU<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseListR3C2 -> unionStyleEnumCaseListR4C2 [weight=100000000]
    unionStyleEnumCaseListR2C2 -> unionStyleEnumCaseListR3C2 [weight=100000000]
    unionStyleEnumCaseListR1C2 -> unionStyleEnumCaseListR2C2 [weight=100000000]
    unionStyleEnumCaseListR0C2 -> unionStyleEnumCaseListR1C2 [weight=100000000]
    rank = same {unionStyleEnumCaseListR0C1 -> unionStyleEnumCaseListR0C2}
    rank = same {unionStyleEnumCaseListR0C0 -> unionStyleEnumCaseListR0C1}
    node [style = invis]
    edge [style = invis]
    unionStyleEnumCaseListR0C0 -> unionStyleEnumCaseListR1C0 [weight=100000000]
    rank = same {unionStyleEnumCaseListR1C0 -> unionStyleEnumCaseListR1C1}
    unionStyleEnumCaseListR1C0 -> unionStyleEnumCaseListR2C0 [weight=100000000]
    rank = same {unionStyleEnumCaseListR2C0 -> unionStyleEnumCaseListR2C1}
    unionStyleEnumCaseListR2C0 -> unionStyleEnumCaseListR3C0 [weight=100000000]
    unionStyleEnumCaseListR2C1 -> unionStyleEnumCaseListR3C1 [weight=100000000]
    rank = same {unionStyleEnumCaseListR3C0 -> unionStyleEnumCaseListR3C1}
    rank = same {unionStyleEnumCaseListR3C1 -> unionStyleEnumCaseListR3C2}
    unionStyleEnumCaseListR3C0 -> unionStyleEnumCaseListR4C0 [weight=100000000]
    unionStyleEnumCaseListR3C1 -> unionStyleEnumCaseListR4C1 [weight=100000000]
    rank = same {unionStyleEnumCaseListR4C0 -> unionStyleEnumCaseListR4C1}
    rank = same {unionStyleEnumCaseListR4C1 -> unionStyleEnumCaseListR4C2}
  }
  subgraph clustersuperclassSubscriptExpression {
    node [shape = box]
    label = <superclassSubscriptExpression = "super" "[" functionCallArgumentList "]" .>
    labeljust = l
    superclassSubscriptExpressionR0C0 [label = <AAS<br/>N superclassSubscriptExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassSubscriptExpressionR0C1 [label = <AAM<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassSubscriptExpressionR1C1 [label = <AAN<br/>T "super"<br/>fi ["super"]<br/>fo ["["]<br/>am []<br/>>]
    superclassSubscriptExpressionR2C1 [label = <AAO<br/>T "["<br/>fi ["["]<br/>fo ["]", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    superclassSubscriptExpressionR3C1 [label = <AAP<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    superclassSubscriptExpressionR4C1 [label = <AAQ<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassSubscriptExpressionR5C1 [label = <AAR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassSubscriptExpressionR4C1 -> superclassSubscriptExpressionR5C1 [weight=100000000]
    superclassSubscriptExpressionR3C1 -> superclassSubscriptExpressionR4C1 [weight=100000000]
    superclassSubscriptExpressionR2C1 -> superclassSubscriptExpressionR3C1 [weight=100000000]
    superclassSubscriptExpressionR1C1 -> superclassSubscriptExpressionR2C1 [weight=100000000]
    superclassSubscriptExpressionR0C1 -> superclassSubscriptExpressionR1C1 [weight=100000000]
    rank = same {superclassSubscriptExpressionR0C0 -> superclassSubscriptExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    superclassSubscriptExpressionR0C0 -> superclassSubscriptExpressionR1C0 [weight=100000000]
    rank = same {superclassSubscriptExpressionR1C0 -> superclassSubscriptExpressionR1C1}
    superclassSubscriptExpressionR1C0 -> superclassSubscriptExpressionR2C0 [weight=100000000]
    rank = same {superclassSubscriptExpressionR2C0 -> superclassSubscriptExpressionR2C1}
    superclassSubscriptExpressionR2C0 -> superclassSubscriptExpressionR3C0 [weight=100000000]
    rank = same {superclassSubscriptExpressionR3C0 -> superclassSubscriptExpressionR3C1}
    superclassSubscriptExpressionR3C0 -> superclassSubscriptExpressionR4C0 [weight=100000000]
    rank = same {superclassSubscriptExpressionR4C0 -> superclassSubscriptExpressionR4C1}
    superclassSubscriptExpressionR4C0 -> superclassSubscriptExpressionR5C0 [weight=100000000]
    rank = same {superclassSubscriptExpressionR5C0 -> superclassSubscriptExpressionR5C1}
  }
  subgraph clusterforInStatement {
    node [shape = box]
    label = <forInStatement = "for" [ "case" ] pattern "in" expression [ whereClause ] codeBlock .>
    labeljust = l
    forInStatementR0C0 [label = <AYF<br/>N forInStatement<br/>fi ["for"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    forInStatementR0C1 [label = <AXQ<br/>ALT <br/>fi ["for"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    forInStatementR1C1 [label = <AXR<br/>T "for"<br/>fi ["for"]<br/>fo ["(", "_", "case", "escapedIdentifier", "implicitParameterName", "in", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    forInStatementR2C1 [label = <AXV<br/>OPT <br/>fi ["", "case"]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "in", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    forInStatementR3C1 [label = <AXW<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["in"]<br/>am []<br/>>]
    forInStatementR4C1 [label = <AXX<br/>T "in"<br/>fi ["in"]<br/>fo ["try", "where", "{"]<br/>am []<br/>>]
    forInStatementR5C1 [label = <AXY<br/>N expression<br/>fi ["", "try"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    forInStatementR6C1 [label = <AYC<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    forInStatementR7C1 [label = <AYD<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    forInStatementR8C1 [label = <AYE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    forInStatementR7C1 -> forInStatementR8C1 [weight=100000000]
    forInStatementR6C1 -> forInStatementR7C1 [weight=100000000]
    forInStatementR6C2 [label = <AYA<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    forInStatementR7C2 [label = <AXZ<br/>N whereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    forInStatementR8C2 [label = <AYB<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    forInStatementR7C2 -> forInStatementR8C2 [weight=100000000]
    forInStatementR6C2 -> forInStatementR7C2 [weight=100000000]
    rank = same {forInStatementR6C1 -> forInStatementR6C2}
    forInStatementR5C1 -> forInStatementR6C1 [weight=100000000]
    forInStatementR4C1 -> forInStatementR5C1 [weight=100000000]
    forInStatementR3C1 -> forInStatementR4C1 [weight=100000000]
    forInStatementR2C1 -> forInStatementR3C1 [weight=100000000]
    forInStatementR2C3 [label = <AXT<br/>ALT <br/>fi ["case"]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "in", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    forInStatementR3C3 [label = <AXS<br/>T "case"<br/>fi ["case"]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "in", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    forInStatementR4C3 [label = <AXU<br/>END <br/>fi [""]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "in", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    forInStatementR3C3 -> forInStatementR4C3 [weight=100000000]
    forInStatementR2C3 -> forInStatementR3C3 [weight=100000000]
    rank = same {forInStatementR2C1 -> forInStatementR2C3}
    forInStatementR1C1 -> forInStatementR2C1 [weight=100000000]
    forInStatementR0C1 -> forInStatementR1C1 [weight=100000000]
    rank = same {forInStatementR0C0 -> forInStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {forInStatementR0C1 -> forInStatementR0C2}
    rank = same {forInStatementR0C2 -> forInStatementR0C3}
    forInStatementR0C0 -> forInStatementR1C0 [weight=100000000]
    rank = same {forInStatementR1C0 -> forInStatementR1C1}
    forInStatementR0C2 -> forInStatementR1C2 [weight=100000000]
    rank = same {forInStatementR1C1 -> forInStatementR1C2}
    forInStatementR0C3 -> forInStatementR1C3 [weight=100000000]
    rank = same {forInStatementR1C2 -> forInStatementR1C3}
    forInStatementR1C0 -> forInStatementR2C0 [weight=100000000]
    rank = same {forInStatementR2C0 -> forInStatementR2C1}
    forInStatementR1C3 -> forInStatementR2C3 [weight=100000000]
    forInStatementR2C0 -> forInStatementR3C0 [weight=100000000]
    rank = same {forInStatementR3C0 -> forInStatementR3C1}
    rank = same {forInStatementR3C1 -> forInStatementR3C2}
    rank = same {forInStatementR3C2 -> forInStatementR3C3}
    forInStatementR3C0 -> forInStatementR4C0 [weight=100000000]
    rank = same {forInStatementR4C0 -> forInStatementR4C1}
    forInStatementR3C2 -> forInStatementR4C2 [weight=100000000]
    rank = same {forInStatementR4C1 -> forInStatementR4C2}
    rank = same {forInStatementR4C2 -> forInStatementR4C3}
    forInStatementR4C0 -> forInStatementR5C0 [weight=100000000]
    rank = same {forInStatementR5C0 -> forInStatementR5C1}
    forInStatementR4C2 -> forInStatementR5C2 [weight=100000000]
    rank = same {forInStatementR5C1 -> forInStatementR5C2}
    forInStatementR4C3 -> forInStatementR5C3 [weight=100000000]
    rank = same {forInStatementR5C2 -> forInStatementR5C3}
    forInStatementR5C0 -> forInStatementR6C0 [weight=100000000]
    rank = same {forInStatementR6C0 -> forInStatementR6C1}
    forInStatementR5C2 -> forInStatementR6C2 [weight=100000000]
    forInStatementR5C3 -> forInStatementR6C3 [weight=100000000]
    rank = same {forInStatementR6C2 -> forInStatementR6C3}
    forInStatementR6C0 -> forInStatementR7C0 [weight=100000000]
    rank = same {forInStatementR7C0 -> forInStatementR7C1}
    forInStatementR6C3 -> forInStatementR7C3 [weight=100000000]
    rank = same {forInStatementR7C2 -> forInStatementR7C3}
    forInStatementR7C0 -> forInStatementR8C0 [weight=100000000]
    rank = same {forInStatementR8C0 -> forInStatementR8C1}
    forInStatementR7C3 -> forInStatementR8C3 [weight=100000000]
    rank = same {forInStatementR8C2 -> forInStatementR8C3}
  }
  subgraph clusterimplicitMemberExpression {
    node [shape = box]
    label = <implicitMemberExpression = "." identifier | "." identifier "." postfixExpression .>
    labeljust = l
    implicitMemberExpressionR0C0 [label = <AIG<br/>N implicitMemberExpression<br/>fi ["."]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["."]<br/>>]
    implicitMemberExpressionR0C1 [label = <AIC<br/>ALT <br/>fi ["."]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR1C1 [label = <AID<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    implicitMemberExpressionR2C1 [label = <AIE<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR3C1 [label = <AIF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR2C1 -> implicitMemberExpressionR3C1 [weight=100000000]
    implicitMemberExpressionR1C1 -> implicitMemberExpressionR2C1 [weight=100000000]
    implicitMemberExpressionR0C1 -> implicitMemberExpressionR1C1 [weight=100000000]
    implicitMemberExpressionR0C2 [label = <AIH<br/>ALT <br/>fi ["."]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR1C2 [label = <AII<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    implicitMemberExpressionR2C2 [label = <AIJ<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["."]<br/>am []<br/>>]
    implicitMemberExpressionR3C2 [label = <AIK<br/>T "."<br/>fi ["."]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    implicitMemberExpressionR4C2 [label = <AIL<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR5C2 [label = <AIM<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitMemberExpressionR4C2 -> implicitMemberExpressionR5C2 [weight=100000000]
    implicitMemberExpressionR3C2 -> implicitMemberExpressionR4C2 [weight=100000000]
    implicitMemberExpressionR2C2 -> implicitMemberExpressionR3C2 [weight=100000000]
    implicitMemberExpressionR1C2 -> implicitMemberExpressionR2C2 [weight=100000000]
    implicitMemberExpressionR0C2 -> implicitMemberExpressionR1C2 [weight=100000000]
    rank = same {implicitMemberExpressionR0C1 -> implicitMemberExpressionR0C2}
    rank = same {implicitMemberExpressionR0C0 -> implicitMemberExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    implicitMemberExpressionR0C0 -> implicitMemberExpressionR1C0 [weight=100000000]
    rank = same {implicitMemberExpressionR1C0 -> implicitMemberExpressionR1C1}
    implicitMemberExpressionR1C0 -> implicitMemberExpressionR2C0 [weight=100000000]
    rank = same {implicitMemberExpressionR2C0 -> implicitMemberExpressionR2C1}
    implicitMemberExpressionR2C0 -> implicitMemberExpressionR3C0 [weight=100000000]
    rank = same {implicitMemberExpressionR3C0 -> implicitMemberExpressionR3C1}
    implicitMemberExpressionR3C0 -> implicitMemberExpressionR4C0 [weight=100000000]
    implicitMemberExpressionR3C1 -> implicitMemberExpressionR4C1 [weight=100000000]
    rank = same {implicitMemberExpressionR4C0 -> implicitMemberExpressionR4C1}
    rank = same {implicitMemberExpressionR4C1 -> implicitMemberExpressionR4C2}
    implicitMemberExpressionR4C0 -> implicitMemberExpressionR5C0 [weight=100000000]
    implicitMemberExpressionR4C1 -> implicitMemberExpressionR5C1 [weight=100000000]
    rank = same {implicitMemberExpressionR5C0 -> implicitMemberExpressionR5C1}
    rank = same {implicitMemberExpressionR5C1 -> implicitMemberExpressionR5C2}
  }
  subgraph clustervariableDeclarationHead {
    node [shape = box]
    label = <variableDeclarationHead = [ attributes ] [ declarationModifiers ] "var" .>
    labeljust = l
    variableDeclarationHeadR0C0 [label = <CFN<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationHeadR0C1 [label = <CFC<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationHeadR1C1 [label = <CFG<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "var", "weak"]<br/>am []<br/>>]
    variableDeclarationHeadR2C1 [label = <CFK<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["var"]<br/>am []<br/>>]
    variableDeclarationHeadR3C1 [label = <CFL<br/>T "var"<br/>fi ["var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am []<br/>>]
    variableDeclarationHeadR4C1 [label = <CFM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am []<br/>>]
    variableDeclarationHeadR3C1 -> variableDeclarationHeadR4C1 [weight=100000000]
    variableDeclarationHeadR2C1 -> variableDeclarationHeadR3C1 [weight=100000000]
    variableDeclarationHeadR2C2 [label = <CFI<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["var"]<br/>am []<br/>>]
    variableDeclarationHeadR3C2 [label = <CFH<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["var"]<br/>am []<br/>>]
    variableDeclarationHeadR4C2 [label = <CFJ<br/>END <br/>fi [""]<br/>fo ["var"]<br/>am []<br/>>]
    variableDeclarationHeadR3C2 -> variableDeclarationHeadR4C2 [weight=100000000]
    variableDeclarationHeadR2C2 -> variableDeclarationHeadR3C2 [weight=100000000]
    rank = same {variableDeclarationHeadR2C1 -> variableDeclarationHeadR2C2}
    variableDeclarationHeadR1C1 -> variableDeclarationHeadR2C1 [weight=100000000]
    variableDeclarationHeadR1C3 [label = <CFE<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "var", "weak"]<br/>am []<br/>>]
    variableDeclarationHeadR2C3 [label = <CFD<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "var", "weak"]<br/>am []<br/>>]
    variableDeclarationHeadR3C3 [label = <CFF<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "var", "weak"]<br/>am []<br/>>]
    variableDeclarationHeadR2C3 -> variableDeclarationHeadR3C3 [weight=100000000]
    variableDeclarationHeadR1C3 -> variableDeclarationHeadR2C3 [weight=100000000]
    rank = same {variableDeclarationHeadR1C1 -> variableDeclarationHeadR1C3}
    variableDeclarationHeadR0C1 -> variableDeclarationHeadR1C1 [weight=100000000]
    rank = same {variableDeclarationHeadR0C0 -> variableDeclarationHeadR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {variableDeclarationHeadR0C1 -> variableDeclarationHeadR0C2}
    rank = same {variableDeclarationHeadR0C2 -> variableDeclarationHeadR0C3}
    variableDeclarationHeadR0C0 -> variableDeclarationHeadR1C0 [weight=100000000]
    rank = same {variableDeclarationHeadR1C0 -> variableDeclarationHeadR1C1}
    variableDeclarationHeadR0C3 -> variableDeclarationHeadR1C3 [weight=100000000]
    variableDeclarationHeadR1C0 -> variableDeclarationHeadR2C0 [weight=100000000]
    rank = same {variableDeclarationHeadR2C0 -> variableDeclarationHeadR2C1}
    variableDeclarationHeadR2C0 -> variableDeclarationHeadR3C0 [weight=100000000]
    rank = same {variableDeclarationHeadR3C0 -> variableDeclarationHeadR3C1}
    variableDeclarationHeadR3C0 -> variableDeclarationHeadR4C0 [weight=100000000]
    rank = same {variableDeclarationHeadR4C0 -> variableDeclarationHeadR4C1}
    variableDeclarationHeadR3C3 -> variableDeclarationHeadR4C3 [weight=100000000]
    rank = same {variableDeclarationHeadR4C2 -> variableDeclarationHeadR4C3}
  }
  subgraph clusteravailabilityArgument {
    node [shape = box]
    label = <availabilityArgument = platformName platformVersion | "*" .>
    labeljust = l
    availabilityArgumentR0C0 [label = <BWA<br/>N availabilityArgument<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR0C1 [label = <BVW<br/>ALT <br/>fi ["iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR1C1 [label = <BVX<br/>N platformName<br/>fi ["iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    availabilityArgumentR2C1 [label = <BVY<br/>N platformVersion<br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR3C1 [label = <BVZ<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR2C1 -> availabilityArgumentR3C1 [weight=100000000]
    availabilityArgumentR1C1 -> availabilityArgumentR2C1 [weight=100000000]
    availabilityArgumentR0C1 -> availabilityArgumentR1C1 [weight=100000000]
    availabilityArgumentR0C2 [label = <BWB<br/>ALT <br/>fi ["*"]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR1C2 [label = <BWC<br/>T "*"<br/>fi ["*"]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR2C2 [label = <BWD<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    availabilityArgumentR1C2 -> availabilityArgumentR2C2 [weight=100000000]
    availabilityArgumentR0C2 -> availabilityArgumentR1C2 [weight=100000000]
    rank = same {availabilityArgumentR0C1 -> availabilityArgumentR0C2}
    rank = same {availabilityArgumentR0C0 -> availabilityArgumentR0C1}
    node [style = invis]
    edge [style = invis]
    availabilityArgumentR0C0 -> availabilityArgumentR1C0 [weight=100000000]
    rank = same {availabilityArgumentR1C0 -> availabilityArgumentR1C1}
    availabilityArgumentR1C0 -> availabilityArgumentR2C0 [weight=100000000]
    rank = same {availabilityArgumentR2C0 -> availabilityArgumentR2C1}
    availabilityArgumentR2C0 -> availabilityArgumentR3C0 [weight=100000000]
    rank = same {availabilityArgumentR3C0 -> availabilityArgumentR3C1}
    availabilityArgumentR2C2 -> availabilityArgumentR3C2 [weight=100000000]
    rank = same {availabilityArgumentR3C1 -> availabilityArgumentR3C2}
  }
  subgraph clusterrawValueAssignment {
    node [shape = box]
    label = <rawValueAssignment = "=" rawValueLiteral .>
    labeljust = l
    rawValueAssignmentR0C0 [label = <CYZ<br/>N rawValueAssignment<br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueAssignmentR0C1 [label = <CYV<br/>ALT <br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueAssignmentR1C1 [label = <CYW<br/>T "="<br/>fi ["="]<br/>fo ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral", "staticStringLiteral", "true"]<br/>am []<br/>>]
    rawValueAssignmentR2C1 [label = <CYX<br/>N rawValueLiteral<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral", "staticStringLiteral", "true"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueAssignmentR3C1 [label = <CYY<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueAssignmentR2C1 -> rawValueAssignmentR3C1 [weight=100000000]
    rawValueAssignmentR1C1 -> rawValueAssignmentR2C1 [weight=100000000]
    rawValueAssignmentR0C1 -> rawValueAssignmentR1C1 [weight=100000000]
    rank = same {rawValueAssignmentR0C0 -> rawValueAssignmentR0C1}
    node [style = invis]
    edge [style = invis]
    rawValueAssignmentR0C0 -> rawValueAssignmentR1C0 [weight=100000000]
    rank = same {rawValueAssignmentR1C0 -> rawValueAssignmentR1C1}
    rawValueAssignmentR1C0 -> rawValueAssignmentR2C0 [weight=100000000]
    rank = same {rawValueAssignmentR2C0 -> rawValueAssignmentR2C1}
    rawValueAssignmentR2C0 -> rawValueAssignmentR3C0 [weight=100000000]
    rank = same {rawValueAssignmentR3C0 -> rawValueAssignmentR3C1}
  }
  subgraph clusterunionStyleEnumCase {
    node [shape = box]
    label = <unionStyleEnumCase = enumCaseName [ tupleType ] .>
    labeljust = l
    unionStyleEnumCaseR0C0 [label = <CWD<br/>N unionStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR0C1 [label = <CVW<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR1C1 [label = <CVX<br/>N enumCaseName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "(", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR2C1 [label = <CWB<br/>OPT <br/>fi ["", "("]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR3C1 [label = <CWC<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR2C1 -> unionStyleEnumCaseR3C1 [weight=100000000]
    unionStyleEnumCaseR2C2 [label = <CVZ<br/>ALT <br/>fi ["("]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR3C2 [label = <CVY<br/>N tupleType<br/>fi ["("]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR4C2 [label = <CWA<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumCaseR3C2 -> unionStyleEnumCaseR4C2 [weight=100000000]
    unionStyleEnumCaseR2C2 -> unionStyleEnumCaseR3C2 [weight=100000000]
    rank = same {unionStyleEnumCaseR2C1 -> unionStyleEnumCaseR2C2}
    unionStyleEnumCaseR1C1 -> unionStyleEnumCaseR2C1 [weight=100000000]
    unionStyleEnumCaseR0C1 -> unionStyleEnumCaseR1C1 [weight=100000000]
    rank = same {unionStyleEnumCaseR0C0 -> unionStyleEnumCaseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {unionStyleEnumCaseR0C1 -> unionStyleEnumCaseR0C2}
    unionStyleEnumCaseR0C0 -> unionStyleEnumCaseR1C0 [weight=100000000]
    rank = same {unionStyleEnumCaseR1C0 -> unionStyleEnumCaseR1C1}
    unionStyleEnumCaseR0C2 -> unionStyleEnumCaseR1C2 [weight=100000000]
    rank = same {unionStyleEnumCaseR1C1 -> unionStyleEnumCaseR1C2}
    unionStyleEnumCaseR1C0 -> unionStyleEnumCaseR2C0 [weight=100000000]
    rank = same {unionStyleEnumCaseR2C0 -> unionStyleEnumCaseR2C1}
    unionStyleEnumCaseR1C2 -> unionStyleEnumCaseR2C2 [weight=100000000]
    unionStyleEnumCaseR2C0 -> unionStyleEnumCaseR3C0 [weight=100000000]
    rank = same {unionStyleEnumCaseR3C0 -> unionStyleEnumCaseR3C1}
    unionStyleEnumCaseR3C0 -> unionStyleEnumCaseR4C0 [weight=100000000]
    unionStyleEnumCaseR3C1 -> unionStyleEnumCaseR4C1 [weight=100000000]
    rank = same {unionStyleEnumCaseR4C0 -> unionStyleEnumCaseR4C1}
    rank = same {unionStyleEnumCaseR4C1 -> unionStyleEnumCaseR4C2}
  }
  subgraph clusteranyType {
    node [shape = box]
    label = <anyType = "Any" .>
    labeljust = l
    anyTypeR0C0 [label = <NF<br/>N anyType<br/>fi ["Any"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    anyTypeR0C1 [label = <NC<br/>ALT <br/>fi ["Any"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    anyTypeR1C1 [label = <ND<br/>T "Any"<br/>fi ["Any"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    anyTypeR2C1 [label = <NE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    anyTypeR1C1 -> anyTypeR2C1 [weight=100000000]
    anyTypeR0C1 -> anyTypeR1C1 [weight=100000000]
    rank = same {anyTypeR0C0 -> anyTypeR0C1}
    node [style = invis]
    edge [style = invis]
    anyTypeR0C0 -> anyTypeR1C0 [weight=100000000]
    rank = same {anyTypeR1C0 -> anyTypeR1C1}
    anyTypeR1C0 -> anyTypeR2C0 [weight=100000000]
    rank = same {anyTypeR2C0 -> anyTypeR2C1}
  }
  subgraph clustercaseLabel {
    node [shape = box]
    label = <caseLabel = [ attributes ] "case" caseItemList ":" .>
    labeljust = l
    caseLabelR0C0 [label = <BDK<br/>N caseLabel<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    caseLabelR0C1 [label = <BDB<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    caseLabelR1C1 [label = <BDF<br/>OPT <br/>fi ["", "@"]<br/>fo ["case"]<br/>am []<br/>>]
    caseLabelR2C1 [label = <BDG<br/>T "case"<br/>fi ["case"]<br/>fo ["(", ":", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    caseLabelR3C1 [label = <BDH<br/>N caseItemList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":"]<br/>am []<br/>>]
    caseLabelR4C1 [label = <BDI<br/>T ":"<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    caseLabelR5C1 [label = <BDJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    caseLabelR4C1 -> caseLabelR5C1 [weight=100000000]
    caseLabelR3C1 -> caseLabelR4C1 [weight=100000000]
    caseLabelR2C1 -> caseLabelR3C1 [weight=100000000]
    caseLabelR1C1 -> caseLabelR2C1 [weight=100000000]
    caseLabelR1C2 [label = <BDD<br/>ALT <br/>fi ["@"]<br/>fo ["case"]<br/>am []<br/>>]
    caseLabelR2C2 [label = <BDC<br/>N attributes<br/>fi ["@"]<br/>fo ["case"]<br/>am []<br/>>]
    caseLabelR3C2 [label = <BDE<br/>END <br/>fi [""]<br/>fo ["case"]<br/>am []<br/>>]
    caseLabelR2C2 -> caseLabelR3C2 [weight=100000000]
    caseLabelR1C2 -> caseLabelR2C2 [weight=100000000]
    rank = same {caseLabelR1C1 -> caseLabelR1C2}
    caseLabelR0C1 -> caseLabelR1C1 [weight=100000000]
    rank = same {caseLabelR0C0 -> caseLabelR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {caseLabelR0C1 -> caseLabelR0C2}
    caseLabelR0C0 -> caseLabelR1C0 [weight=100000000]
    rank = same {caseLabelR1C0 -> caseLabelR1C1}
    caseLabelR0C2 -> caseLabelR1C2 [weight=100000000]
    caseLabelR1C0 -> caseLabelR2C0 [weight=100000000]
    rank = same {caseLabelR2C0 -> caseLabelR2C1}
    caseLabelR2C0 -> caseLabelR3C0 [weight=100000000]
    rank = same {caseLabelR3C0 -> caseLabelR3C1}
    caseLabelR3C0 -> caseLabelR4C0 [weight=100000000]
    rank = same {caseLabelR4C0 -> caseLabelR4C1}
    caseLabelR3C2 -> caseLabelR4C2 [weight=100000000]
    rank = same {caseLabelR4C1 -> caseLabelR4C2}
    caseLabelR4C0 -> caseLabelR5C0 [weight=100000000]
    rank = same {caseLabelR5C0 -> caseLabelR5C1}
    caseLabelR4C2 -> caseLabelR5C2 [weight=100000000]
    rank = same {caseLabelR5C1 -> caseLabelR5C2}
  }
  subgraph clusterunionStyleEnumMember {
    node [shape = box]
    label = <unionStyleEnumMember = declaration | unionStyleEnumCaseClause | compilerControlStatement .>
    labeljust = l
    unionStyleEnumMemberR0C0 [label = <CUZ<br/>N unionStyleEnumMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    unionStyleEnumMemberR0C1 [label = <CUQ<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    unionStyleEnumMemberR1C1 [label = <CUR<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    unionStyleEnumMemberR2C1 [label = <CUS<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumMemberR1C1 -> unionStyleEnumMemberR2C1 [weight=100000000]
    unionStyleEnumMemberR0C1 -> unionStyleEnumMemberR1C1 [weight=100000000]
    unionStyleEnumMemberR0C2 [label = <CUT<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    unionStyleEnumMemberR1C2 [label = <CUU<br/>N unionStyleEnumCaseClause<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    unionStyleEnumMemberR2C2 [label = <CUV<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumMemberR1C2 -> unionStyleEnumMemberR2C2 [weight=100000000]
    unionStyleEnumMemberR0C2 -> unionStyleEnumMemberR1C2 [weight=100000000]
    unionStyleEnumMemberR0C3 [label = <CUW<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumMemberR1C3 [label = <CUX<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumMemberR2C3 [label = <CUY<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumMemberR1C3 -> unionStyleEnumMemberR2C3 [weight=100000000]
    unionStyleEnumMemberR0C3 -> unionStyleEnumMemberR1C3 [weight=100000000]
    rank = same {unionStyleEnumMemberR0C2 -> unionStyleEnumMemberR0C3}
    rank = same {unionStyleEnumMemberR0C1 -> unionStyleEnumMemberR0C2}
    rank = same {unionStyleEnumMemberR0C0 -> unionStyleEnumMemberR0C1}
    node [style = invis]
    edge [style = invis]
    unionStyleEnumMemberR0C0 -> unionStyleEnumMemberR1C0 [weight=100000000]
    rank = same {unionStyleEnumMemberR1C0 -> unionStyleEnumMemberR1C1}
    unionStyleEnumMemberR1C0 -> unionStyleEnumMemberR2C0 [weight=100000000]
    rank = same {unionStyleEnumMemberR2C0 -> unionStyleEnumMemberR2C1}
  }
  subgraph clusterinfixOperatorGroup {
    node [shape = box]
    label = <infixOperatorGroup = ":" precedenceGroupName .>
    labeljust = l
    infixOperatorGroupR0C0 [label = <DXD<br/>N infixOperatorGroup<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorGroupR0C1 [label = <DWZ<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorGroupR1C1 [label = <DXA<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    infixOperatorGroupR2C1 [label = <DXB<br/>N precedenceGroupName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorGroupR3C1 [label = <DXC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorGroupR2C1 -> infixOperatorGroupR3C1 [weight=100000000]
    infixOperatorGroupR1C1 -> infixOperatorGroupR2C1 [weight=100000000]
    infixOperatorGroupR0C1 -> infixOperatorGroupR1C1 [weight=100000000]
    rank = same {infixOperatorGroupR0C0 -> infixOperatorGroupR0C1}
    node [style = invis]
    edge [style = invis]
    infixOperatorGroupR0C0 -> infixOperatorGroupR1C0 [weight=100000000]
    rank = same {infixOperatorGroupR1C0 -> infixOperatorGroupR1C1}
    infixOperatorGroupR1C0 -> infixOperatorGroupR2C0 [weight=100000000]
    rank = same {infixOperatorGroupR2C0 -> infixOperatorGroupR2C1}
    infixOperatorGroupR2C0 -> infixOperatorGroupR3C0 [weight=100000000]
    rank = same {infixOperatorGroupR3C0 -> infixOperatorGroupR3C1}
  }
  subgraph clusterwildcardPattern {
    node [shape = box]
    label = <wildcardPattern = "_" .>
    labeljust = l
    wildcardPatternR0C0 [label = <EKJ<br/>N wildcardPattern<br/>fi ["_"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardPatternR0C1 [label = <EKG<br/>ALT <br/>fi ["_"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardPatternR1C1 [label = <EKH<br/>T "_"<br/>fi ["_"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardPatternR2C1 [label = <EKI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardPatternR1C1 -> wildcardPatternR2C1 [weight=100000000]
    wildcardPatternR0C1 -> wildcardPatternR1C1 [weight=100000000]
    rank = same {wildcardPatternR0C0 -> wildcardPatternR0C1}
    node [style = invis]
    edge [style = invis]
    wildcardPatternR0C0 -> wildcardPatternR1C0 [weight=100000000]
    rank = same {wildcardPatternR1C0 -> wildcardPatternR1C1}
    wildcardPatternR1C0 -> wildcardPatternR2C0 [weight=100000000]
    rank = same {wildcardPatternR2C0 -> wildcardPatternR2C1}
  }
  subgraph clusterboxedProtocolType {
    node [shape = box]
    label = <boxedProtocolType = "any" type .>
    labeljust = l
    boxedProtocolTypeR0C0 [label = <MQ<br/>N boxedProtocolType<br/>fi ["any"]<br/>fo []<br/>am []<br/>>]
    boxedProtocolTypeR0C1 [label = <MM<br/>ALT <br/>fi ["any"]<br/>fo []<br/>am []<br/>>]
    boxedProtocolTypeR1C1 [label = <MN<br/>T "any"<br/>fi ["any"]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    boxedProtocolTypeR2C1 [label = <MO<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo []<br/>am []<br/>>]
    boxedProtocolTypeR3C1 [label = <MP<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    boxedProtocolTypeR2C1 -> boxedProtocolTypeR3C1 [weight=100000000]
    boxedProtocolTypeR1C1 -> boxedProtocolTypeR2C1 [weight=100000000]
    boxedProtocolTypeR0C1 -> boxedProtocolTypeR1C1 [weight=100000000]
    rank = same {boxedProtocolTypeR0C0 -> boxedProtocolTypeR0C1}
    node [style = invis]
    edge [style = invis]
    boxedProtocolTypeR0C0 -> boxedProtocolTypeR1C0 [weight=100000000]
    rank = same {boxedProtocolTypeR1C0 -> boxedProtocolTypeR1C1}
    boxedProtocolTypeR1C0 -> boxedProtocolTypeR2C0 [weight=100000000]
    rank = same {boxedProtocolTypeR2C0 -> boxedProtocolTypeR2C1}
    boxedProtocolTypeR2C0 -> boxedProtocolTypeR3C0 [weight=100000000]
    rank = same {boxedProtocolTypeR3C0 -> boxedProtocolTypeR3C1}
  }
  subgraph clusterimplicitlyUnwrappedOptionalType {
    node [shape = box]
    label = <implicitlyUnwrappedOptionalType = type "!" .>
    labeljust = l
    implicitlyUnwrappedOptionalTypeR0C0 [label = <LT<br/>N implicitlyUnwrappedOptionalType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    implicitlyUnwrappedOptionalTypeR0C1 [label = <LP<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    implicitlyUnwrappedOptionalTypeR1C1 [label = <LQ<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!"]<br/>am []<br/>>]
    implicitlyUnwrappedOptionalTypeR2C1 [label = <LR<br/>T "!"<br/>fi ["!"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitlyUnwrappedOptionalTypeR3C1 [label = <LS<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    implicitlyUnwrappedOptionalTypeR2C1 -> implicitlyUnwrappedOptionalTypeR3C1 [weight=100000000]
    implicitlyUnwrappedOptionalTypeR1C1 -> implicitlyUnwrappedOptionalTypeR2C1 [weight=100000000]
    implicitlyUnwrappedOptionalTypeR0C1 -> implicitlyUnwrappedOptionalTypeR1C1 [weight=100000000]
    rank = same {implicitlyUnwrappedOptionalTypeR0C0 -> implicitlyUnwrappedOptionalTypeR0C1}
    node [style = invis]
    edge [style = invis]
    implicitlyUnwrappedOptionalTypeR0C0 -> implicitlyUnwrappedOptionalTypeR1C0 [weight=100000000]
    rank = same {implicitlyUnwrappedOptionalTypeR1C0 -> implicitlyUnwrappedOptionalTypeR1C1}
    implicitlyUnwrappedOptionalTypeR1C0 -> implicitlyUnwrappedOptionalTypeR2C0 [weight=100000000]
    rank = same {implicitlyUnwrappedOptionalTypeR2C0 -> implicitlyUnwrappedOptionalTypeR2C1}
    implicitlyUnwrappedOptionalTypeR2C0 -> implicitlyUnwrappedOptionalTypeR3C0 [weight=100000000]
    rank = same {implicitlyUnwrappedOptionalTypeR3C0 -> implicitlyUnwrappedOptionalTypeR3C1}
  }
  subgraph clustertupleElement {
    node [shape = box]
    label = <tupleElement = expression | identifier ":" expression .>
    labeljust = l
    tupleElementR0C0 [label = <AJW<br/>N tupleElement<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR0C1 [label = <AJO<br/>ALT <br/>fi ["", "try"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR1C1 [label = <AJP<br/>N expression<br/>fi ["", "try"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR2C1 [label = <AJQ<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR1C1 -> tupleElementR2C1 [weight=100000000]
    tupleElementR0C1 -> tupleElementR1C1 [weight=100000000]
    tupleElementR0C2 [label = <AJR<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR1C2 [label = <AJS<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    tupleElementR2C2 [label = <AJT<br/>T ":"<br/>fi [":"]<br/>fo [")", ",", "try"]<br/>am []<br/>>]
    tupleElementR3C2 [label = <AJU<br/>N expression<br/>fi ["", "try"]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR4C2 [label = <AJV<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    tupleElementR3C2 -> tupleElementR4C2 [weight=100000000]
    tupleElementR2C2 -> tupleElementR3C2 [weight=100000000]
    tupleElementR1C2 -> tupleElementR2C2 [weight=100000000]
    tupleElementR0C2 -> tupleElementR1C2 [weight=100000000]
    rank = same {tupleElementR0C1 -> tupleElementR0C2}
    rank = same {tupleElementR0C0 -> tupleElementR0C1}
    node [style = invis]
    edge [style = invis]
    tupleElementR0C0 -> tupleElementR1C0 [weight=100000000]
    rank = same {tupleElementR1C0 -> tupleElementR1C1}
    tupleElementR1C0 -> tupleElementR2C0 [weight=100000000]
    rank = same {tupleElementR2C0 -> tupleElementR2C1}
    tupleElementR2C0 -> tupleElementR3C0 [weight=100000000]
    tupleElementR2C1 -> tupleElementR3C1 [weight=100000000]
    rank = same {tupleElementR3C0 -> tupleElementR3C1}
    rank = same {tupleElementR3C1 -> tupleElementR3C2}
    tupleElementR3C0 -> tupleElementR4C0 [weight=100000000]
    tupleElementR3C1 -> tupleElementR4C1 [weight=100000000]
    rank = same {tupleElementR4C0 -> tupleElementR4C1}
    rank = same {tupleElementR4C1 -> tupleElementR4C2}
  }
  subgraph clustertopLevelDeclaration {
    node [shape = box]
    label = <topLevelDeclaration = [ statements ] .>
    labeljust = l
    topLevelDeclarationR0C0 [label = <G<br/>N topLevelDeclaration<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR0C1 [label = <A<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR1C1 [label = <E<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR2C1 [label = <F<br/>END <br/>fi [""]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR1C1 -> topLevelDeclarationR2C1 [weight=100000000]
    topLevelDeclarationR1C2 [label = <C<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR2C2 [label = <B<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR3C2 [label = <D<br/>END <br/>fi [""]<br/>fo ["$"]<br/>am []<br/>>]
    topLevelDeclarationR2C2 -> topLevelDeclarationR3C2 [weight=100000000]
    topLevelDeclarationR1C2 -> topLevelDeclarationR2C2 [weight=100000000]
    rank = same {topLevelDeclarationR1C1 -> topLevelDeclarationR1C2}
    topLevelDeclarationR0C1 -> topLevelDeclarationR1C1 [weight=100000000]
    rank = same {topLevelDeclarationR0C0 -> topLevelDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {topLevelDeclarationR0C1 -> topLevelDeclarationR0C2}
    topLevelDeclarationR0C0 -> topLevelDeclarationR1C0 [weight=100000000]
    rank = same {topLevelDeclarationR1C0 -> topLevelDeclarationR1C1}
    topLevelDeclarationR0C2 -> topLevelDeclarationR1C2 [weight=100000000]
    topLevelDeclarationR1C0 -> topLevelDeclarationR2C0 [weight=100000000]
    rank = same {topLevelDeclarationR2C0 -> topLevelDeclarationR2C1}
    topLevelDeclarationR2C0 -> topLevelDeclarationR3C0 [weight=100000000]
    topLevelDeclarationR2C1 -> topLevelDeclarationR3C1 [weight=100000000]
    rank = same {topLevelDeclarationR3C0 -> topLevelDeclarationR3C1}
    rank = same {topLevelDeclarationR3C1 -> topLevelDeclarationR3C2}
  }
  subgraph clusterplatformCondition {
    node [shape = box]
    label = <platformCondition = "os" "(" operatingSystem ")" | "arch" "(" architecture ")" | "swift" "(" "&gt;=" swiftVersion ")" | "swift" "(" "&lt;" swiftVersion ")" | "compiler" "(" "&gt;=" swiftVersion ")" | "compiler" "(" "&lt;" swiftVersion ")" | "canImport" "(" importPath ")" | "targetEnvironment" "(" environment ")" .>
    labeljust = l
    platformConditionR0C0 [label = <BPQ<br/>N platformCondition<br/>fi ["arch", "canImport", "compiler", "os", "swift", "targetEnvironment"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am ["compiler", "swift"]<br/>>]
    platformConditionR0C1 [label = <BPK<br/>ALT <br/>fi ["os"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C1 [label = <BPL<br/>T "os"<br/>fi ["os"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C1 [label = <BPM<br/>T "("<br/>fi ["("]<br/>fo ["Linux", "Windows", "iOS", "macOS", "tvOS", "visionOS", "watchOS"]<br/>am []<br/>>]
    platformConditionR3C1 [label = <BPN<br/>N operatingSystem<br/>fi ["Linux", "Windows", "iOS", "macOS", "tvOS", "visionOS", "watchOS"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR4C1 [label = <BPO<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C1 [label = <BPP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR4C1 -> platformConditionR5C1 [weight=100000000]
    platformConditionR3C1 -> platformConditionR4C1 [weight=100000000]
    platformConditionR2C1 -> platformConditionR3C1 [weight=100000000]
    platformConditionR1C1 -> platformConditionR2C1 [weight=100000000]
    platformConditionR0C1 -> platformConditionR1C1 [weight=100000000]
    platformConditionR0C2 [label = <BPR<br/>ALT <br/>fi ["arch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C2 [label = <BPS<br/>T "arch"<br/>fi ["arch"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C2 [label = <BPT<br/>T "("<br/>fi ["("]<br/>fo ["arm", "arm64", "i386", "x86_64"]<br/>am []<br/>>]
    platformConditionR3C2 [label = <BPU<br/>N architecture<br/>fi ["arm", "arm64", "i386", "x86_64"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR4C2 [label = <BPV<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C2 [label = <BPW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR4C2 -> platformConditionR5C2 [weight=100000000]
    platformConditionR3C2 -> platformConditionR4C2 [weight=100000000]
    platformConditionR2C2 -> platformConditionR3C2 [weight=100000000]
    platformConditionR1C2 -> platformConditionR2C2 [weight=100000000]
    platformConditionR0C2 -> platformConditionR1C2 [weight=100000000]
    platformConditionR0C3 [label = <BPX<br/>ALT <br/>fi ["swift"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C3 [label = <BPY<br/>T "swift"<br/>fi ["swift"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C3 [label = <BPZ<br/>T "("<br/>fi ["("]<br/>fo ["&gt;="]<br/>am []<br/>>]
    platformConditionR3C3 [label = <BQA<br/>T "&gt;="<br/>fi ["&gt;="]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformConditionR4C3 [label = <BQB<br/>N swiftVersion<br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR5C3 [label = <BQC<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR6C3 [label = <BQD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C3 -> platformConditionR6C3 [weight=100000000]
    platformConditionR4C3 -> platformConditionR5C3 [weight=100000000]
    platformConditionR3C3 -> platformConditionR4C3 [weight=100000000]
    platformConditionR2C3 -> platformConditionR3C3 [weight=100000000]
    platformConditionR1C3 -> platformConditionR2C3 [weight=100000000]
    platformConditionR0C3 -> platformConditionR1C3 [weight=100000000]
    platformConditionR0C4 [label = <BQE<br/>ALT <br/>fi ["swift"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C4 [label = <BQF<br/>T "swift"<br/>fi ["swift"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C4 [label = <BQG<br/>T "("<br/>fi ["("]<br/>fo ["&lt;"]<br/>am []<br/>>]
    platformConditionR3C4 [label = <BQH<br/>T "&lt;"<br/>fi ["&lt;"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformConditionR4C4 [label = <BQI<br/>N swiftVersion<br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR5C4 [label = <BQJ<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR6C4 [label = <BQK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C4 -> platformConditionR6C4 [weight=100000000]
    platformConditionR4C4 -> platformConditionR5C4 [weight=100000000]
    platformConditionR3C4 -> platformConditionR4C4 [weight=100000000]
    platformConditionR2C4 -> platformConditionR3C4 [weight=100000000]
    platformConditionR1C4 -> platformConditionR2C4 [weight=100000000]
    platformConditionR0C4 -> platformConditionR1C4 [weight=100000000]
    platformConditionR0C5 [label = <BQL<br/>ALT <br/>fi ["compiler"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C5 [label = <BQM<br/>T "compiler"<br/>fi ["compiler"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C5 [label = <BQN<br/>T "("<br/>fi ["("]<br/>fo ["&gt;="]<br/>am []<br/>>]
    platformConditionR3C5 [label = <BQO<br/>T "&gt;="<br/>fi ["&gt;="]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformConditionR4C5 [label = <BQP<br/>N swiftVersion<br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR5C5 [label = <BQQ<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR6C5 [label = <BQR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C5 -> platformConditionR6C5 [weight=100000000]
    platformConditionR4C5 -> platformConditionR5C5 [weight=100000000]
    platformConditionR3C5 -> platformConditionR4C5 [weight=100000000]
    platformConditionR2C5 -> platformConditionR3C5 [weight=100000000]
    platformConditionR1C5 -> platformConditionR2C5 [weight=100000000]
    platformConditionR0C5 -> platformConditionR1C5 [weight=100000000]
    platformConditionR0C6 [label = <BQS<br/>ALT <br/>fi ["compiler"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C6 [label = <BQT<br/>T "compiler"<br/>fi ["compiler"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C6 [label = <BQU<br/>T "("<br/>fi ["("]<br/>fo ["&lt;"]<br/>am []<br/>>]
    platformConditionR3C6 [label = <BQV<br/>T "&lt;"<br/>fi ["&lt;"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformConditionR4C6 [label = <BQW<br/>N swiftVersion<br/>fi ["decimalDigits"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR5C6 [label = <BQX<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR6C6 [label = <BQY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C6 -> platformConditionR6C6 [weight=100000000]
    platformConditionR4C6 -> platformConditionR5C6 [weight=100000000]
    platformConditionR3C6 -> platformConditionR4C6 [weight=100000000]
    platformConditionR2C6 -> platformConditionR3C6 [weight=100000000]
    platformConditionR1C6 -> platformConditionR2C6 [weight=100000000]
    platformConditionR0C6 -> platformConditionR1C6 [weight=100000000]
    platformConditionR0C7 [label = <BQZ<br/>ALT <br/>fi ["canImport"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C7 [label = <BRA<br/>T "canImport"<br/>fi ["canImport"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C7 [label = <BRB<br/>T "("<br/>fi ["("]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    platformConditionR3C7 [label = <BRC<br/>N importPath<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR4C7 [label = <BRD<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C7 [label = <BRE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR4C7 -> platformConditionR5C7 [weight=100000000]
    platformConditionR3C7 -> platformConditionR4C7 [weight=100000000]
    platformConditionR2C7 -> platformConditionR3C7 [weight=100000000]
    platformConditionR1C7 -> platformConditionR2C7 [weight=100000000]
    platformConditionR0C7 -> platformConditionR1C7 [weight=100000000]
    platformConditionR0C8 [label = <BRF<br/>ALT <br/>fi ["targetEnvironment"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR1C8 [label = <BRG<br/>T "targetEnvironment"<br/>fi ["targetEnvironment"]<br/>fo ["("]<br/>am []<br/>>]
    platformConditionR2C8 [label = <BRH<br/>T "("<br/>fi ["("]<br/>fo ["macCatalyst", "simulator"]<br/>am []<br/>>]
    platformConditionR3C8 [label = <BRI<br/>N environment<br/>fi ["macCatalyst", "simulator"]<br/>fo [")"]<br/>am []<br/>>]
    platformConditionR4C8 [label = <BRJ<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR5C8 [label = <BRK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    platformConditionR4C8 -> platformConditionR5C8 [weight=100000000]
    platformConditionR3C8 -> platformConditionR4C8 [weight=100000000]
    platformConditionR2C8 -> platformConditionR3C8 [weight=100000000]
    platformConditionR1C8 -> platformConditionR2C8 [weight=100000000]
    platformConditionR0C8 -> platformConditionR1C8 [weight=100000000]
    rank = same {platformConditionR0C7 -> platformConditionR0C8}
    rank = same {platformConditionR0C6 -> platformConditionR0C7}
    rank = same {platformConditionR0C5 -> platformConditionR0C6}
    rank = same {platformConditionR0C4 -> platformConditionR0C5}
    rank = same {platformConditionR0C3 -> platformConditionR0C4}
    rank = same {platformConditionR0C2 -> platformConditionR0C3}
    rank = same {platformConditionR0C1 -> platformConditionR0C2}
    rank = same {platformConditionR0C0 -> platformConditionR0C1}
    node [style = invis]
    edge [style = invis]
    platformConditionR0C0 -> platformConditionR1C0 [weight=100000000]
    rank = same {platformConditionR1C0 -> platformConditionR1C1}
    platformConditionR1C0 -> platformConditionR2C0 [weight=100000000]
    rank = same {platformConditionR2C0 -> platformConditionR2C1}
    platformConditionR2C0 -> platformConditionR3C0 [weight=100000000]
    rank = same {platformConditionR3C0 -> platformConditionR3C1}
    platformConditionR3C0 -> platformConditionR4C0 [weight=100000000]
    rank = same {platformConditionR4C0 -> platformConditionR4C1}
    platformConditionR4C0 -> platformConditionR5C0 [weight=100000000]
    rank = same {platformConditionR5C0 -> platformConditionR5C1}
    platformConditionR5C0 -> platformConditionR6C0 [weight=100000000]
    platformConditionR5C1 -> platformConditionR6C1 [weight=100000000]
    rank = same {platformConditionR6C0 -> platformConditionR6C1}
    platformConditionR5C2 -> platformConditionR6C2 [weight=100000000]
    rank = same {platformConditionR6C1 -> platformConditionR6C2}
    rank = same {platformConditionR6C2 -> platformConditionR6C3}
    platformConditionR5C7 -> platformConditionR6C7 [weight=100000000]
    rank = same {platformConditionR6C6 -> platformConditionR6C7}
    platformConditionR5C8 -> platformConditionR6C8 [weight=100000000]
    rank = same {platformConditionR6C7 -> platformConditionR6C8}
  }
  subgraph clustersuperclassInitializerExpression {
    node [shape = box]
    label = <superclassInitializerExpression = "super" "." "init" .>
    labeljust = l
    superclassInitializerExpressionR0C0 [label = <AAY<br/>N superclassInitializerExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassInitializerExpressionR0C1 [label = <AAT<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassInitializerExpressionR1C1 [label = <AAU<br/>T "super"<br/>fi ["super"]<br/>fo ["."]<br/>am []<br/>>]
    superclassInitializerExpressionR2C1 [label = <AAV<br/>T "."<br/>fi ["."]<br/>fo ["init"]<br/>am []<br/>>]
    superclassInitializerExpressionR3C1 [label = <AAW<br/>T "init"<br/>fi ["init"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassInitializerExpressionR4C1 [label = <AAX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassInitializerExpressionR3C1 -> superclassInitializerExpressionR4C1 [weight=100000000]
    superclassInitializerExpressionR2C1 -> superclassInitializerExpressionR3C1 [weight=100000000]
    superclassInitializerExpressionR1C1 -> superclassInitializerExpressionR2C1 [weight=100000000]
    superclassInitializerExpressionR0C1 -> superclassInitializerExpressionR1C1 [weight=100000000]
    rank = same {superclassInitializerExpressionR0C0 -> superclassInitializerExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    superclassInitializerExpressionR0C0 -> superclassInitializerExpressionR1C0 [weight=100000000]
    rank = same {superclassInitializerExpressionR1C0 -> superclassInitializerExpressionR1C1}
    superclassInitializerExpressionR1C0 -> superclassInitializerExpressionR2C0 [weight=100000000]
    rank = same {superclassInitializerExpressionR2C0 -> superclassInitializerExpressionR2C1}
    superclassInitializerExpressionR2C0 -> superclassInitializerExpressionR3C0 [weight=100000000]
    rank = same {superclassInitializerExpressionR3C0 -> superclassInitializerExpressionR3C1}
    superclassInitializerExpressionR3C0 -> superclassInitializerExpressionR4C0 [weight=100000000]
    rank = same {superclassInitializerExpressionR4C0 -> superclassInitializerExpressionR4C1}
  }
  subgraph clusterswitchIfDirectiveClause {
    node [shape = box]
    label = <switchIfDirectiveClause = ifDirective compilationCondition [ switchCases ] .>
    labeljust = l
    switchIfDirectiveClauseR0C0 [label = <BFP<br/>N switchIfDirectiveClause<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR0C1 [label = <BFH<br/>ALT <br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR1C1 [label = <BFI<br/>N ifDirective<br/>fi ["#if"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    switchIfDirectiveClauseR2C1 [label = <BFJ<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@"]<br/>am []<br/>>]
    switchIfDirectiveClauseR3C1 [label = <BFN<br/>OPT <br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR4C1 [label = <BFO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR3C1 -> switchIfDirectiveClauseR4C1 [weight=100000000]
    switchIfDirectiveClauseR3C2 [label = <BFL<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR4C2 [label = <BFK<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR5C2 [label = <BFM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchIfDirectiveClauseR4C2 -> switchIfDirectiveClauseR5C2 [weight=100000000]
    switchIfDirectiveClauseR3C2 -> switchIfDirectiveClauseR4C2 [weight=100000000]
    rank = same {switchIfDirectiveClauseR3C1 -> switchIfDirectiveClauseR3C2}
    switchIfDirectiveClauseR2C1 -> switchIfDirectiveClauseR3C1 [weight=100000000]
    switchIfDirectiveClauseR1C1 -> switchIfDirectiveClauseR2C1 [weight=100000000]
    switchIfDirectiveClauseR0C1 -> switchIfDirectiveClauseR1C1 [weight=100000000]
    rank = same {switchIfDirectiveClauseR0C0 -> switchIfDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchIfDirectiveClauseR0C1 -> switchIfDirectiveClauseR0C2}
    switchIfDirectiveClauseR0C0 -> switchIfDirectiveClauseR1C0 [weight=100000000]
    rank = same {switchIfDirectiveClauseR1C0 -> switchIfDirectiveClauseR1C1}
    switchIfDirectiveClauseR0C2 -> switchIfDirectiveClauseR1C2 [weight=100000000]
    rank = same {switchIfDirectiveClauseR1C1 -> switchIfDirectiveClauseR1C2}
    switchIfDirectiveClauseR1C0 -> switchIfDirectiveClauseR2C0 [weight=100000000]
    rank = same {switchIfDirectiveClauseR2C0 -> switchIfDirectiveClauseR2C1}
    switchIfDirectiveClauseR1C2 -> switchIfDirectiveClauseR2C2 [weight=100000000]
    rank = same {switchIfDirectiveClauseR2C1 -> switchIfDirectiveClauseR2C2}
    switchIfDirectiveClauseR2C0 -> switchIfDirectiveClauseR3C0 [weight=100000000]
    rank = same {switchIfDirectiveClauseR3C0 -> switchIfDirectiveClauseR3C1}
    switchIfDirectiveClauseR2C2 -> switchIfDirectiveClauseR3C2 [weight=100000000]
    switchIfDirectiveClauseR3C0 -> switchIfDirectiveClauseR4C0 [weight=100000000]
    rank = same {switchIfDirectiveClauseR4C0 -> switchIfDirectiveClauseR4C1}
    switchIfDirectiveClauseR4C0 -> switchIfDirectiveClauseR5C0 [weight=100000000]
    switchIfDirectiveClauseR4C1 -> switchIfDirectiveClauseR5C1 [weight=100000000]
    rank = same {switchIfDirectiveClauseR5C0 -> switchIfDirectiveClauseR5C1}
    rank = same {switchIfDirectiveClauseR5C1 -> switchIfDirectiveClauseR5C2}
  }
  subgraph clusterdoStatement {
    node [shape = box]
    label = <doStatement = "do" [ throwsClause ] codeBlock [ catchClauses ] .>
    labeljust = l
    doStatementR0C0 [label = <BKD<br/>N doStatement<br/>fi ["do"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR0C1 [label = <BJR<br/>ALT <br/>fi ["do"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR1C1 [label = <BJS<br/>T "do"<br/>fi ["do"]<br/>fo ["throws", "{"]<br/>am []<br/>>]
    doStatementR2C1 [label = <BJW<br/>OPT <br/>fi ["", "throws"]<br/>fo ["{"]<br/>am []<br/>>]
    doStatementR3C1 [label = <BJX<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR4C1 [label = <BKB<br/>OPT <br/>fi ["", "catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR5C1 [label = <BKC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR4C1 -> doStatementR5C1 [weight=100000000]
    doStatementR4C2 [label = <BJZ<br/>ALT <br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR5C2 [label = <BJY<br/>N catchClauses<br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR6C2 [label = <BKA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    doStatementR5C2 -> doStatementR6C2 [weight=100000000]
    doStatementR4C2 -> doStatementR5C2 [weight=100000000]
    rank = same {doStatementR4C1 -> doStatementR4C2}
    doStatementR3C1 -> doStatementR4C1 [weight=100000000]
    doStatementR2C1 -> doStatementR3C1 [weight=100000000]
    doStatementR2C3 [label = <BJU<br/>ALT <br/>fi ["throws"]<br/>fo ["{"]<br/>am []<br/>>]
    doStatementR3C3 [label = <BJT<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["{"]<br/>am []<br/>>]
    doStatementR4C3 [label = <BJV<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    doStatementR3C3 -> doStatementR4C3 [weight=100000000]
    doStatementR2C3 -> doStatementR3C3 [weight=100000000]
    rank = same {doStatementR2C1 -> doStatementR2C3}
    doStatementR1C1 -> doStatementR2C1 [weight=100000000]
    doStatementR0C1 -> doStatementR1C1 [weight=100000000]
    rank = same {doStatementR0C0 -> doStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {doStatementR0C1 -> doStatementR0C2}
    rank = same {doStatementR0C2 -> doStatementR0C3}
    doStatementR0C0 -> doStatementR1C0 [weight=100000000]
    rank = same {doStatementR1C0 -> doStatementR1C1}
    doStatementR0C2 -> doStatementR1C2 [weight=100000000]
    rank = same {doStatementR1C1 -> doStatementR1C2}
    doStatementR0C3 -> doStatementR1C3 [weight=100000000]
    rank = same {doStatementR1C2 -> doStatementR1C3}
    doStatementR1C0 -> doStatementR2C0 [weight=100000000]
    rank = same {doStatementR2C0 -> doStatementR2C1}
    doStatementR1C3 -> doStatementR2C3 [weight=100000000]
    doStatementR2C0 -> doStatementR3C0 [weight=100000000]
    rank = same {doStatementR3C0 -> doStatementR3C1}
    rank = same {doStatementR3C1 -> doStatementR3C2}
    rank = same {doStatementR3C2 -> doStatementR3C3}
    doStatementR3C0 -> doStatementR4C0 [weight=100000000]
    rank = same {doStatementR4C0 -> doStatementR4C1}
    doStatementR3C2 -> doStatementR4C2 [weight=100000000]
    doStatementR4C0 -> doStatementR5C0 [weight=100000000]
    rank = same {doStatementR5C0 -> doStatementR5C1}
    doStatementR4C3 -> doStatementR5C3 [weight=100000000]
    rank = same {doStatementR5C2 -> doStatementR5C3}
    doStatementR5C0 -> doStatementR6C0 [weight=100000000]
    doStatementR5C1 -> doStatementR6C1 [weight=100000000]
    rank = same {doStatementR6C0 -> doStatementR6C1}
    rank = same {doStatementR6C1 -> doStatementR6C2}
    doStatementR5C3 -> doStatementR6C3 [weight=100000000]
    rank = same {doStatementR6C2 -> doStatementR6C3}
  }
  subgraph clusterrequirement {
    node [shape = box]
    label = <requirement = conformanceRequirement | sameTypeRequirement .>
    labeljust = l
    requirementR0C0 [label = <EPJ<br/>N requirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    requirementR0C1 [label = <EPD<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR1C1 [label = <EPE<br/>N conformanceRequirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR2C1 [label = <EPF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR1C1 -> requirementR2C1 [weight=100000000]
    requirementR0C1 -> requirementR1C1 [weight=100000000]
    requirementR0C2 [label = <EPG<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR1C2 [label = <EPH<br/>N sameTypeRequirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR2C2 [label = <EPI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    requirementR1C2 -> requirementR2C2 [weight=100000000]
    requirementR0C2 -> requirementR1C2 [weight=100000000]
    rank = same {requirementR0C1 -> requirementR0C2}
    rank = same {requirementR0C0 -> requirementR0C1}
    node [style = invis]
    edge [style = invis]
    requirementR0C0 -> requirementR1C0 [weight=100000000]
    rank = same {requirementR1C0 -> requirementR1C1}
    requirementR1C0 -> requirementR2C0 [weight=100000000]
    rank = same {requirementR2C0 -> requirementR2C1}
  }
  subgraph clusterswitchStatement {
    node [shape = box]
    label = <switchStatement = "switch" expression "{" [ switchCases ] "}" .>
    labeljust = l
    switchStatementR0C0 [label = <BCG<br/>N switchStatement<br/>fi ["switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    switchStatementR0C1 [label = <BBW<br/>ALT <br/>fi ["switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    switchStatementR1C1 [label = <BBX<br/>T "switch"<br/>fi ["switch"]<br/>fo ["try", "{"]<br/>am []<br/>>]
    switchStatementR2C1 [label = <BBY<br/>N expression<br/>fi ["", "try"]<br/>fo ["{"]<br/>am []<br/>>]
    switchStatementR3C1 [label = <BBZ<br/>T "{"<br/>fi ["{"]<br/>fo ["#if", "@", "}"]<br/>am []<br/>>]
    switchStatementR4C1 [label = <BCD<br/>OPT <br/>fi ["", "#if", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchStatementR5C1 [label = <BCE<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    switchStatementR6C1 [label = <BCF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    switchStatementR5C1 -> switchStatementR6C1 [weight=100000000]
    switchStatementR4C1 -> switchStatementR5C1 [weight=100000000]
    switchStatementR4C2 [label = <BCB<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchStatementR5C2 [label = <BCA<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchStatementR6C2 [label = <BCC<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    switchStatementR5C2 -> switchStatementR6C2 [weight=100000000]
    switchStatementR4C2 -> switchStatementR5C2 [weight=100000000]
    rank = same {switchStatementR4C1 -> switchStatementR4C2}
    switchStatementR3C1 -> switchStatementR4C1 [weight=100000000]
    switchStatementR2C1 -> switchStatementR3C1 [weight=100000000]
    switchStatementR1C1 -> switchStatementR2C1 [weight=100000000]
    switchStatementR0C1 -> switchStatementR1C1 [weight=100000000]
    rank = same {switchStatementR0C0 -> switchStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchStatementR0C1 -> switchStatementR0C2}
    switchStatementR0C0 -> switchStatementR1C0 [weight=100000000]
    rank = same {switchStatementR1C0 -> switchStatementR1C1}
    switchStatementR0C2 -> switchStatementR1C2 [weight=100000000]
    rank = same {switchStatementR1C1 -> switchStatementR1C2}
    switchStatementR1C0 -> switchStatementR2C0 [weight=100000000]
    rank = same {switchStatementR2C0 -> switchStatementR2C1}
    switchStatementR1C2 -> switchStatementR2C2 [weight=100000000]
    rank = same {switchStatementR2C1 -> switchStatementR2C2}
    switchStatementR2C0 -> switchStatementR3C0 [weight=100000000]
    rank = same {switchStatementR3C0 -> switchStatementR3C1}
    switchStatementR2C2 -> switchStatementR3C2 [weight=100000000]
    rank = same {switchStatementR3C1 -> switchStatementR3C2}
    switchStatementR3C0 -> switchStatementR4C0 [weight=100000000]
    rank = same {switchStatementR4C0 -> switchStatementR4C1}
    switchStatementR3C2 -> switchStatementR4C2 [weight=100000000]
    switchStatementR4C0 -> switchStatementR5C0 [weight=100000000]
    rank = same {switchStatementR5C0 -> switchStatementR5C1}
    switchStatementR5C0 -> switchStatementR6C0 [weight=100000000]
    rank = same {switchStatementR6C0 -> switchStatementR6C1}
  }
  subgraph clusterconformanceRequirement {
    node [shape = box]
    label = <conformanceRequirement = typeIdentifier ":" typeIdentifier | typeIdentifier ":" protocolCompositionType .>
    labeljust = l
    conformanceRequirementR0C0 [label = <EPP<br/>N conformanceRequirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    conformanceRequirementR0C1 [label = <EPK<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR1C1 [label = <EPL<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    conformanceRequirementR2C1 [label = <EPM<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    conformanceRequirementR3C1 [label = <EPN<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR4C1 [label = <EPO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR3C1 -> conformanceRequirementR4C1 [weight=100000000]
    conformanceRequirementR2C1 -> conformanceRequirementR3C1 [weight=100000000]
    conformanceRequirementR1C1 -> conformanceRequirementR2C1 [weight=100000000]
    conformanceRequirementR0C1 -> conformanceRequirementR1C1 [weight=100000000]
    conformanceRequirementR0C2 [label = <EPQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR1C2 [label = <EPR<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    conformanceRequirementR2C2 [label = <EPS<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    conformanceRequirementR3C2 [label = <EPT<br/>N protocolCompositionType<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR4C2 [label = <EPU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    conformanceRequirementR3C2 -> conformanceRequirementR4C2 [weight=100000000]
    conformanceRequirementR2C2 -> conformanceRequirementR3C2 [weight=100000000]
    conformanceRequirementR1C2 -> conformanceRequirementR2C2 [weight=100000000]
    conformanceRequirementR0C2 -> conformanceRequirementR1C2 [weight=100000000]
    rank = same {conformanceRequirementR0C1 -> conformanceRequirementR0C2}
    rank = same {conformanceRequirementR0C0 -> conformanceRequirementR0C1}
    node [style = invis]
    edge [style = invis]
    conformanceRequirementR0C0 -> conformanceRequirementR1C0 [weight=100000000]
    rank = same {conformanceRequirementR1C0 -> conformanceRequirementR1C1}
    conformanceRequirementR1C0 -> conformanceRequirementR2C0 [weight=100000000]
    rank = same {conformanceRequirementR2C0 -> conformanceRequirementR2C1}
    conformanceRequirementR2C0 -> conformanceRequirementR3C0 [weight=100000000]
    rank = same {conformanceRequirementR3C0 -> conformanceRequirementR3C1}
    conformanceRequirementR3C0 -> conformanceRequirementR4C0 [weight=100000000]
    rank = same {conformanceRequirementR4C0 -> conformanceRequirementR4C1}
  }
  subgraph clusterclassName {
    node [shape = box]
    label = <className = identifier .>
    labeljust = l
    classNameR0C0 [label = <DDT<br/>N className<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classNameR0C1 [label = <DDQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classNameR1C1 [label = <DDR<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classNameR2C1 [label = <DDS<br/>END <br/>fi [""]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classNameR1C1 -> classNameR2C1 [weight=100000000]
    classNameR0C1 -> classNameR1C1 [weight=100000000]
    rank = same {classNameR0C0 -> classNameR0C1}
    node [style = invis]
    edge [style = invis]
    classNameR0C0 -> classNameR1C0 [weight=100000000]
    rank = same {classNameR1C0 -> classNameR1C1}
    classNameR1C0 -> classNameR2C0 [weight=100000000]
    rank = same {classNameR2C0 -> classNameR2C1}
  }
  subgraph clusterprotocolCompositionContinuation {
    node [shape = box]
    label = <protocolCompositionContinuation = typeIdentifier | protocolCompositionType .>
    labeljust = l
    protocolCompositionContinuationR0C0 [label = <MG<br/>N protocolCompositionContinuation<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    protocolCompositionContinuationR0C1 [label = <MA<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR1C1 [label = <MB<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR2C1 [label = <MC<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR1C1 -> protocolCompositionContinuationR2C1 [weight=100000000]
    protocolCompositionContinuationR0C1 -> protocolCompositionContinuationR1C1 [weight=100000000]
    protocolCompositionContinuationR0C2 [label = <MD<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR1C2 [label = <ME<br/>N protocolCompositionType<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR2C2 [label = <MF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionContinuationR1C2 -> protocolCompositionContinuationR2C2 [weight=100000000]
    protocolCompositionContinuationR0C2 -> protocolCompositionContinuationR1C2 [weight=100000000]
    rank = same {protocolCompositionContinuationR0C1 -> protocolCompositionContinuationR0C2}
    rank = same {protocolCompositionContinuationR0C0 -> protocolCompositionContinuationR0C1}
    node [style = invis]
    edge [style = invis]
    protocolCompositionContinuationR0C0 -> protocolCompositionContinuationR1C0 [weight=100000000]
    rank = same {protocolCompositionContinuationR1C0 -> protocolCompositionContinuationR1C1}
    protocolCompositionContinuationR1C0 -> protocolCompositionContinuationR2C0 [weight=100000000]
    rank = same {protocolCompositionContinuationR2C0 -> protocolCompositionContinuationR2C1}
  }
  subgraph clustertypealiasDeclaration {
    node [shape = box]
    label = <typealiasDeclaration = [ attributes ] [ accessLevelModifier ] "typealias" typealiasName [ genericParameterClause ] typealiasAssignment .>
    labeljust = l
    typealiasDeclarationR0C0 [label = <CLT<br/>N typealiasDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    typealiasDeclarationR0C1 [label = <CLC<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    typealiasDeclarationR1C1 [label = <CLG<br/>OPT <br/>fi ["", "@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "typealias"]<br/>am []<br/>>]
    typealiasDeclarationR2C1 [label = <CLK<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["typealias"]<br/>am []<br/>>]
    typealiasDeclarationR3C1 [label = <CLL<br/>T "typealias"<br/>fi ["typealias"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typealiasDeclarationR4C1 [label = <CLM<br/>N typealiasName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&lt;", "="]<br/>am []<br/>>]
    typealiasDeclarationR5C1 [label = <CLQ<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["="]<br/>am []<br/>>]
    typealiasDeclarationR6C1 [label = <CLR<br/>N typealiasAssignment<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    typealiasDeclarationR7C1 [label = <CLS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    typealiasDeclarationR6C1 -> typealiasDeclarationR7C1 [weight=100000000]
    typealiasDeclarationR5C1 -> typealiasDeclarationR6C1 [weight=100000000]
    typealiasDeclarationR5C2 [label = <CLO<br/>ALT <br/>fi ["&lt;"]<br/>fo ["="]<br/>am []<br/>>]
    typealiasDeclarationR6C2 [label = <CLN<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["="]<br/>am []<br/>>]
    typealiasDeclarationR7C2 [label = <CLP<br/>END <br/>fi [""]<br/>fo ["="]<br/>am []<br/>>]
    typealiasDeclarationR6C2 -> typealiasDeclarationR7C2 [weight=100000000]
    typealiasDeclarationR5C2 -> typealiasDeclarationR6C2 [weight=100000000]
    rank = same {typealiasDeclarationR5C1 -> typealiasDeclarationR5C2}
    typealiasDeclarationR4C1 -> typealiasDeclarationR5C1 [weight=100000000]
    typealiasDeclarationR3C1 -> typealiasDeclarationR4C1 [weight=100000000]
    typealiasDeclarationR2C1 -> typealiasDeclarationR3C1 [weight=100000000]
    typealiasDeclarationR2C3 [label = <CLI<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["typealias"]<br/>am []<br/>>]
    typealiasDeclarationR3C3 [label = <CLH<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["typealias"]<br/>am []<br/>>]
    typealiasDeclarationR4C3 [label = <CLJ<br/>END <br/>fi [""]<br/>fo ["typealias"]<br/>am []<br/>>]
    typealiasDeclarationR3C3 -> typealiasDeclarationR4C3 [weight=100000000]
    typealiasDeclarationR2C3 -> typealiasDeclarationR3C3 [weight=100000000]
    rank = same {typealiasDeclarationR2C1 -> typealiasDeclarationR2C3}
    typealiasDeclarationR1C1 -> typealiasDeclarationR2C1 [weight=100000000]
    typealiasDeclarationR1C4 [label = <CLE<br/>ALT <br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "typealias"]<br/>am []<br/>>]
    typealiasDeclarationR2C4 [label = <CLD<br/>N attributes<br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "typealias"]<br/>am []<br/>>]
    typealiasDeclarationR3C4 [label = <CLF<br/>END <br/>fi [""]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "typealias"]<br/>am []<br/>>]
    typealiasDeclarationR2C4 -> typealiasDeclarationR3C4 [weight=100000000]
    typealiasDeclarationR1C4 -> typealiasDeclarationR2C4 [weight=100000000]
    rank = same {typealiasDeclarationR1C1 -> typealiasDeclarationR1C4}
    typealiasDeclarationR0C1 -> typealiasDeclarationR1C1 [weight=100000000]
    rank = same {typealiasDeclarationR0C0 -> typealiasDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {typealiasDeclarationR0C1 -> typealiasDeclarationR0C2}
    rank = same {typealiasDeclarationR0C2 -> typealiasDeclarationR0C3}
    rank = same {typealiasDeclarationR0C3 -> typealiasDeclarationR0C4}
    typealiasDeclarationR0C0 -> typealiasDeclarationR1C0 [weight=100000000]
    rank = same {typealiasDeclarationR1C0 -> typealiasDeclarationR1C1}
    typealiasDeclarationR0C4 -> typealiasDeclarationR1C4 [weight=100000000]
    typealiasDeclarationR1C0 -> typealiasDeclarationR2C0 [weight=100000000]
    rank = same {typealiasDeclarationR2C0 -> typealiasDeclarationR2C1}
    typealiasDeclarationR2C0 -> typealiasDeclarationR3C0 [weight=100000000]
    rank = same {typealiasDeclarationR3C0 -> typealiasDeclarationR3C1}
    rank = same {typealiasDeclarationR3C1 -> typealiasDeclarationR3C2}
    rank = same {typealiasDeclarationR3C2 -> typealiasDeclarationR3C3}
    typealiasDeclarationR3C0 -> typealiasDeclarationR4C0 [weight=100000000]
    rank = same {typealiasDeclarationR4C0 -> typealiasDeclarationR4C1}
    typealiasDeclarationR3C2 -> typealiasDeclarationR4C2 [weight=100000000]
    rank = same {typealiasDeclarationR4C1 -> typealiasDeclarationR4C2}
    rank = same {typealiasDeclarationR4C2 -> typealiasDeclarationR4C3}
    typealiasDeclarationR3C4 -> typealiasDeclarationR4C4 [weight=100000000]
    rank = same {typealiasDeclarationR4C3 -> typealiasDeclarationR4C4}
    typealiasDeclarationR4C0 -> typealiasDeclarationR5C0 [weight=100000000]
    rank = same {typealiasDeclarationR5C0 -> typealiasDeclarationR5C1}
    typealiasDeclarationR4C2 -> typealiasDeclarationR5C2 [weight=100000000]
    typealiasDeclarationR4C3 -> typealiasDeclarationR5C3 [weight=100000000]
    rank = same {typealiasDeclarationR5C2 -> typealiasDeclarationR5C3}
    typealiasDeclarationR4C4 -> typealiasDeclarationR5C4 [weight=100000000]
    rank = same {typealiasDeclarationR5C3 -> typealiasDeclarationR5C4}
    typealiasDeclarationR5C0 -> typealiasDeclarationR6C0 [weight=100000000]
    rank = same {typealiasDeclarationR6C0 -> typealiasDeclarationR6C1}
    typealiasDeclarationR5C3 -> typealiasDeclarationR6C3 [weight=100000000]
    rank = same {typealiasDeclarationR6C2 -> typealiasDeclarationR6C3}
    typealiasDeclarationR5C4 -> typealiasDeclarationR6C4 [weight=100000000]
    rank = same {typealiasDeclarationR6C3 -> typealiasDeclarationR6C4}
    typealiasDeclarationR6C0 -> typealiasDeclarationR7C0 [weight=100000000]
    rank = same {typealiasDeclarationR7C0 -> typealiasDeclarationR7C1}
    typealiasDeclarationR6C3 -> typealiasDeclarationR7C3 [weight=100000000]
    rank = same {typealiasDeclarationR7C2 -> typealiasDeclarationR7C3}
    typealiasDeclarationR6C4 -> typealiasDeclarationR7C4 [weight=100000000]
    rank = same {typealiasDeclarationR7C3 -> typealiasDeclarationR7C4}
  }
  subgraph clustercontrolTransferStatement {
    node [shape = box]
    label = <controlTransferStatement = breakStatement | continueStatement | fallthroughStatement | returnStatement | throwStatement .>
    labeljust = l
    controlTransferStatementR0C0 [label = <BHS<br/>N controlTransferStatement<br/>fi ["break", "continue", "fallthrough", "return", "throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR0C1 [label = <BHP<br/>ALT <br/>fi ["break"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C1 [label = <BHQ<br/>N breakStatement<br/>fi ["break"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR2C1 [label = <BHR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C1 -> controlTransferStatementR2C1 [weight=100000000]
    controlTransferStatementR0C1 -> controlTransferStatementR1C1 [weight=100000000]
    controlTransferStatementR0C2 [label = <BHT<br/>ALT <br/>fi ["continue"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C2 [label = <BHU<br/>N continueStatement<br/>fi ["continue"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR2C2 [label = <BHV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C2 -> controlTransferStatementR2C2 [weight=100000000]
    controlTransferStatementR0C2 -> controlTransferStatementR1C2 [weight=100000000]
    controlTransferStatementR0C3 [label = <BHW<br/>ALT <br/>fi ["fallthrough"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C3 [label = <BHX<br/>N fallthroughStatement<br/>fi ["fallthrough"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR2C3 [label = <BHY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C3 -> controlTransferStatementR2C3 [weight=100000000]
    controlTransferStatementR0C3 -> controlTransferStatementR1C3 [weight=100000000]
    controlTransferStatementR0C4 [label = <BHZ<br/>ALT <br/>fi ["return"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C4 [label = <BIA<br/>N returnStatement<br/>fi ["return"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR2C4 [label = <BIB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C4 -> controlTransferStatementR2C4 [weight=100000000]
    controlTransferStatementR0C4 -> controlTransferStatementR1C4 [weight=100000000]
    controlTransferStatementR0C5 [label = <BIC<br/>ALT <br/>fi ["throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C5 [label = <BID<br/>N throwStatement<br/>fi ["throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR2C5 [label = <BIE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    controlTransferStatementR1C5 -> controlTransferStatementR2C5 [weight=100000000]
    controlTransferStatementR0C5 -> controlTransferStatementR1C5 [weight=100000000]
    rank = same {controlTransferStatementR0C4 -> controlTransferStatementR0C5}
    rank = same {controlTransferStatementR0C3 -> controlTransferStatementR0C4}
    rank = same {controlTransferStatementR0C2 -> controlTransferStatementR0C3}
    rank = same {controlTransferStatementR0C1 -> controlTransferStatementR0C2}
    rank = same {controlTransferStatementR0C0 -> controlTransferStatementR0C1}
    node [style = invis]
    edge [style = invis]
    controlTransferStatementR0C0 -> controlTransferStatementR1C0 [weight=100000000]
    rank = same {controlTransferStatementR1C0 -> controlTransferStatementR1C1}
    controlTransferStatementR1C0 -> controlTransferStatementR2C0 [weight=100000000]
    rank = same {controlTransferStatementR2C0 -> controlTransferStatementR2C1}
  }
  subgraph clusterrepeatWhileStatement {
    node [shape = box]
    label = <repeatWhileStatement = "repeat" codeBlock "while" expression .>
    labeljust = l
    repeatWhileStatementR0C0 [label = <BAL<br/>N repeatWhileStatement<br/>fi ["repeat"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    repeatWhileStatementR0C1 [label = <BAF<br/>ALT <br/>fi ["repeat"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    repeatWhileStatementR1C1 [label = <BAG<br/>T "repeat"<br/>fi ["repeat"]<br/>fo ["{"]<br/>am []<br/>>]
    repeatWhileStatementR2C1 [label = <BAH<br/>N codeBlock<br/>fi ["{"]<br/>fo ["while"]<br/>am []<br/>>]
    repeatWhileStatementR3C1 [label = <BAI<br/>T "while"<br/>fi ["while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    repeatWhileStatementR4C1 [label = <BAJ<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    repeatWhileStatementR5C1 [label = <BAK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    repeatWhileStatementR4C1 -> repeatWhileStatementR5C1 [weight=100000000]
    repeatWhileStatementR3C1 -> repeatWhileStatementR4C1 [weight=100000000]
    repeatWhileStatementR2C1 -> repeatWhileStatementR3C1 [weight=100000000]
    repeatWhileStatementR1C1 -> repeatWhileStatementR2C1 [weight=100000000]
    repeatWhileStatementR0C1 -> repeatWhileStatementR1C1 [weight=100000000]
    rank = same {repeatWhileStatementR0C0 -> repeatWhileStatementR0C1}
    node [style = invis]
    edge [style = invis]
    repeatWhileStatementR0C0 -> repeatWhileStatementR1C0 [weight=100000000]
    rank = same {repeatWhileStatementR1C0 -> repeatWhileStatementR1C1}
    repeatWhileStatementR1C0 -> repeatWhileStatementR2C0 [weight=100000000]
    rank = same {repeatWhileStatementR2C0 -> repeatWhileStatementR2C1}
    repeatWhileStatementR2C0 -> repeatWhileStatementR3C0 [weight=100000000]
    rank = same {repeatWhileStatementR3C0 -> repeatWhileStatementR3C1}
    repeatWhileStatementR3C0 -> repeatWhileStatementR4C0 [weight=100000000]
    rank = same {repeatWhileStatementR4C0 -> repeatWhileStatementR4C1}
    repeatWhileStatementR4C0 -> repeatWhileStatementR5C0 [weight=100000000]
    rank = same {repeatWhileStatementR5C0 -> repeatWhileStatementR5C1}
  }
  subgraph clusterprefixOperatorDeclaration {
    node [shape = box]
    label = <prefixOperatorDeclaration = "prefix" "operator" Operator .>
    labeljust = l
    prefixOperatorDeclarationR0C0 [label = <DWI<br/>N prefixOperatorDeclaration<br/>fi ["prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    prefixOperatorDeclarationR0C1 [label = <DWD<br/>ALT <br/>fi ["prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    prefixOperatorDeclarationR1C1 [label = <DWE<br/>T "prefix"<br/>fi ["prefix"]<br/>fo ["operator"]<br/>am []<br/>>]
    prefixOperatorDeclarationR2C1 [label = <DWF<br/>T "operator"<br/>fi ["operator"]<br/>fo ["dotOperator", "plainOperator"]<br/>am []<br/>>]
    prefixOperatorDeclarationR3C1 [label = <DWG<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    prefixOperatorDeclarationR4C1 [label = <DWH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    prefixOperatorDeclarationR3C1 -> prefixOperatorDeclarationR4C1 [weight=100000000]
    prefixOperatorDeclarationR2C1 -> prefixOperatorDeclarationR3C1 [weight=100000000]
    prefixOperatorDeclarationR1C1 -> prefixOperatorDeclarationR2C1 [weight=100000000]
    prefixOperatorDeclarationR0C1 -> prefixOperatorDeclarationR1C1 [weight=100000000]
    rank = same {prefixOperatorDeclarationR0C0 -> prefixOperatorDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    prefixOperatorDeclarationR0C0 -> prefixOperatorDeclarationR1C0 [weight=100000000]
    rank = same {prefixOperatorDeclarationR1C0 -> prefixOperatorDeclarationR1C1}
    prefixOperatorDeclarationR1C0 -> prefixOperatorDeclarationR2C0 [weight=100000000]
    rank = same {prefixOperatorDeclarationR2C0 -> prefixOperatorDeclarationR2C1}
    prefixOperatorDeclarationR2C0 -> prefixOperatorDeclarationR3C0 [weight=100000000]
    rank = same {prefixOperatorDeclarationR3C0 -> prefixOperatorDeclarationR3C1}
    prefixOperatorDeclarationR3C0 -> prefixOperatorDeclarationR4C0 [weight=100000000]
    rank = same {prefixOperatorDeclarationR4C0 -> prefixOperatorDeclarationR4C1}
  }
  subgraph clusterinitializerBody {
    node [shape = box]
    label = <initializerBody = codeBlock .>
    labeljust = l
    initializerBodyR0C0 [label = <DPU<br/>N initializerBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerBodyR0C1 [label = <DPR<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerBodyR1C1 [label = <DPS<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerBodyR2C1 [label = <DPT<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerBodyR1C1 -> initializerBodyR2C1 [weight=100000000]
    initializerBodyR0C1 -> initializerBodyR1C1 [weight=100000000]
    rank = same {initializerBodyR0C0 -> initializerBodyR0C1}
    node [style = invis]
    edge [style = invis]
    initializerBodyR0C0 -> initializerBodyR1C0 [weight=100000000]
    rank = same {initializerBodyR1C0 -> initializerBodyR1C1}
    initializerBodyR1C0 -> initializerBodyR2C0 [weight=100000000]
    rank = same {initializerBodyR2C0 -> initializerBodyR2C1}
  }
  subgraph clusterstructMember {
    node [shape = box]
    label = <structMember = declaration | compilerControlStatement .>
    labeljust = l
    structMemberR0C0 [label = <DBL<br/>N structMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    structMemberR0C1 [label = <DBF<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    structMemberR1C1 [label = <DBG<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    structMemberR2C1 [label = <DBH<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    structMemberR1C1 -> structMemberR2C1 [weight=100000000]
    structMemberR0C1 -> structMemberR1C1 [weight=100000000]
    structMemberR0C2 [label = <DBI<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    structMemberR1C2 [label = <DBJ<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    structMemberR2C2 [label = <DBK<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    structMemberR1C2 -> structMemberR2C2 [weight=100000000]
    structMemberR0C2 -> structMemberR1C2 [weight=100000000]
    rank = same {structMemberR0C1 -> structMemberR0C2}
    rank = same {structMemberR0C0 -> structMemberR0C1}
    node [style = invis]
    edge [style = invis]
    structMemberR0C0 -> structMemberR1C0 [weight=100000000]
    rank = same {structMemberR1C0 -> structMemberR1C1}
    structMemberR1C0 -> structMemberR2C0 [weight=100000000]
    rank = same {structMemberR2C0 -> structMemberR2C1}
  }
  subgraph clustercaptureListItem {
    node [shape = box]
    label = <captureListItem = [ captureSpecifier ] identifier | [ captureSpecifier ] identifier "=" expression | [ captureSpecifier ] selfExpression .>
    labeljust = l
    captureListItemR0C0 [label = <AGY<br/>N captureListItem<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo [",", "]"]<br/>am ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>>]
    captureListItemR0C1 [label = <AGR<br/>ALT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR1C1 [label = <AGV<br/>OPT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C1 [label = <AGW<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR3C1 [label = <AGX<br/>END <br/>fi [""]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR2C1 -> captureListItemR3C1 [weight=100000000]
    captureListItemR1C1 -> captureListItemR2C1 [weight=100000000]
    captureListItemR1C2 [label = <AGT<br/>ALT <br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C2 [label = <AGS<br/>N captureSpecifier<br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR3C2 [label = <AGU<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C2 -> captureListItemR3C2 [weight=100000000]
    captureListItemR1C2 -> captureListItemR2C2 [weight=100000000]
    rank = same {captureListItemR1C1 -> captureListItemR1C2}
    captureListItemR0C1 -> captureListItemR1C1 [weight=100000000]
    captureListItemR0C3 [label = <AGZ<br/>ALT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR1C3 [label = <AHD<br/>OPT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C3 [label = <AHE<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["="]<br/>am []<br/>>]
    captureListItemR3C3 [label = <AHF<br/>T "="<br/>fi ["="]<br/>fo [",", "]", "try"]<br/>am []<br/>>]
    captureListItemR4C3 [label = <AHG<br/>N expression<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR5C3 [label = <AHH<br/>END <br/>fi [""]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR4C3 -> captureListItemR5C3 [weight=100000000]
    captureListItemR3C3 -> captureListItemR4C3 [weight=100000000]
    captureListItemR2C3 -> captureListItemR3C3 [weight=100000000]
    captureListItemR1C3 -> captureListItemR2C3 [weight=100000000]
    captureListItemR1C4 [label = <AHB<br/>ALT <br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C4 [label = <AHA<br/>N captureSpecifier<br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR3C4 [label = <AHC<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListItemR2C4 -> captureListItemR3C4 [weight=100000000]
    captureListItemR1C4 -> captureListItemR2C4 [weight=100000000]
    rank = same {captureListItemR1C3 -> captureListItemR1C4}
    captureListItemR0C3 -> captureListItemR1C3 [weight=100000000]
    captureListItemR0C5 [label = <AHI<br/>ALT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR1C5 [label = <AHM<br/>OPT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["self"]<br/>am []<br/>>]
    captureListItemR2C5 [label = <AHN<br/>N selfExpression<br/>fi ["self"]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR3C5 [label = <AHO<br/>END <br/>fi [""]<br/>fo [",", "]"]<br/>am []<br/>>]
    captureListItemR2C5 -> captureListItemR3C5 [weight=100000000]
    captureListItemR1C5 -> captureListItemR2C5 [weight=100000000]
    captureListItemR1C6 [label = <AHK<br/>ALT <br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["self"]<br/>am []<br/>>]
    captureListItemR2C6 [label = <AHJ<br/>N captureSpecifier<br/>fi ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["self"]<br/>am []<br/>>]
    captureListItemR3C6 [label = <AHL<br/>END <br/>fi [""]<br/>fo ["self"]<br/>am []<br/>>]
    captureListItemR2C6 -> captureListItemR3C6 [weight=100000000]
    captureListItemR1C6 -> captureListItemR2C6 [weight=100000000]
    rank = same {captureListItemR1C5 -> captureListItemR1C6}
    captureListItemR0C5 -> captureListItemR1C5 [weight=100000000]
    rank = same {captureListItemR0C3 -> captureListItemR0C5}
    rank = same {captureListItemR0C1 -> captureListItemR0C3}
    rank = same {captureListItemR0C0 -> captureListItemR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {captureListItemR0C5 -> captureListItemR0C6}
    captureListItemR0C0 -> captureListItemR1C0 [weight=100000000]
    rank = same {captureListItemR1C0 -> captureListItemR1C1}
    captureListItemR0C6 -> captureListItemR1C6 [weight=100000000]
    captureListItemR1C0 -> captureListItemR2C0 [weight=100000000]
    rank = same {captureListItemR2C0 -> captureListItemR2C1}
    captureListItemR2C0 -> captureListItemR3C0 [weight=100000000]
    rank = same {captureListItemR3C0 -> captureListItemR3C1}
    captureListItemR3C0 -> captureListItemR4C0 [weight=100000000]
    captureListItemR3C1 -> captureListItemR4C1 [weight=100000000]
    rank = same {captureListItemR4C0 -> captureListItemR4C1}
    captureListItemR3C2 -> captureListItemR4C2 [weight=100000000]
    rank = same {captureListItemR4C1 -> captureListItemR4C2}
    rank = same {captureListItemR4C2 -> captureListItemR4C3}
    captureListItemR3C4 -> captureListItemR4C4 [weight=100000000]
    rank = same {captureListItemR4C3 -> captureListItemR4C4}
    captureListItemR3C5 -> captureListItemR4C5 [weight=100000000]
    rank = same {captureListItemR4C4 -> captureListItemR4C5}
    captureListItemR3C6 -> captureListItemR4C6 [weight=100000000]
    rank = same {captureListItemR4C5 -> captureListItemR4C6}
    captureListItemR4C0 -> captureListItemR5C0 [weight=100000000]
    captureListItemR4C1 -> captureListItemR5C1 [weight=100000000]
    rank = same {captureListItemR5C0 -> captureListItemR5C1}
    captureListItemR4C2 -> captureListItemR5C2 [weight=100000000]
    rank = same {captureListItemR5C1 -> captureListItemR5C2}
    rank = same {captureListItemR5C2 -> captureListItemR5C3}
    captureListItemR4C4 -> captureListItemR5C4 [weight=100000000]
    rank = same {captureListItemR5C3 -> captureListItemR5C4}
    captureListItemR4C5 -> captureListItemR5C5 [weight=100000000]
    rank = same {captureListItemR5C4 -> captureListItemR5C5}
    captureListItemR4C6 -> captureListItemR5C6 [weight=100000000]
    rank = same {captureListItemR5C5 -> captureListItemR5C6}
  }
  subgraph clustersubscriptResult {
    node [shape = box]
    label = <subscriptResult = "&gt;" [ attributes ] type .>
    labeljust = l
    subscriptResultR0C0 [label = <DTZ<br/>N subscriptResult<br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptResultR0C1 [label = <DTR<br/>ALT <br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptResultR1C1 [label = <DTS<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where", "{"]<br/>am []<br/>>]
    subscriptResultR2C1 [label = <DTW<br/>OPT <br/>fi ["", "@"]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where", "{"]<br/>am ["@"]<br/>>]
    subscriptResultR3C1 [label = <DTX<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptResultR4C1 [label = <DTY<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptResultR3C1 -> subscriptResultR4C1 [weight=100000000]
    subscriptResultR2C1 -> subscriptResultR3C1 [weight=100000000]
    subscriptResultR2C2 [label = <DTU<br/>ALT <br/>fi ["@"]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where", "{"]<br/>am []<br/>>]
    subscriptResultR3C2 [label = <DTT<br/>N attributes<br/>fi ["@"]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where", "{"]<br/>am []<br/>>]
    subscriptResultR4C2 [label = <DTV<br/>END <br/>fi [""]<br/>fo ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some", "where", "{"]<br/>am []<br/>>]
    subscriptResultR3C2 -> subscriptResultR4C2 [weight=100000000]
    subscriptResultR2C2 -> subscriptResultR3C2 [weight=100000000]
    rank = same {subscriptResultR2C1 -> subscriptResultR2C2}
    subscriptResultR1C1 -> subscriptResultR2C1 [weight=100000000]
    subscriptResultR0C1 -> subscriptResultR1C1 [weight=100000000]
    rank = same {subscriptResultR0C0 -> subscriptResultR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {subscriptResultR0C1 -> subscriptResultR0C2}
    subscriptResultR0C0 -> subscriptResultR1C0 [weight=100000000]
    rank = same {subscriptResultR1C0 -> subscriptResultR1C1}
    subscriptResultR0C2 -> subscriptResultR1C2 [weight=100000000]
    rank = same {subscriptResultR1C1 -> subscriptResultR1C2}
    subscriptResultR1C0 -> subscriptResultR2C0 [weight=100000000]
    rank = same {subscriptResultR2C0 -> subscriptResultR2C1}
    subscriptResultR1C2 -> subscriptResultR2C2 [weight=100000000]
    subscriptResultR2C0 -> subscriptResultR3C0 [weight=100000000]
    rank = same {subscriptResultR3C0 -> subscriptResultR3C1}
    subscriptResultR3C0 -> subscriptResultR4C0 [weight=100000000]
    rank = same {subscriptResultR4C0 -> subscriptResultR4C1}
  }
  subgraph clustersetterClause {
    node [shape = box]
    label = <setterClause = [ attributes ] [ mutationModifier ] "set" [ setterName ] codeBlock .>
    labeljust = l
    setterClauseR0C0 [label = <CHO<br/>N setterClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    setterClauseR0C1 [label = <CGY<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    setterClauseR1C1 [label = <CHC<br/>OPT <br/>fi ["", "@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterClauseR2C1 [label = <CHG<br/>OPT <br/>fi ["", "mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterClauseR3C1 [label = <CHH<br/>T "set"<br/>fi ["set"]<br/>fo ["(", "{"]<br/>am []<br/>>]
    setterClauseR4C1 [label = <CHL<br/>OPT <br/>fi ["", "("]<br/>fo ["{"]<br/>am []<br/>>]
    setterClauseR5C1 [label = <CHM<br/>N codeBlock<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    setterClauseR6C1 [label = <CHN<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    setterClauseR5C1 -> setterClauseR6C1 [weight=100000000]
    setterClauseR4C1 -> setterClauseR5C1 [weight=100000000]
    setterClauseR4C2 [label = <CHJ<br/>ALT <br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    setterClauseR5C2 [label = <CHI<br/>N setterName<br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    setterClauseR6C2 [label = <CHK<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    setterClauseR5C2 -> setterClauseR6C2 [weight=100000000]
    setterClauseR4C2 -> setterClauseR5C2 [weight=100000000]
    rank = same {setterClauseR4C1 -> setterClauseR4C2}
    setterClauseR3C1 -> setterClauseR4C1 [weight=100000000]
    setterClauseR2C1 -> setterClauseR3C1 [weight=100000000]
    setterClauseR2C3 [label = <CHE<br/>ALT <br/>fi ["mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterClauseR3C3 [label = <CHD<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterClauseR4C3 [label = <CHF<br/>END <br/>fi [""]<br/>fo ["set"]<br/>am []<br/>>]
    setterClauseR3C3 -> setterClauseR4C3 [weight=100000000]
    setterClauseR2C3 -> setterClauseR3C3 [weight=100000000]
    rank = same {setterClauseR2C1 -> setterClauseR2C3}
    setterClauseR1C1 -> setterClauseR2C1 [weight=100000000]
    setterClauseR1C4 [label = <CHA<br/>ALT <br/>fi ["@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterClauseR2C4 [label = <CGZ<br/>N attributes<br/>fi ["@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterClauseR3C4 [label = <CHB<br/>END <br/>fi [""]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterClauseR2C4 -> setterClauseR3C4 [weight=100000000]
    setterClauseR1C4 -> setterClauseR2C4 [weight=100000000]
    rank = same {setterClauseR1C1 -> setterClauseR1C4}
    setterClauseR0C1 -> setterClauseR1C1 [weight=100000000]
    rank = same {setterClauseR0C0 -> setterClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {setterClauseR0C1 -> setterClauseR0C2}
    rank = same {setterClauseR0C2 -> setterClauseR0C3}
    rank = same {setterClauseR0C3 -> setterClauseR0C4}
    setterClauseR0C0 -> setterClauseR1C0 [weight=100000000]
    rank = same {setterClauseR1C0 -> setterClauseR1C1}
    setterClauseR0C4 -> setterClauseR1C4 [weight=100000000]
    setterClauseR1C0 -> setterClauseR2C0 [weight=100000000]
    rank = same {setterClauseR2C0 -> setterClauseR2C1}
    setterClauseR2C0 -> setterClauseR3C0 [weight=100000000]
    rank = same {setterClauseR3C0 -> setterClauseR3C1}
    rank = same {setterClauseR3C1 -> setterClauseR3C2}
    rank = same {setterClauseR3C2 -> setterClauseR3C3}
    setterClauseR3C0 -> setterClauseR4C0 [weight=100000000]
    rank = same {setterClauseR4C0 -> setterClauseR4C1}
    setterClauseR3C2 -> setterClauseR4C2 [weight=100000000]
    setterClauseR3C4 -> setterClauseR4C4 [weight=100000000]
    rank = same {setterClauseR4C3 -> setterClauseR4C4}
    setterClauseR4C0 -> setterClauseR5C0 [weight=100000000]
    rank = same {setterClauseR5C0 -> setterClauseR5C1}
    setterClauseR4C3 -> setterClauseR5C3 [weight=100000000]
    rank = same {setterClauseR5C2 -> setterClauseR5C3}
    setterClauseR4C4 -> setterClauseR5C4 [weight=100000000]
    rank = same {setterClauseR5C3 -> setterClauseR5C4}
    setterClauseR5C0 -> setterClauseR6C0 [weight=100000000]
    rank = same {setterClauseR6C0 -> setterClauseR6C1}
    setterClauseR5C3 -> setterClauseR6C3 [weight=100000000]
    rank = same {setterClauseR6C2 -> setterClauseR6C3}
    setterClauseR5C4 -> setterClauseR6C4 [weight=100000000]
    rank = same {setterClauseR6C3 -> setterClauseR6C4}
  }
  subgraph clusterdeclaration {
    node [shape = box]
    label = <declaration = importDeclaration | constantDeclaration | variableDeclaration | typealiasDeclaration | functionDeclaration | enumDeclaration | structDeclaration | classDeclaration | actorDeclaration | protocolDeclaration | initializerDeclaration | deinitializerDeclaration | extensionDeclaration | subscriptDeclaration | operatorDeclaration | precedenceGroupDeclaration .>
    labeljust = l
    declarationR0C0 [label = <BYI<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    declarationR0C1 [label = <BYF<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C1 [label = <BYG<br/>N importDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C1 [label = <BYH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C1 -> declarationR2C1 [weight=100000000]
    declarationR0C1 -> declarationR1C1 [weight=100000000]
    declarationR0C2 [label = <BYJ<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C2 [label = <BYK<br/>N constantDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C2 [label = <BYL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C2 -> declarationR2C2 [weight=100000000]
    declarationR0C2 -> declarationR1C2 [weight=100000000]
    declarationR0C3 [label = <BYM<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C3 [label = <BYN<br/>N variableDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C3 [label = <BYO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C3 -> declarationR2C3 [weight=100000000]
    declarationR0C3 -> declarationR1C3 [weight=100000000]
    declarationR0C4 [label = <BYP<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C4 [label = <BYQ<br/>N typealiasDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C4 [label = <BYR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C4 -> declarationR2C4 [weight=100000000]
    declarationR0C4 -> declarationR1C4 [weight=100000000]
    declarationR0C5 [label = <BYS<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C5 [label = <BYT<br/>N functionDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C5 [label = <BYU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C5 -> declarationR2C5 [weight=100000000]
    declarationR0C5 -> declarationR1C5 [weight=100000000]
    declarationR0C6 [label = <BYV<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C6 [label = <BYW<br/>N enumDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C6 [label = <BYX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C6 -> declarationR2C6 [weight=100000000]
    declarationR0C6 -> declarationR1C6 [weight=100000000]
    declarationR0C7 [label = <BYY<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C7 [label = <BYZ<br/>N structDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C7 [label = <BZA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C7 -> declarationR2C7 [weight=100000000]
    declarationR0C7 -> declarationR1C7 [weight=100000000]
    declarationR0C8 [label = <BZB<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C8 [label = <BZC<br/>N classDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C8 [label = <BZD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C8 -> declarationR2C8 [weight=100000000]
    declarationR0C8 -> declarationR1C8 [weight=100000000]
    declarationR0C9 [label = <BZE<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C9 [label = <BZF<br/>N actorDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C9 [label = <BZG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C9 -> declarationR2C9 [weight=100000000]
    declarationR0C9 -> declarationR1C9 [weight=100000000]
    declarationR0C10 [label = <BZH<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C10 [label = <BZI<br/>N protocolDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C10 [label = <BZJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C10 -> declarationR2C10 [weight=100000000]
    declarationR0C10 -> declarationR1C10 [weight=100000000]
    declarationR0C11 [label = <BZK<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C11 [label = <BZL<br/>N initializerDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C11 [label = <BZM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C11 -> declarationR2C11 [weight=100000000]
    declarationR0C11 -> declarationR1C11 [weight=100000000]
    declarationR0C12 [label = <BZN<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C12 [label = <BZO<br/>N deinitializerDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C12 [label = <BZP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C12 -> declarationR2C12 [weight=100000000]
    declarationR0C12 -> declarationR1C12 [weight=100000000]
    declarationR0C13 [label = <BZQ<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C13 [label = <BZR<br/>N extensionDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C13 [label = <BZS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C13 -> declarationR2C13 [weight=100000000]
    declarationR0C13 -> declarationR1C13 [weight=100000000]
    declarationR0C14 [label = <BZT<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR1C14 [label = <BZU<br/>N subscriptDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    declarationR2C14 [label = <BZV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C14 -> declarationR2C14 [weight=100000000]
    declarationR0C14 -> declarationR1C14 [weight=100000000]
    declarationR0C15 [label = <BZW<br/>ALT <br/>fi ["infix", "postfix", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C15 [label = <BZX<br/>N operatorDeclaration<br/>fi ["infix", "postfix", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR2C15 [label = <BZY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C15 -> declarationR2C15 [weight=100000000]
    declarationR0C15 -> declarationR1C15 [weight=100000000]
    declarationR0C16 [label = <BZZ<br/>ALT <br/>fi ["precedencegroup"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C16 [label = <CAA<br/>N precedenceGroupDeclaration<br/>fi ["precedencegroup"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR2C16 [label = <CAB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    declarationR1C16 -> declarationR2C16 [weight=100000000]
    declarationR0C16 -> declarationR1C16 [weight=100000000]
    rank = same {declarationR0C15 -> declarationR0C16}
    rank = same {declarationR0C14 -> declarationR0C15}
    rank = same {declarationR0C13 -> declarationR0C14}
    rank = same {declarationR0C12 -> declarationR0C13}
    rank = same {declarationR0C11 -> declarationR0C12}
    rank = same {declarationR0C10 -> declarationR0C11}
    rank = same {declarationR0C9 -> declarationR0C10}
    rank = same {declarationR0C8 -> declarationR0C9}
    rank = same {declarationR0C7 -> declarationR0C8}
    rank = same {declarationR0C6 -> declarationR0C7}
    rank = same {declarationR0C5 -> declarationR0C6}
    rank = same {declarationR0C4 -> declarationR0C5}
    rank = same {declarationR0C3 -> declarationR0C4}
    rank = same {declarationR0C2 -> declarationR0C3}
    rank = same {declarationR0C1 -> declarationR0C2}
    rank = same {declarationR0C0 -> declarationR0C1}
    node [style = invis]
    edge [style = invis]
    declarationR0C0 -> declarationR1C0 [weight=100000000]
    rank = same {declarationR1C0 -> declarationR1C1}
    declarationR1C0 -> declarationR2C0 [weight=100000000]
    rank = same {declarationR2C0 -> declarationR2C1}
  }
  subgraph clusterthrowStatement {
    node [shape = box]
    label = <throwStatement = "throw" expression .>
    labeljust = l
    throwStatementR0C0 [label = <BJL<br/>N throwStatement<br/>fi ["throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    throwStatementR0C1 [label = <BJH<br/>ALT <br/>fi ["throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    throwStatementR1C1 [label = <BJI<br/>T "throw"<br/>fi ["throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    throwStatementR2C1 [label = <BJJ<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    throwStatementR3C1 [label = <BJK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    throwStatementR2C1 -> throwStatementR3C1 [weight=100000000]
    throwStatementR1C1 -> throwStatementR2C1 [weight=100000000]
    throwStatementR0C1 -> throwStatementR1C1 [weight=100000000]
    rank = same {throwStatementR0C0 -> throwStatementR0C1}
    node [style = invis]
    edge [style = invis]
    throwStatementR0C0 -> throwStatementR1C0 [weight=100000000]
    rank = same {throwStatementR1C0 -> throwStatementR1C1}
    throwStatementR1C0 -> throwStatementR2C0 [weight=100000000]
    rank = same {throwStatementR2C0 -> throwStatementR2C1}
    throwStatementR2C0 -> throwStatementR3C0 [weight=100000000]
    rank = same {throwStatementR3C0 -> throwStatementR3C1}
  }
  subgraph clusterstatementLabel {
    node [shape = box]
    label = <statementLabel = labelName ":" .>
    labeljust = l
    statementLabelR0C0 [label = <BHK<br/>N statementLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["do", "for", "if", "repeat", "switch", "while"]<br/>am []<br/>>]
    statementLabelR0C1 [label = <BHG<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["do", "for", "if", "repeat", "switch", "while"]<br/>am []<br/>>]
    statementLabelR1C1 [label = <BHH<br/>N labelName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    statementLabelR2C1 [label = <BHI<br/>T ":"<br/>fi [":"]<br/>fo ["do", "for", "if", "repeat", "switch", "while"]<br/>am []<br/>>]
    statementLabelR3C1 [label = <BHJ<br/>END <br/>fi [""]<br/>fo ["do", "for", "if", "repeat", "switch", "while"]<br/>am []<br/>>]
    statementLabelR2C1 -> statementLabelR3C1 [weight=100000000]
    statementLabelR1C1 -> statementLabelR2C1 [weight=100000000]
    statementLabelR0C1 -> statementLabelR1C1 [weight=100000000]
    rank = same {statementLabelR0C0 -> statementLabelR0C1}
    node [style = invis]
    edge [style = invis]
    statementLabelR0C0 -> statementLabelR1C0 [weight=100000000]
    rank = same {statementLabelR1C0 -> statementLabelR1C1}
    statementLabelR1C0 -> statementLabelR2C0 [weight=100000000]
    rank = same {statementLabelR2C0 -> statementLabelR2C1}
    statementLabelR2C0 -> statementLabelR3C0 [weight=100000000]
    rank = same {statementLabelR3C0 -> statementLabelR3C1}
  }
  subgraph clustermutationModifier {
    node [shape = box]
    label = <mutationModifier = "mutating" | "nonmutating" .>
    labeljust = l
    mutationModifierR0C0 [label = <EFE<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR0C1 [label = <EEY<br/>ALT <br/>fi ["mutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR1C1 [label = <EEZ<br/>T "mutating"<br/>fi ["mutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR2C1 [label = <EFA<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR1C1 -> mutationModifierR2C1 [weight=100000000]
    mutationModifierR0C1 -> mutationModifierR1C1 [weight=100000000]
    mutationModifierR0C2 [label = <EFB<br/>ALT <br/>fi ["nonmutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR1C2 [label = <EFC<br/>T "nonmutating"<br/>fi ["nonmutating"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR2C2 [label = <EFD<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "func", "get", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "set", "static", "subscript", "unowned", "var", "weak"]<br/>am []<br/>>]
    mutationModifierR1C2 -> mutationModifierR2C2 [weight=100000000]
    mutationModifierR0C2 -> mutationModifierR1C2 [weight=100000000]
    rank = same {mutationModifierR0C1 -> mutationModifierR0C2}
    rank = same {mutationModifierR0C0 -> mutationModifierR0C1}
    node [style = invis]
    edge [style = invis]
    mutationModifierR0C0 -> mutationModifierR1C0 [weight=100000000]
    rank = same {mutationModifierR1C0 -> mutationModifierR1C1}
    mutationModifierR1C0 -> mutationModifierR2C0 [weight=100000000]
    rank = same {mutationModifierR2C0 -> mutationModifierR2C1}
  }
  subgraph clusterinitializer {
    node [shape = box]
    label = <initializer = "=" expression .>
    labeljust = l
    initializerR0C0 [label = <CDO<br/>N initializer<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    initializerR0C1 [label = <CDK<br/>ALT <br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    initializerR1C1 [label = <CDL<br/>T "="<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    initializerR2C1 [label = <CDM<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am ["try"]<br/>>]
    initializerR3C1 [label = <CDN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    initializerR2C1 -> initializerR3C1 [weight=100000000]
    initializerR1C1 -> initializerR2C1 [weight=100000000]
    initializerR0C1 -> initializerR1C1 [weight=100000000]
    rank = same {initializerR0C0 -> initializerR0C1}
    node [style = invis]
    edge [style = invis]
    initializerR0C0 -> initializerR1C0 [weight=100000000]
    rank = same {initializerR1C0 -> initializerR1C1}
    initializerR1C0 -> initializerR2C0 [weight=100000000]
    rank = same {initializerR2C0 -> initializerR2C1}
    initializerR2C0 -> initializerR3C0 [weight=100000000]
    rank = same {initializerR3C0 -> initializerR3C1}
  }
  subgraph clusteraccessLevelModifier {
    node [shape = box]
    label = <accessLevelModifier = "private" | "private" "(" "set" ")" | "fileprivate" | "fileprivate" "(" "set" ")" | "internal" | "internal" "(" "set" ")" | "package" | "package" "(" "set" ")" | "public" | "public" "(" "set" ")" | "open" | "open" "(" "set" ")" .>
    labeljust = l
    accessLevelModifierR0C0 [label = <EDE<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am ["fileprivate", "internal", "open", "package", "private", "public"]<br/>>]
    accessLevelModifierR0C1 [label = <ECV<br/>ALT <br/>fi ["private"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C1 [label = <ECW<br/>T "private"<br/>fi ["private"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C1 [label = <ECX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C1 -> accessLevelModifierR2C1 [weight=100000000]
    accessLevelModifierR0C1 -> accessLevelModifierR1C1 [weight=100000000]
    accessLevelModifierR0C2 [label = <ECY<br/>ALT <br/>fi ["private"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C2 [label = <ECZ<br/>T "private"<br/>fi ["private"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C2 [label = <EDA<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C2 [label = <EDB<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C2 [label = <EDC<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C2 [label = <EDD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C2 -> accessLevelModifierR5C2 [weight=100000000]
    accessLevelModifierR3C2 -> accessLevelModifierR4C2 [weight=100000000]
    accessLevelModifierR2C2 -> accessLevelModifierR3C2 [weight=100000000]
    accessLevelModifierR1C2 -> accessLevelModifierR2C2 [weight=100000000]
    accessLevelModifierR0C2 -> accessLevelModifierR1C2 [weight=100000000]
    accessLevelModifierR0C3 [label = <EDF<br/>ALT <br/>fi ["fileprivate"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C3 [label = <EDG<br/>T "fileprivate"<br/>fi ["fileprivate"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C3 [label = <EDH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C3 -> accessLevelModifierR2C3 [weight=100000000]
    accessLevelModifierR0C3 -> accessLevelModifierR1C3 [weight=100000000]
    accessLevelModifierR0C4 [label = <EDI<br/>ALT <br/>fi ["fileprivate"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C4 [label = <EDJ<br/>T "fileprivate"<br/>fi ["fileprivate"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C4 [label = <EDK<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C4 [label = <EDL<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C4 [label = <EDM<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C4 [label = <EDN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C4 -> accessLevelModifierR5C4 [weight=100000000]
    accessLevelModifierR3C4 -> accessLevelModifierR4C4 [weight=100000000]
    accessLevelModifierR2C4 -> accessLevelModifierR3C4 [weight=100000000]
    accessLevelModifierR1C4 -> accessLevelModifierR2C4 [weight=100000000]
    accessLevelModifierR0C4 -> accessLevelModifierR1C4 [weight=100000000]
    accessLevelModifierR0C5 [label = <EDO<br/>ALT <br/>fi ["internal"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C5 [label = <EDP<br/>T "internal"<br/>fi ["internal"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C5 [label = <EDQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C5 -> accessLevelModifierR2C5 [weight=100000000]
    accessLevelModifierR0C5 -> accessLevelModifierR1C5 [weight=100000000]
    accessLevelModifierR0C6 [label = <EDR<br/>ALT <br/>fi ["internal"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C6 [label = <EDS<br/>T "internal"<br/>fi ["internal"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C6 [label = <EDT<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C6 [label = <EDU<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C6 [label = <EDV<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C6 [label = <EDW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C6 -> accessLevelModifierR5C6 [weight=100000000]
    accessLevelModifierR3C6 -> accessLevelModifierR4C6 [weight=100000000]
    accessLevelModifierR2C6 -> accessLevelModifierR3C6 [weight=100000000]
    accessLevelModifierR1C6 -> accessLevelModifierR2C6 [weight=100000000]
    accessLevelModifierR0C6 -> accessLevelModifierR1C6 [weight=100000000]
    accessLevelModifierR0C7 [label = <EDX<br/>ALT <br/>fi ["package"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C7 [label = <EDY<br/>T "package"<br/>fi ["package"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C7 [label = <EDZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C7 -> accessLevelModifierR2C7 [weight=100000000]
    accessLevelModifierR0C7 -> accessLevelModifierR1C7 [weight=100000000]
    accessLevelModifierR0C8 [label = <EEA<br/>ALT <br/>fi ["package"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C8 [label = <EEB<br/>T "package"<br/>fi ["package"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C8 [label = <EEC<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C8 [label = <EED<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C8 [label = <EEE<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C8 [label = <EEF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C8 -> accessLevelModifierR5C8 [weight=100000000]
    accessLevelModifierR3C8 -> accessLevelModifierR4C8 [weight=100000000]
    accessLevelModifierR2C8 -> accessLevelModifierR3C8 [weight=100000000]
    accessLevelModifierR1C8 -> accessLevelModifierR2C8 [weight=100000000]
    accessLevelModifierR0C8 -> accessLevelModifierR1C8 [weight=100000000]
    accessLevelModifierR0C9 [label = <EEG<br/>ALT <br/>fi ["public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C9 [label = <EEH<br/>T "public"<br/>fi ["public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C9 [label = <EEI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C9 -> accessLevelModifierR2C9 [weight=100000000]
    accessLevelModifierR0C9 -> accessLevelModifierR1C9 [weight=100000000]
    accessLevelModifierR0C10 [label = <EEJ<br/>ALT <br/>fi ["public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C10 [label = <EEK<br/>T "public"<br/>fi ["public"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C10 [label = <EEL<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C10 [label = <EEM<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C10 [label = <EEN<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C10 [label = <EEO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C10 -> accessLevelModifierR5C10 [weight=100000000]
    accessLevelModifierR3C10 -> accessLevelModifierR4C10 [weight=100000000]
    accessLevelModifierR2C10 -> accessLevelModifierR3C10 [weight=100000000]
    accessLevelModifierR1C10 -> accessLevelModifierR2C10 [weight=100000000]
    accessLevelModifierR0C10 -> accessLevelModifierR1C10 [weight=100000000]
    accessLevelModifierR0C11 [label = <EEP<br/>ALT <br/>fi ["open"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C11 [label = <EEQ<br/>T "open"<br/>fi ["open"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR2C11 [label = <EER<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C11 -> accessLevelModifierR2C11 [weight=100000000]
    accessLevelModifierR0C11 -> accessLevelModifierR1C11 [weight=100000000]
    accessLevelModifierR0C12 [label = <EES<br/>ALT <br/>fi ["open"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR1C12 [label = <EET<br/>T "open"<br/>fi ["open"]<br/>fo ["("]<br/>am []<br/>>]
    accessLevelModifierR2C12 [label = <EEU<br/>T "("<br/>fi ["("]<br/>fo ["set"]<br/>am []<br/>>]
    accessLevelModifierR3C12 [label = <EEV<br/>T "set"<br/>fi ["set"]<br/>fo [")"]<br/>am []<br/>>]
    accessLevelModifierR4C12 [label = <EEW<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR5C12 [label = <EEX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "actor", "associatedtype", "break", "class", "continue", "convenience", "defer", "do", "dynamic", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "guard", "if", "implicitParameterName", "indirect", "infix", "init", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "while", "}"]<br/>am []<br/>>]
    accessLevelModifierR4C12 -> accessLevelModifierR5C12 [weight=100000000]
    accessLevelModifierR3C12 -> accessLevelModifierR4C12 [weight=100000000]
    accessLevelModifierR2C12 -> accessLevelModifierR3C12 [weight=100000000]
    accessLevelModifierR1C12 -> accessLevelModifierR2C12 [weight=100000000]
    accessLevelModifierR0C12 -> accessLevelModifierR1C12 [weight=100000000]
    rank = same {accessLevelModifierR0C11 -> accessLevelModifierR0C12}
    rank = same {accessLevelModifierR0C10 -> accessLevelModifierR0C11}
    rank = same {accessLevelModifierR0C9 -> accessLevelModifierR0C10}
    rank = same {accessLevelModifierR0C8 -> accessLevelModifierR0C9}
    rank = same {accessLevelModifierR0C7 -> accessLevelModifierR0C8}
    rank = same {accessLevelModifierR0C6 -> accessLevelModifierR0C7}
    rank = same {accessLevelModifierR0C5 -> accessLevelModifierR0C6}
    rank = same {accessLevelModifierR0C4 -> accessLevelModifierR0C5}
    rank = same {accessLevelModifierR0C3 -> accessLevelModifierR0C4}
    rank = same {accessLevelModifierR0C2 -> accessLevelModifierR0C3}
    rank = same {accessLevelModifierR0C1 -> accessLevelModifierR0C2}
    rank = same {accessLevelModifierR0C0 -> accessLevelModifierR0C1}
    node [style = invis]
    edge [style = invis]
    accessLevelModifierR0C0 -> accessLevelModifierR1C0 [weight=100000000]
    rank = same {accessLevelModifierR1C0 -> accessLevelModifierR1C1}
    accessLevelModifierR1C0 -> accessLevelModifierR2C0 [weight=100000000]
    rank = same {accessLevelModifierR2C0 -> accessLevelModifierR2C1}
    accessLevelModifierR2C0 -> accessLevelModifierR3C0 [weight=100000000]
    accessLevelModifierR2C1 -> accessLevelModifierR3C1 [weight=100000000]
    rank = same {accessLevelModifierR3C0 -> accessLevelModifierR3C1}
    rank = same {accessLevelModifierR3C1 -> accessLevelModifierR3C2}
    accessLevelModifierR2C3 -> accessLevelModifierR3C3 [weight=100000000]
    rank = same {accessLevelModifierR3C2 -> accessLevelModifierR3C3}
    rank = same {accessLevelModifierR3C3 -> accessLevelModifierR3C4}
    accessLevelModifierR2C5 -> accessLevelModifierR3C5 [weight=100000000]
    rank = same {accessLevelModifierR3C4 -> accessLevelModifierR3C5}
    rank = same {accessLevelModifierR3C5 -> accessLevelModifierR3C6}
    accessLevelModifierR2C7 -> accessLevelModifierR3C7 [weight=100000000]
    rank = same {accessLevelModifierR3C6 -> accessLevelModifierR3C7}
    rank = same {accessLevelModifierR3C7 -> accessLevelModifierR3C8}
    accessLevelModifierR2C9 -> accessLevelModifierR3C9 [weight=100000000]
    rank = same {accessLevelModifierR3C8 -> accessLevelModifierR3C9}
    rank = same {accessLevelModifierR3C9 -> accessLevelModifierR3C10}
    accessLevelModifierR2C11 -> accessLevelModifierR3C11 [weight=100000000]
    rank = same {accessLevelModifierR3C10 -> accessLevelModifierR3C11}
    rank = same {accessLevelModifierR3C11 -> accessLevelModifierR3C12}
    accessLevelModifierR3C0 -> accessLevelModifierR4C0 [weight=100000000]
    accessLevelModifierR3C1 -> accessLevelModifierR4C1 [weight=100000000]
    rank = same {accessLevelModifierR4C0 -> accessLevelModifierR4C1}
    rank = same {accessLevelModifierR4C1 -> accessLevelModifierR4C2}
    accessLevelModifierR3C3 -> accessLevelModifierR4C3 [weight=100000000]
    rank = same {accessLevelModifierR4C2 -> accessLevelModifierR4C3}
    rank = same {accessLevelModifierR4C3 -> accessLevelModifierR4C4}
    accessLevelModifierR3C5 -> accessLevelModifierR4C5 [weight=100000000]
    rank = same {accessLevelModifierR4C4 -> accessLevelModifierR4C5}
    rank = same {accessLevelModifierR4C5 -> accessLevelModifierR4C6}
    accessLevelModifierR3C7 -> accessLevelModifierR4C7 [weight=100000000]
    rank = same {accessLevelModifierR4C6 -> accessLevelModifierR4C7}
    rank = same {accessLevelModifierR4C7 -> accessLevelModifierR4C8}
    accessLevelModifierR3C9 -> accessLevelModifierR4C9 [weight=100000000]
    rank = same {accessLevelModifierR4C8 -> accessLevelModifierR4C9}
    rank = same {accessLevelModifierR4C9 -> accessLevelModifierR4C10}
    accessLevelModifierR3C11 -> accessLevelModifierR4C11 [weight=100000000]
    rank = same {accessLevelModifierR4C10 -> accessLevelModifierR4C11}
    rank = same {accessLevelModifierR4C11 -> accessLevelModifierR4C12}
    accessLevelModifierR4C0 -> accessLevelModifierR5C0 [weight=100000000]
    accessLevelModifierR4C1 -> accessLevelModifierR5C1 [weight=100000000]
    rank = same {accessLevelModifierR5C0 -> accessLevelModifierR5C1}
    rank = same {accessLevelModifierR5C1 -> accessLevelModifierR5C2}
    accessLevelModifierR4C3 -> accessLevelModifierR5C3 [weight=100000000]
    rank = same {accessLevelModifierR5C2 -> accessLevelModifierR5C3}
    rank = same {accessLevelModifierR5C3 -> accessLevelModifierR5C4}
    accessLevelModifierR4C5 -> accessLevelModifierR5C5 [weight=100000000]
    rank = same {accessLevelModifierR5C4 -> accessLevelModifierR5C5}
    rank = same {accessLevelModifierR5C5 -> accessLevelModifierR5C6}
    accessLevelModifierR4C7 -> accessLevelModifierR5C7 [weight=100000000]
    rank = same {accessLevelModifierR5C6 -> accessLevelModifierR5C7}
    rank = same {accessLevelModifierR5C7 -> accessLevelModifierR5C8}
    accessLevelModifierR4C9 -> accessLevelModifierR5C9 [weight=100000000]
    rank = same {accessLevelModifierR5C8 -> accessLevelModifierR5C9}
    rank = same {accessLevelModifierR5C9 -> accessLevelModifierR5C10}
    accessLevelModifierR4C11 -> accessLevelModifierR5C11 [weight=100000000]
    rank = same {accessLevelModifierR5C10 -> accessLevelModifierR5C11}
    rank = same {accessLevelModifierR5C11 -> accessLevelModifierR5C12}
  }
  subgraph clusterprecedenceGroupAttributes {
    node [shape = box]
    label = <precedenceGroupAttributes = precedenceGroupAttribute [ precedenceGroupAttributes ] .>
    labeljust = l
    precedenceGroupAttributesR0C0 [label = <DXW<br/>N precedenceGroupAttributes<br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR0C1 [label = <DXP<br/>ALT <br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR1C1 [label = <DXQ<br/>N precedenceGroupAttribute<br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributesR2C1 [label = <DXU<br/>OPT <br/>fi ["", "assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR3C1 [label = <DXV<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR2C1 -> precedenceGroupAttributesR3C1 [weight=100000000]
    precedenceGroupAttributesR2C2 [label = <DXS<br/>ALT <br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR3C2 [label = <DXR<br/>N precedenceGroupAttributes<br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR4C2 [label = <DXT<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupAttributesR3C2 -> precedenceGroupAttributesR4C2 [weight=100000000]
    precedenceGroupAttributesR2C2 -> precedenceGroupAttributesR3C2 [weight=100000000]
    rank = same {precedenceGroupAttributesR2C1 -> precedenceGroupAttributesR2C2}
    precedenceGroupAttributesR1C1 -> precedenceGroupAttributesR2C1 [weight=100000000]
    precedenceGroupAttributesR0C1 -> precedenceGroupAttributesR1C1 [weight=100000000]
    rank = same {precedenceGroupAttributesR0C0 -> precedenceGroupAttributesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {precedenceGroupAttributesR0C1 -> precedenceGroupAttributesR0C2}
    precedenceGroupAttributesR0C0 -> precedenceGroupAttributesR1C0 [weight=100000000]
    rank = same {precedenceGroupAttributesR1C0 -> precedenceGroupAttributesR1C1}
    precedenceGroupAttributesR0C2 -> precedenceGroupAttributesR1C2 [weight=100000000]
    rank = same {precedenceGroupAttributesR1C1 -> precedenceGroupAttributesR1C2}
    precedenceGroupAttributesR1C0 -> precedenceGroupAttributesR2C0 [weight=100000000]
    rank = same {precedenceGroupAttributesR2C0 -> precedenceGroupAttributesR2C1}
    precedenceGroupAttributesR1C2 -> precedenceGroupAttributesR2C2 [weight=100000000]
    precedenceGroupAttributesR2C0 -> precedenceGroupAttributesR3C0 [weight=100000000]
    rank = same {precedenceGroupAttributesR3C0 -> precedenceGroupAttributesR3C1}
    precedenceGroupAttributesR3C0 -> precedenceGroupAttributesR4C0 [weight=100000000]
    precedenceGroupAttributesR3C1 -> precedenceGroupAttributesR4C1 [weight=100000000]
    rank = same {precedenceGroupAttributesR4C0 -> precedenceGroupAttributesR4C1}
    rank = same {precedenceGroupAttributesR4C1 -> precedenceGroupAttributesR4C2}
  }
  subgraph clustercatchPatternList {
    node [shape = box]
    label = <catchPatternList = catchPattern | catchPattern "," catchPatternList .>
    labeljust = l
    catchPatternListR0C0 [label = <BLD<br/>N catchPatternList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>>]
    catchPatternListR0C1 [label = <BKV<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR1C1 [label = <BKW<br/>N catchPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR2C1 [label = <BKX<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR1C1 -> catchPatternListR2C1 [weight=100000000]
    catchPatternListR0C1 -> catchPatternListR1C1 [weight=100000000]
    catchPatternListR0C2 [label = <BKY<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR1C2 [label = <BKZ<br/>N catchPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [","]<br/>am []<br/>>]
    catchPatternListR2C2 [label = <BLA<br/>T ","<br/>fi [","]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var", "{"]<br/>am []<br/>>]
    catchPatternListR3C2 [label = <BLB<br/>N catchPatternList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR4C2 [label = <BLC<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    catchPatternListR3C2 -> catchPatternListR4C2 [weight=100000000]
    catchPatternListR2C2 -> catchPatternListR3C2 [weight=100000000]
    catchPatternListR1C2 -> catchPatternListR2C2 [weight=100000000]
    catchPatternListR0C2 -> catchPatternListR1C2 [weight=100000000]
    rank = same {catchPatternListR0C1 -> catchPatternListR0C2}
    rank = same {catchPatternListR0C0 -> catchPatternListR0C1}
    node [style = invis]
    edge [style = invis]
    catchPatternListR0C0 -> catchPatternListR1C0 [weight=100000000]
    rank = same {catchPatternListR1C0 -> catchPatternListR1C1}
    catchPatternListR1C0 -> catchPatternListR2C0 [weight=100000000]
    rank = same {catchPatternListR2C0 -> catchPatternListR2C1}
    catchPatternListR2C0 -> catchPatternListR3C0 [weight=100000000]
    catchPatternListR2C1 -> catchPatternListR3C1 [weight=100000000]
    rank = same {catchPatternListR3C0 -> catchPatternListR3C1}
    rank = same {catchPatternListR3C1 -> catchPatternListR3C2}
    catchPatternListR3C0 -> catchPatternListR4C0 [weight=100000000]
    catchPatternListR3C1 -> catchPatternListR4C1 [weight=100000000]
    rank = same {catchPatternListR4C0 -> catchPatternListR4C1}
    rank = same {catchPatternListR4C1 -> catchPatternListR4C2}
  }
  subgraph clusterargumentNames {
    node [shape = box]
    label = <argumentNames = argumentName [ argumentNames ] .>
    labeljust = l
    argumentNamesR0C0 [label = <ATN<br/>N argumentNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR0C1 [label = <ATG<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR1C1 [label = <ATH<br/>N argumentName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    argumentNamesR2C1 [label = <ATL<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR3C1 [label = <ATM<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR2C1 -> argumentNamesR3C1 [weight=100000000]
    argumentNamesR2C2 [label = <ATJ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR3C2 [label = <ATI<br/>N argumentNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR4C2 [label = <ATK<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    argumentNamesR3C2 -> argumentNamesR4C2 [weight=100000000]
    argumentNamesR2C2 -> argumentNamesR3C2 [weight=100000000]
    rank = same {argumentNamesR2C1 -> argumentNamesR2C2}
    argumentNamesR1C1 -> argumentNamesR2C1 [weight=100000000]
    argumentNamesR0C1 -> argumentNamesR1C1 [weight=100000000]
    rank = same {argumentNamesR0C0 -> argumentNamesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {argumentNamesR0C1 -> argumentNamesR0C2}
    argumentNamesR0C0 -> argumentNamesR1C0 [weight=100000000]
    rank = same {argumentNamesR1C0 -> argumentNamesR1C1}
    argumentNamesR0C2 -> argumentNamesR1C2 [weight=100000000]
    rank = same {argumentNamesR1C1 -> argumentNamesR1C2}
    argumentNamesR1C0 -> argumentNamesR2C0 [weight=100000000]
    rank = same {argumentNamesR2C0 -> argumentNamesR2C1}
    argumentNamesR1C2 -> argumentNamesR2C2 [weight=100000000]
    argumentNamesR2C0 -> argumentNamesR3C0 [weight=100000000]
    rank = same {argumentNamesR3C0 -> argumentNamesR3C1}
    argumentNamesR3C0 -> argumentNamesR4C0 [weight=100000000]
    argumentNamesR3C1 -> argumentNamesR4C1 [weight=100000000]
    rank = same {argumentNamesR4C0 -> argumentNamesR4C1}
    rank = same {argumentNamesR4C1 -> argumentNamesR4C2}
  }
  subgraph clusteroptionalChainingExpression {
    node [shape = box]
    label = <optionalChainingExpression = postfixExpression "?" .>
    labeljust = l
    optionalChainingExpressionR0C0 [label = <AUP<br/>N optionalChainingExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalChainingExpressionR0C1 [label = <AUL<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalChainingExpressionR1C1 [label = <AUM<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["?"]<br/>am []<br/>>]
    optionalChainingExpressionR2C1 [label = <AUN<br/>T "?"<br/>fi ["?"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalChainingExpressionR3C1 [label = <AUO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalChainingExpressionR2C1 -> optionalChainingExpressionR3C1 [weight=100000000]
    optionalChainingExpressionR1C1 -> optionalChainingExpressionR2C1 [weight=100000000]
    optionalChainingExpressionR0C1 -> optionalChainingExpressionR1C1 [weight=100000000]
    rank = same {optionalChainingExpressionR0C0 -> optionalChainingExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    optionalChainingExpressionR0C0 -> optionalChainingExpressionR1C0 [weight=100000000]
    rank = same {optionalChainingExpressionR1C0 -> optionalChainingExpressionR1C1}
    optionalChainingExpressionR1C0 -> optionalChainingExpressionR2C0 [weight=100000000]
    rank = same {optionalChainingExpressionR2C0 -> optionalChainingExpressionR2C1}
    optionalChainingExpressionR2C0 -> optionalChainingExpressionR3C0 [weight=100000000]
    rank = same {optionalChainingExpressionR3C0 -> optionalChainingExpressionR3C1}
  }
  subgraph clusterprecedenceGroupRelation {
    node [shape = box]
    label = <precedenceGroupRelation = "higherThan" ":" precedenceGroupNames | "lowerThan" ":" precedenceGroupNames .>
    labeljust = l
    precedenceGroupRelationR0C0 [label = <DYM<br/>N precedenceGroupRelation<br/>fi ["higherThan", "lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR0C1 [label = <DYH<br/>ALT <br/>fi ["higherThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR1C1 [label = <DYI<br/>T "higherThan"<br/>fi ["higherThan"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupRelationR2C1 [label = <DYJ<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    precedenceGroupRelationR3C1 [label = <DYK<br/>N precedenceGroupNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR4C1 [label = <DYL<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR3C1 -> precedenceGroupRelationR4C1 [weight=100000000]
    precedenceGroupRelationR2C1 -> precedenceGroupRelationR3C1 [weight=100000000]
    precedenceGroupRelationR1C1 -> precedenceGroupRelationR2C1 [weight=100000000]
    precedenceGroupRelationR0C1 -> precedenceGroupRelationR1C1 [weight=100000000]
    precedenceGroupRelationR0C2 [label = <DYN<br/>ALT <br/>fi ["lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR1C2 [label = <DYO<br/>T "lowerThan"<br/>fi ["lowerThan"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupRelationR2C2 [label = <DYP<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    precedenceGroupRelationR3C2 [label = <DYQ<br/>N precedenceGroupNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR4C2 [label = <DYR<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupRelationR3C2 -> precedenceGroupRelationR4C2 [weight=100000000]
    precedenceGroupRelationR2C2 -> precedenceGroupRelationR3C2 [weight=100000000]
    precedenceGroupRelationR1C2 -> precedenceGroupRelationR2C2 [weight=100000000]
    precedenceGroupRelationR0C2 -> precedenceGroupRelationR1C2 [weight=100000000]
    rank = same {precedenceGroupRelationR0C1 -> precedenceGroupRelationR0C2}
    rank = same {precedenceGroupRelationR0C0 -> precedenceGroupRelationR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupRelationR0C0 -> precedenceGroupRelationR1C0 [weight=100000000]
    rank = same {precedenceGroupRelationR1C0 -> precedenceGroupRelationR1C1}
    precedenceGroupRelationR1C0 -> precedenceGroupRelationR2C0 [weight=100000000]
    rank = same {precedenceGroupRelationR2C0 -> precedenceGroupRelationR2C1}
    precedenceGroupRelationR2C0 -> precedenceGroupRelationR3C0 [weight=100000000]
    rank = same {precedenceGroupRelationR3C0 -> precedenceGroupRelationR3C1}
    precedenceGroupRelationR3C0 -> precedenceGroupRelationR4C0 [weight=100000000]
    rank = same {precedenceGroupRelationR4C0 -> precedenceGroupRelationR4C1}
  }
  subgraph clustertupleTypeElementList {
    node [shape = box]
    label = <tupleTypeElementList = tupleTypeElement | tupleTypeElement "," tupleTypeElementList .>
    labeljust = l
    tupleTypeElementListR0C0 [label = <HQ<br/>N tupleTypeElementList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>>]
    tupleTypeElementListR0C1 [label = <HI<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR1C1 [label = <HJ<br/>N tupleTypeElement<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR2C1 [label = <HK<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR1C1 -> tupleTypeElementListR2C1 [weight=100000000]
    tupleTypeElementListR0C1 -> tupleTypeElementListR1C1 [weight=100000000]
    tupleTypeElementListR0C2 [label = <HL<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR1C2 [label = <HM<br/>N tupleTypeElement<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [","]<br/>am []<br/>>]
    tupleTypeElementListR2C2 [label = <HN<br/>T ","<br/>fi [","]<br/>fo ["(", ")", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    tupleTypeElementListR3C2 [label = <HO<br/>N tupleTypeElementList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR4C2 [label = <HP<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeElementListR3C2 -> tupleTypeElementListR4C2 [weight=100000000]
    tupleTypeElementListR2C2 -> tupleTypeElementListR3C2 [weight=100000000]
    tupleTypeElementListR1C2 -> tupleTypeElementListR2C2 [weight=100000000]
    tupleTypeElementListR0C2 -> tupleTypeElementListR1C2 [weight=100000000]
    rank = same {tupleTypeElementListR0C1 -> tupleTypeElementListR0C2}
    rank = same {tupleTypeElementListR0C0 -> tupleTypeElementListR0C1}
    node [style = invis]
    edge [style = invis]
    tupleTypeElementListR0C0 -> tupleTypeElementListR1C0 [weight=100000000]
    rank = same {tupleTypeElementListR1C0 -> tupleTypeElementListR1C1}
    tupleTypeElementListR1C0 -> tupleTypeElementListR2C0 [weight=100000000]
    rank = same {tupleTypeElementListR2C0 -> tupleTypeElementListR2C1}
    tupleTypeElementListR2C0 -> tupleTypeElementListR3C0 [weight=100000000]
    tupleTypeElementListR2C1 -> tupleTypeElementListR3C1 [weight=100000000]
    rank = same {tupleTypeElementListR3C0 -> tupleTypeElementListR3C1}
    rank = same {tupleTypeElementListR3C1 -> tupleTypeElementListR3C2}
    tupleTypeElementListR3C0 -> tupleTypeElementListR4C0 [weight=100000000]
    tupleTypeElementListR3C1 -> tupleTypeElementListR4C1 [weight=100000000]
    rank = same {tupleTypeElementListR4C0 -> tupleTypeElementListR4C1}
    rank = same {tupleTypeElementListR4C1 -> tupleTypeElementListR4C2}
  }
  subgraph clustertypeCastingPattern {
    node [shape = box]
    label = <typeCastingPattern = isPattern | asPattern .>
    labeljust = l
    typeCastingPatternR0C0 [label = <EMW<br/>N typeCastingPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "is", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    typeCastingPatternR0C1 [label = <EMQ<br/>ALT <br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingPatternR1C1 [label = <EMR<br/>N isPattern<br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingPatternR2C1 [label = <EMS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingPatternR1C1 -> typeCastingPatternR2C1 [weight=100000000]
    typeCastingPatternR0C1 -> typeCastingPatternR1C1 [weight=100000000]
    typeCastingPatternR0C2 [label = <EMT<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    typeCastingPatternR1C2 [label = <EMU<br/>N asPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    typeCastingPatternR2C2 [label = <EMV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingPatternR1C2 -> typeCastingPatternR2C2 [weight=100000000]
    typeCastingPatternR0C2 -> typeCastingPatternR1C2 [weight=100000000]
    rank = same {typeCastingPatternR0C1 -> typeCastingPatternR0C2}
    rank = same {typeCastingPatternR0C0 -> typeCastingPatternR0C1}
    node [style = invis]
    edge [style = invis]
    typeCastingPatternR0C0 -> typeCastingPatternR1C0 [weight=100000000]
    rank = same {typeCastingPatternR1C0 -> typeCastingPatternR1C1}
    typeCastingPatternR1C0 -> typeCastingPatternR2C0 [weight=100000000]
    rank = same {typeCastingPatternR2C0 -> typeCastingPatternR2C1}
  }
  subgraph clusterwildcardExpression {
    node [shape = box]
    label = <wildcardExpression = "_" .>
    labeljust = l
    wildcardExpressionR0C0 [label = <AKA<br/>N wildcardExpression<br/>fi ["_"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardExpressionR0C1 [label = <AJX<br/>ALT <br/>fi ["_"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardExpressionR1C1 [label = <AJY<br/>T "_"<br/>fi ["_"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardExpressionR2C1 [label = <AJZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    wildcardExpressionR1C1 -> wildcardExpressionR2C1 [weight=100000000]
    wildcardExpressionR0C1 -> wildcardExpressionR1C1 [weight=100000000]
    rank = same {wildcardExpressionR0C0 -> wildcardExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    wildcardExpressionR0C0 -> wildcardExpressionR1C0 [weight=100000000]
    rank = same {wildcardExpressionR1C0 -> wildcardExpressionR1C1}
    wildcardExpressionR1C0 -> wildcardExpressionR2C0 [weight=100000000]
    rank = same {wildcardExpressionR2C0 -> wildcardExpressionR2C1}
  }
  subgraph clusterswitchExpressionCase {
    node [shape = box]
    label = <switchExpressionCase = caseLabel statement | defaultLabel statement .>
    labeljust = l
    switchExpressionCaseR0C0 [label = <ACU<br/>N switchExpressionCase<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR0C1 [label = <ACQ<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR1C1 [label = <ACR<br/>N caseLabel<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR2C1 [label = <ACS<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR3C1 [label = <ACT<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    switchExpressionCaseR2C1 -> switchExpressionCaseR3C1 [weight=100000000]
    switchExpressionCaseR1C1 -> switchExpressionCaseR2C1 [weight=100000000]
    switchExpressionCaseR0C1 -> switchExpressionCaseR1C1 [weight=100000000]
    switchExpressionCaseR0C2 [label = <ACV<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR1C2 [label = <ACW<br/>N defaultLabel<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR2C2 [label = <ACX<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCaseR3C2 [label = <ACY<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    switchExpressionCaseR2C2 -> switchExpressionCaseR3C2 [weight=100000000]
    switchExpressionCaseR1C2 -> switchExpressionCaseR2C2 [weight=100000000]
    switchExpressionCaseR0C2 -> switchExpressionCaseR1C2 [weight=100000000]
    rank = same {switchExpressionCaseR0C1 -> switchExpressionCaseR0C2}
    rank = same {switchExpressionCaseR0C0 -> switchExpressionCaseR0C1}
    node [style = invis]
    edge [style = invis]
    switchExpressionCaseR0C0 -> switchExpressionCaseR1C0 [weight=100000000]
    rank = same {switchExpressionCaseR1C0 -> switchExpressionCaseR1C1}
    switchExpressionCaseR1C0 -> switchExpressionCaseR2C0 [weight=100000000]
    rank = same {switchExpressionCaseR2C0 -> switchExpressionCaseR2C1}
    switchExpressionCaseR2C0 -> switchExpressionCaseR3C0 [weight=100000000]
    rank = same {switchExpressionCaseR3C0 -> switchExpressionCaseR3C1}
  }
  subgraph clusterawaitOperator {
    node [shape = box]
    label = <awaitOperator = "await" .>
    labeljust = l
    awaitOperatorR0C0 [label = <QB<br/>N awaitOperator<br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    awaitOperatorR0C1 [label = <PY<br/>ALT <br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    awaitOperatorR1C1 [label = <PZ<br/>T "await"<br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    awaitOperatorR2C1 [label = <QA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    awaitOperatorR1C1 -> awaitOperatorR2C1 [weight=100000000]
    awaitOperatorR0C1 -> awaitOperatorR1C1 [weight=100000000]
    rank = same {awaitOperatorR0C0 -> awaitOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    awaitOperatorR0C0 -> awaitOperatorR1C0 [weight=100000000]
    rank = same {awaitOperatorR1C0 -> awaitOperatorR1C1}
    awaitOperatorR1C0 -> awaitOperatorR2C0 [weight=100000000]
    rank = same {awaitOperatorR2C0 -> awaitOperatorR2C1}
  }
  subgraph clusterinitializerExpression {
    node [shape = box]
    label = <initializerExpression = postfixExpression "." "init" | postfixExpression "." "init" "(" argumentNames ")" .>
    labeljust = l
    initializerExpressionR0C0 [label = <ARW<br/>N initializerExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>>]
    initializerExpressionR0C1 [label = <ARR<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR1C1 [label = <ARS<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    initializerExpressionR2C1 [label = <ART<br/>T "."<br/>fi ["."]<br/>fo ["init"]<br/>am []<br/>>]
    initializerExpressionR3C1 [label = <ARU<br/>T "init"<br/>fi ["init"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR4C1 [label = <ARV<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR3C1 -> initializerExpressionR4C1 [weight=100000000]
    initializerExpressionR2C1 -> initializerExpressionR3C1 [weight=100000000]
    initializerExpressionR1C1 -> initializerExpressionR2C1 [weight=100000000]
    initializerExpressionR0C1 -> initializerExpressionR1C1 [weight=100000000]
    initializerExpressionR0C2 [label = <ARX<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR1C2 [label = <ARY<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["."]<br/>am []<br/>>]
    initializerExpressionR2C2 [label = <ARZ<br/>T "."<br/>fi ["."]<br/>fo ["init"]<br/>am []<br/>>]
    initializerExpressionR3C2 [label = <ASA<br/>T "init"<br/>fi ["init"]<br/>fo ["("]<br/>am []<br/>>]
    initializerExpressionR4C2 [label = <ASB<br/>T "("<br/>fi ["("]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    initializerExpressionR5C2 [label = <ASC<br/>N argumentNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    initializerExpressionR6C2 [label = <ASD<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR7C2 [label = <ASE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    initializerExpressionR6C2 -> initializerExpressionR7C2 [weight=100000000]
    initializerExpressionR5C2 -> initializerExpressionR6C2 [weight=100000000]
    initializerExpressionR4C2 -> initializerExpressionR5C2 [weight=100000000]
    initializerExpressionR3C2 -> initializerExpressionR4C2 [weight=100000000]
    initializerExpressionR2C2 -> initializerExpressionR3C2 [weight=100000000]
    initializerExpressionR1C2 -> initializerExpressionR2C2 [weight=100000000]
    initializerExpressionR0C2 -> initializerExpressionR1C2 [weight=100000000]
    rank = same {initializerExpressionR0C1 -> initializerExpressionR0C2}
    rank = same {initializerExpressionR0C0 -> initializerExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    initializerExpressionR0C0 -> initializerExpressionR1C0 [weight=100000000]
    rank = same {initializerExpressionR1C0 -> initializerExpressionR1C1}
    initializerExpressionR1C0 -> initializerExpressionR2C0 [weight=100000000]
    rank = same {initializerExpressionR2C0 -> initializerExpressionR2C1}
    initializerExpressionR2C0 -> initializerExpressionR3C0 [weight=100000000]
    rank = same {initializerExpressionR3C0 -> initializerExpressionR3C1}
    initializerExpressionR3C0 -> initializerExpressionR4C0 [weight=100000000]
    rank = same {initializerExpressionR4C0 -> initializerExpressionR4C1}
    initializerExpressionR4C0 -> initializerExpressionR5C0 [weight=100000000]
    initializerExpressionR4C1 -> initializerExpressionR5C1 [weight=100000000]
    rank = same {initializerExpressionR5C0 -> initializerExpressionR5C1}
    rank = same {initializerExpressionR5C1 -> initializerExpressionR5C2}
    initializerExpressionR5C0 -> initializerExpressionR6C0 [weight=100000000]
    initializerExpressionR5C1 -> initializerExpressionR6C1 [weight=100000000]
    rank = same {initializerExpressionR6C0 -> initializerExpressionR6C1}
    rank = same {initializerExpressionR6C1 -> initializerExpressionR6C2}
    initializerExpressionR6C0 -> initializerExpressionR7C0 [weight=100000000]
    initializerExpressionR6C1 -> initializerExpressionR7C1 [weight=100000000]
    rank = same {initializerExpressionR7C0 -> initializerExpressionR7C1}
    rank = same {initializerExpressionR7C1 -> initializerExpressionR7C2}
  }
  subgraph clusterkeyPathComponents {
    node [shape = box]
    label = <keyPathComponents = keyPathComponent | keyPathComponent "." keyPathComponents .>
    labeljust = l
    keyPathComponentsR0C0 [label = <ALK<br/>N keyPathComponents<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>>]
    keyPathComponentsR0C1 [label = <ALC<br/>ALT <br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR1C1 [label = <ALD<br/>N keyPathComponent<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR2C1 [label = <ALE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR1C1 -> keyPathComponentsR2C1 [weight=100000000]
    keyPathComponentsR0C1 -> keyPathComponentsR1C1 [weight=100000000]
    keyPathComponentsR0C2 [label = <ALF<br/>ALT <br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR1C2 [label = <ALG<br/>N keyPathComponent<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["."]<br/>am []<br/>>]
    keyPathComponentsR2C2 [label = <ALH<br/>T "."<br/>fi ["."]<br/>fo ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    keyPathComponentsR3C2 [label = <ALI<br/>N keyPathComponents<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR4C2 [label = <ALJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentsR3C2 -> keyPathComponentsR4C2 [weight=100000000]
    keyPathComponentsR2C2 -> keyPathComponentsR3C2 [weight=100000000]
    keyPathComponentsR1C2 -> keyPathComponentsR2C2 [weight=100000000]
    keyPathComponentsR0C2 -> keyPathComponentsR1C2 [weight=100000000]
    rank = same {keyPathComponentsR0C1 -> keyPathComponentsR0C2}
    rank = same {keyPathComponentsR0C0 -> keyPathComponentsR0C1}
    node [style = invis]
    edge [style = invis]
    keyPathComponentsR0C0 -> keyPathComponentsR1C0 [weight=100000000]
    rank = same {keyPathComponentsR1C0 -> keyPathComponentsR1C1}
    keyPathComponentsR1C0 -> keyPathComponentsR2C0 [weight=100000000]
    rank = same {keyPathComponentsR2C0 -> keyPathComponentsR2C1}
    keyPathComponentsR2C0 -> keyPathComponentsR3C0 [weight=100000000]
    keyPathComponentsR2C1 -> keyPathComponentsR3C1 [weight=100000000]
    rank = same {keyPathComponentsR3C0 -> keyPathComponentsR3C1}
    rank = same {keyPathComponentsR3C1 -> keyPathComponentsR3C2}
    keyPathComponentsR3C0 -> keyPathComponentsR4C0 [weight=100000000]
    keyPathComponentsR3C1 -> keyPathComponentsR4C1 [weight=100000000]
    rank = same {keyPathComponentsR4C0 -> keyPathComponentsR4C1}
    rank = same {keyPathComponentsR4C1 -> keyPathComponentsR4C2}
  }
  subgraph clusterdefaultLabel {
    node [shape = box]
    label = <defaultLabel = [ attributes ] "default" ":" .>
    labeljust = l
    defaultLabelR0C0 [label = <BEK<br/>N defaultLabel<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    defaultLabelR0C1 [label = <BEC<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    defaultLabelR1C1 [label = <BEG<br/>OPT <br/>fi ["", "@"]<br/>fo ["default"]<br/>am []<br/>>]
    defaultLabelR2C1 [label = <BEH<br/>T "default"<br/>fi ["default"]<br/>fo [":"]<br/>am []<br/>>]
    defaultLabelR3C1 [label = <BEI<br/>T ":"<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    defaultLabelR4C1 [label = <BEJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    defaultLabelR3C1 -> defaultLabelR4C1 [weight=100000000]
    defaultLabelR2C1 -> defaultLabelR3C1 [weight=100000000]
    defaultLabelR1C1 -> defaultLabelR2C1 [weight=100000000]
    defaultLabelR1C2 [label = <BEE<br/>ALT <br/>fi ["@"]<br/>fo ["default"]<br/>am []<br/>>]
    defaultLabelR2C2 [label = <BED<br/>N attributes<br/>fi ["@"]<br/>fo ["default"]<br/>am []<br/>>]
    defaultLabelR3C2 [label = <BEF<br/>END <br/>fi [""]<br/>fo ["default"]<br/>am []<br/>>]
    defaultLabelR2C2 -> defaultLabelR3C2 [weight=100000000]
    defaultLabelR1C2 -> defaultLabelR2C2 [weight=100000000]
    rank = same {defaultLabelR1C1 -> defaultLabelR1C2}
    defaultLabelR0C1 -> defaultLabelR1C1 [weight=100000000]
    rank = same {defaultLabelR0C0 -> defaultLabelR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {defaultLabelR0C1 -> defaultLabelR0C2}
    defaultLabelR0C0 -> defaultLabelR1C0 [weight=100000000]
    rank = same {defaultLabelR1C0 -> defaultLabelR1C1}
    defaultLabelR0C2 -> defaultLabelR1C2 [weight=100000000]
    defaultLabelR1C0 -> defaultLabelR2C0 [weight=100000000]
    rank = same {defaultLabelR2C0 -> defaultLabelR2C1}
    defaultLabelR2C0 -> defaultLabelR3C0 [weight=100000000]
    rank = same {defaultLabelR3C0 -> defaultLabelR3C1}
    defaultLabelR3C0 -> defaultLabelR4C0 [weight=100000000]
    rank = same {defaultLabelR4C0 -> defaultLabelR4C1}
    defaultLabelR3C2 -> defaultLabelR4C2 [weight=100000000]
    rank = same {defaultLabelR4C1 -> defaultLabelR4C2}
  }
  subgraph clusterkeyPathPostfixes {
    node [shape = box]
    label = <keyPathPostfixes = keyPathPostfix [ keyPathPostfixes ] .>
    labeljust = l
    keyPathPostfixesR0C0 [label = <AMD<br/>N keyPathPostfixes<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR0C1 [label = <ALW<br/>ALT <br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR1C1 [label = <ALX<br/>N keyPathPostfix<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR2C1 [label = <AMB<br/>OPT <br/>fi ["", "!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["!", "?", "["]<br/>>]
    keyPathPostfixesR3C1 [label = <AMC<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR2C1 -> keyPathPostfixesR3C1 [weight=100000000]
    keyPathPostfixesR2C2 [label = <ALZ<br/>ALT <br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR3C2 [label = <ALY<br/>N keyPathPostfixes<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR4C2 [label = <AMA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixesR3C2 -> keyPathPostfixesR4C2 [weight=100000000]
    keyPathPostfixesR2C2 -> keyPathPostfixesR3C2 [weight=100000000]
    rank = same {keyPathPostfixesR2C1 -> keyPathPostfixesR2C2}
    keyPathPostfixesR1C1 -> keyPathPostfixesR2C1 [weight=100000000]
    keyPathPostfixesR0C1 -> keyPathPostfixesR1C1 [weight=100000000]
    rank = same {keyPathPostfixesR0C0 -> keyPathPostfixesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {keyPathPostfixesR0C1 -> keyPathPostfixesR0C2}
    keyPathPostfixesR0C0 -> keyPathPostfixesR1C0 [weight=100000000]
    rank = same {keyPathPostfixesR1C0 -> keyPathPostfixesR1C1}
    keyPathPostfixesR0C2 -> keyPathPostfixesR1C2 [weight=100000000]
    rank = same {keyPathPostfixesR1C1 -> keyPathPostfixesR1C2}
    keyPathPostfixesR1C0 -> keyPathPostfixesR2C0 [weight=100000000]
    rank = same {keyPathPostfixesR2C0 -> keyPathPostfixesR2C1}
    keyPathPostfixesR1C2 -> keyPathPostfixesR2C2 [weight=100000000]
    keyPathPostfixesR2C0 -> keyPathPostfixesR3C0 [weight=100000000]
    rank = same {keyPathPostfixesR3C0 -> keyPathPostfixesR3C1}
    keyPathPostfixesR3C0 -> keyPathPostfixesR4C0 [weight=100000000]
    keyPathPostfixesR3C1 -> keyPathPostfixesR4C1 [weight=100000000]
    rank = same {keyPathPostfixesR4C0 -> keyPathPostfixesR4C1}
    rank = same {keyPathPostfixesR4C1 -> keyPathPostfixesR4C2}
  }
  subgraph clusterparameterClause {
    node [shape = box]
    label = <parameterClause = "(" ")" | "(" parameterList ")" .>
    labeljust = l
    parameterClauseR0C0 [label = <CPM<br/>N parameterClause<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    parameterClauseR0C1 [label = <CPD<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR1C1 [label = <CPE<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    parameterClauseR2C1 [label = <CPF<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR3C1 [label = <CPG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR2C1 -> parameterClauseR3C1 [weight=100000000]
    parameterClauseR1C1 -> parameterClauseR2C1 [weight=100000000]
    parameterClauseR0C1 -> parameterClauseR1C1 [weight=100000000]
    parameterClauseR0C2 [label = <CPH<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR1C2 [label = <CPI<br/>T "("<br/>fi ["("]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterClauseR2C2 [label = <CPJ<br/>N parameterList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    parameterClauseR3C2 [label = <CPK<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR4C2 [label = <CPL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "=", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "rethrows", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parameterClauseR3C2 -> parameterClauseR4C2 [weight=100000000]
    parameterClauseR2C2 -> parameterClauseR3C2 [weight=100000000]
    parameterClauseR1C2 -> parameterClauseR2C2 [weight=100000000]
    parameterClauseR0C2 -> parameterClauseR1C2 [weight=100000000]
    rank = same {parameterClauseR0C1 -> parameterClauseR0C2}
    rank = same {parameterClauseR0C0 -> parameterClauseR0C1}
    node [style = invis]
    edge [style = invis]
    parameterClauseR0C0 -> parameterClauseR1C0 [weight=100000000]
    rank = same {parameterClauseR1C0 -> parameterClauseR1C1}
    parameterClauseR1C0 -> parameterClauseR2C0 [weight=100000000]
    rank = same {parameterClauseR2C0 -> parameterClauseR2C1}
    parameterClauseR2C0 -> parameterClauseR3C0 [weight=100000000]
    rank = same {parameterClauseR3C0 -> parameterClauseR3C1}
    parameterClauseR3C0 -> parameterClauseR4C0 [weight=100000000]
    parameterClauseR3C1 -> parameterClauseR4C1 [weight=100000000]
    rank = same {parameterClauseR4C0 -> parameterClauseR4C1}
    rank = same {parameterClauseR4C1 -> parameterClauseR4C2}
  }
  subgraph clusterrawValueLiteral {
    node [shape = box]
    label = <rawValueLiteral = numericLiteral | "staticStringLiteral" | booleanLiteral .>
    labeljust = l
    rawValueLiteralR0C0 [label = <CZJ<br/>N rawValueLiteral<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral", "staticStringLiteral", "true"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR0C1 [label = <CZA<br/>ALT <br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C1 [label = <CZB<br/>N numericLiteral<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR2C1 [label = <CZC<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C1 -> rawValueLiteralR2C1 [weight=100000000]
    rawValueLiteralR0C1 -> rawValueLiteralR1C1 [weight=100000000]
    rawValueLiteralR0C2 [label = <CZD<br/>ALT <br/>fi ["staticStringLiteral"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C2 [label = <CZE<br/>T "staticStringLiteral"<br/>fi ["staticStringLiteral"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR2C2 [label = <CZF<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C2 -> rawValueLiteralR2C2 [weight=100000000]
    rawValueLiteralR0C2 -> rawValueLiteralR1C2 [weight=100000000]
    rawValueLiteralR0C3 [label = <CZG<br/>ALT <br/>fi ["false", "true"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C3 [label = <CZH<br/>N booleanLiteral<br/>fi ["false", "true"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR2C3 [label = <CZI<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueLiteralR1C3 -> rawValueLiteralR2C3 [weight=100000000]
    rawValueLiteralR0C3 -> rawValueLiteralR1C3 [weight=100000000]
    rank = same {rawValueLiteralR0C2 -> rawValueLiteralR0C3}
    rank = same {rawValueLiteralR0C1 -> rawValueLiteralR0C2}
    rank = same {rawValueLiteralR0C0 -> rawValueLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    rawValueLiteralR0C0 -> rawValueLiteralR1C0 [weight=100000000]
    rank = same {rawValueLiteralR1C0 -> rawValueLiteralR1C1}
    rawValueLiteralR1C0 -> rawValueLiteralR2C0 [weight=100000000]
    rank = same {rawValueLiteralR2C0 -> rawValueLiteralR2C1}
  }
  subgraph clusterfallthroughStatement {
    node [shape = box]
    label = <fallthroughStatement = "fallthrough" .>
    labeljust = l
    fallthroughStatementR0C0 [label = <BIY<br/>N fallthroughStatement<br/>fi ["fallthrough"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    fallthroughStatementR0C1 [label = <BIV<br/>ALT <br/>fi ["fallthrough"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    fallthroughStatementR1C1 [label = <BIW<br/>T "fallthrough"<br/>fi ["fallthrough"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    fallthroughStatementR2C1 [label = <BIX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    fallthroughStatementR1C1 -> fallthroughStatementR2C1 [weight=100000000]
    fallthroughStatementR0C1 -> fallthroughStatementR1C1 [weight=100000000]
    rank = same {fallthroughStatementR0C0 -> fallthroughStatementR0C1}
    node [style = invis]
    edge [style = invis]
    fallthroughStatementR0C0 -> fallthroughStatementR1C0 [weight=100000000]
    rank = same {fallthroughStatementR1C0 -> fallthroughStatementR1C1}
    fallthroughStatementR1C0 -> fallthroughStatementR2C0 [weight=100000000]
    rank = same {fallthroughStatementR2C0 -> fallthroughStatementR2C1}
  }
  subgraph clusterkeyPathStringExpression {
    node [shape = box]
    label = <keyPathStringExpression = "#keyPath" "(" expression ")" .>
    labeljust = l
    keyPathStringExpressionR0C0 [label = <ANU<br/>N keyPathStringExpression<br/>fi ["#keyPath"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathStringExpressionR0C1 [label = <ANO<br/>ALT <br/>fi ["#keyPath"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathStringExpressionR1C1 [label = <ANP<br/>T "#keyPath"<br/>fi ["#keyPath"]<br/>fo ["("]<br/>am []<br/>>]
    keyPathStringExpressionR2C1 [label = <ANQ<br/>T "("<br/>fi ["("]<br/>fo [")", "try"]<br/>am []<br/>>]
    keyPathStringExpressionR3C1 [label = <ANR<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    keyPathStringExpressionR4C1 [label = <ANS<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathStringExpressionR5C1 [label = <ANT<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathStringExpressionR4C1 -> keyPathStringExpressionR5C1 [weight=100000000]
    keyPathStringExpressionR3C1 -> keyPathStringExpressionR4C1 [weight=100000000]
    keyPathStringExpressionR2C1 -> keyPathStringExpressionR3C1 [weight=100000000]
    keyPathStringExpressionR1C1 -> keyPathStringExpressionR2C1 [weight=100000000]
    keyPathStringExpressionR0C1 -> keyPathStringExpressionR1C1 [weight=100000000]
    rank = same {keyPathStringExpressionR0C0 -> keyPathStringExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    keyPathStringExpressionR0C0 -> keyPathStringExpressionR1C0 [weight=100000000]
    rank = same {keyPathStringExpressionR1C0 -> keyPathStringExpressionR1C1}
    keyPathStringExpressionR1C0 -> keyPathStringExpressionR2C0 [weight=100000000]
    rank = same {keyPathStringExpressionR2C0 -> keyPathStringExpressionR2C1}
    keyPathStringExpressionR2C0 -> keyPathStringExpressionR3C0 [weight=100000000]
    rank = same {keyPathStringExpressionR3C0 -> keyPathStringExpressionR3C1}
    keyPathStringExpressionR3C0 -> keyPathStringExpressionR4C0 [weight=100000000]
    rank = same {keyPathStringExpressionR4C0 -> keyPathStringExpressionR4C1}
    keyPathStringExpressionR4C0 -> keyPathStringExpressionR5C0 [weight=100000000]
    rank = same {keyPathStringExpressionR5C0 -> keyPathStringExpressionR5C1}
  }
  subgraph clusterargumentLabel {
    node [shape = box]
    label = <argumentLabel = identifier .>
    labeljust = l
    argumentLabelR0C0 [label = <KL<br/>N argumentLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    argumentLabelR0C1 [label = <KI<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    argumentLabelR1C1 [label = <KJ<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    argumentLabelR2C1 [label = <KK<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    argumentLabelR1C1 -> argumentLabelR2C1 [weight=100000000]
    argumentLabelR0C1 -> argumentLabelR1C1 [weight=100000000]
    rank = same {argumentLabelR0C0 -> argumentLabelR0C1}
    node [style = invis]
    edge [style = invis]
    argumentLabelR0C0 -> argumentLabelR1C0 [weight=100000000]
    rank = same {argumentLabelR1C0 -> argumentLabelR1C1}
    argumentLabelR1C0 -> argumentLabelR2C0 [weight=100000000]
    rank = same {argumentLabelR2C0 -> argumentLabelR2C1}
  }
  subgraph clusterprotocolSubscriptDeclaration {
    node [shape = box]
    label = <protocolSubscriptDeclaration = subscriptHead subscriptResult [ genericWhereClause ] getterSetterKeywordBlock .>
    labeljust = l
    protocolSubscriptDeclarationR0C0 [label = <DLT<br/>N protocolSubscriptDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolSubscriptDeclarationR0C1 [label = <DLK<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolSubscriptDeclarationR1C1 [label = <DLL<br/>N subscriptHead<br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR2C1 [label = <DLM<br/>N subscriptResult<br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR3C1 [label = <DLQ<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR4C1 [label = <DLR<br/>N getterSetterKeywordBlock<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR5C1 [label = <DLS<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR4C1 -> protocolSubscriptDeclarationR5C1 [weight=100000000]
    protocolSubscriptDeclarationR3C1 -> protocolSubscriptDeclarationR4C1 [weight=100000000]
    protocolSubscriptDeclarationR3C2 [label = <DLO<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR4C2 [label = <DLN<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR5C2 [label = <DLP<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    protocolSubscriptDeclarationR4C2 -> protocolSubscriptDeclarationR5C2 [weight=100000000]
    protocolSubscriptDeclarationR3C2 -> protocolSubscriptDeclarationR4C2 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR3C1 -> protocolSubscriptDeclarationR3C2}
    protocolSubscriptDeclarationR2C1 -> protocolSubscriptDeclarationR3C1 [weight=100000000]
    protocolSubscriptDeclarationR1C1 -> protocolSubscriptDeclarationR2C1 [weight=100000000]
    protocolSubscriptDeclarationR0C1 -> protocolSubscriptDeclarationR1C1 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR0C0 -> protocolSubscriptDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolSubscriptDeclarationR0C1 -> protocolSubscriptDeclarationR0C2}
    protocolSubscriptDeclarationR0C0 -> protocolSubscriptDeclarationR1C0 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR1C0 -> protocolSubscriptDeclarationR1C1}
    protocolSubscriptDeclarationR0C2 -> protocolSubscriptDeclarationR1C2 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR1C1 -> protocolSubscriptDeclarationR1C2}
    protocolSubscriptDeclarationR1C0 -> protocolSubscriptDeclarationR2C0 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR2C0 -> protocolSubscriptDeclarationR2C1}
    protocolSubscriptDeclarationR1C2 -> protocolSubscriptDeclarationR2C2 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR2C1 -> protocolSubscriptDeclarationR2C2}
    protocolSubscriptDeclarationR2C0 -> protocolSubscriptDeclarationR3C0 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR3C0 -> protocolSubscriptDeclarationR3C1}
    protocolSubscriptDeclarationR2C2 -> protocolSubscriptDeclarationR3C2 [weight=100000000]
    protocolSubscriptDeclarationR3C0 -> protocolSubscriptDeclarationR4C0 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR4C0 -> protocolSubscriptDeclarationR4C1}
    protocolSubscriptDeclarationR4C0 -> protocolSubscriptDeclarationR5C0 [weight=100000000]
    rank = same {protocolSubscriptDeclarationR5C0 -> protocolSubscriptDeclarationR5C1}
  }
  subgraph clusteravailabilityArguments {
    node [shape = box]
    label = <availabilityArguments = availabilityArgument | availabilityArgument "," availabilityArguments .>
    labeljust = l
    availabilityArgumentsR0C0 [label = <BVV<br/>N availabilityArguments<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>>]
    availabilityArgumentsR0C1 [label = <BVN<br/>ALT <br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR1C1 [label = <BVO<br/>N availabilityArgument<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR2C1 [label = <BVP<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR1C1 -> availabilityArgumentsR2C1 [weight=100000000]
    availabilityArgumentsR0C1 -> availabilityArgumentsR1C1 [weight=100000000]
    availabilityArgumentsR0C2 [label = <BVQ<br/>ALT <br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR1C2 [label = <BVR<br/>N availabilityArgument<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [","]<br/>am []<br/>>]
    availabilityArgumentsR2C2 [label = <BVS<br/>T ","<br/>fi [","]<br/>fo ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>am []<br/>>]
    availabilityArgumentsR3C2 [label = <BVT<br/>N availabilityArguments<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR4C2 [label = <BVU<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    availabilityArgumentsR3C2 -> availabilityArgumentsR4C2 [weight=100000000]
    availabilityArgumentsR2C2 -> availabilityArgumentsR3C2 [weight=100000000]
    availabilityArgumentsR1C2 -> availabilityArgumentsR2C2 [weight=100000000]
    availabilityArgumentsR0C2 -> availabilityArgumentsR1C2 [weight=100000000]
    rank = same {availabilityArgumentsR0C1 -> availabilityArgumentsR0C2}
    rank = same {availabilityArgumentsR0C0 -> availabilityArgumentsR0C1}
    node [style = invis]
    edge [style = invis]
    availabilityArgumentsR0C0 -> availabilityArgumentsR1C0 [weight=100000000]
    rank = same {availabilityArgumentsR1C0 -> availabilityArgumentsR1C1}
    availabilityArgumentsR1C0 -> availabilityArgumentsR2C0 [weight=100000000]
    rank = same {availabilityArgumentsR2C0 -> availabilityArgumentsR2C1}
    availabilityArgumentsR2C0 -> availabilityArgumentsR3C0 [weight=100000000]
    availabilityArgumentsR2C1 -> availabilityArgumentsR3C1 [weight=100000000]
    rank = same {availabilityArgumentsR3C0 -> availabilityArgumentsR3C1}
    rank = same {availabilityArgumentsR3C1 -> availabilityArgumentsR3C2}
    availabilityArgumentsR3C0 -> availabilityArgumentsR4C0 [weight=100000000]
    availabilityArgumentsR3C1 -> availabilityArgumentsR4C1 [weight=100000000]
    rank = same {availabilityArgumentsR4C0 -> availabilityArgumentsR4C1}
    rank = same {availabilityArgumentsR4C1 -> availabilityArgumentsR4C2}
  }
  subgraph clustercompilerControlStatement {
    node [shape = box]
    label = <compilerControlStatement = conditionalCompilationBlock | lineControlStatement | diagnosticStatement .>
    labeljust = l
    compilerControlStatementR0C0 [label = <BLP<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR0C1 [label = <BLM<br/>ALT <br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C1 [label = <BLN<br/>N conditionalCompilationBlock<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR2C1 [label = <BLO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C1 -> compilerControlStatementR2C1 [weight=100000000]
    compilerControlStatementR0C1 -> compilerControlStatementR1C1 [weight=100000000]
    compilerControlStatementR0C2 [label = <BLQ<br/>ALT <br/>fi ["#sourceLocation"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C2 [label = <BLR<br/>N lineControlStatement<br/>fi ["#sourceLocation"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR2C2 [label = <BLS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C2 -> compilerControlStatementR2C2 [weight=100000000]
    compilerControlStatementR0C2 -> compilerControlStatementR1C2 [weight=100000000]
    compilerControlStatementR0C3 [label = <BLT<br/>ALT <br/>fi ["#error", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C3 [label = <BLU<br/>N diagnosticStatement<br/>fi ["#error", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR2C3 [label = <BLV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    compilerControlStatementR1C3 -> compilerControlStatementR2C3 [weight=100000000]
    compilerControlStatementR0C3 -> compilerControlStatementR1C3 [weight=100000000]
    rank = same {compilerControlStatementR0C2 -> compilerControlStatementR0C3}
    rank = same {compilerControlStatementR0C1 -> compilerControlStatementR0C2}
    rank = same {compilerControlStatementR0C0 -> compilerControlStatementR0C1}
    node [style = invis]
    edge [style = invis]
    compilerControlStatementR0C0 -> compilerControlStatementR1C0 [weight=100000000]
    rank = same {compilerControlStatementR1C0 -> compilerControlStatementR1C1}
    compilerControlStatementR1C0 -> compilerControlStatementR2C0 [weight=100000000]
    rank = same {compilerControlStatementR2C0 -> compilerControlStatementR2C1}
  }
  subgraph clustervariableDeclaration {
    node [shape = box]
    label = <variableDeclaration = variableDeclarationHead patternInitializerList | variableDeclarationHead variableName typeAnnotation codeBlock | variableDeclarationHead variableName typeAnnotation getterSetterBlock | variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock | variableDeclarationHead variableName initializer willSetDidSetBlock | variableDeclarationHead variableName typeAnnotation [ initializer ] willSetDidSetBlock .>
    labeljust = l
    variableDeclarationR0C0 [label = <CDT<br/>N variableDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR0C1 [label = <CDP<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C1 [label = <CDQ<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR2C1 [label = <CDR<br/>N patternInitializerList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    variableDeclarationR3C1 [label = <CDS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR2C1 -> variableDeclarationR3C1 [weight=100000000]
    variableDeclarationR1C1 -> variableDeclarationR2C1 [weight=100000000]
    variableDeclarationR0C1 -> variableDeclarationR1C1 [weight=100000000]
    variableDeclarationR0C2 [label = <CDU<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C2 [label = <CDV<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    variableDeclarationR2C2 [label = <CDW<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    variableDeclarationR3C2 [label = <CDX<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR4C2 [label = <CDY<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR5C2 [label = <CDZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR4C2 -> variableDeclarationR5C2 [weight=100000000]
    variableDeclarationR3C2 -> variableDeclarationR4C2 [weight=100000000]
    variableDeclarationR2C2 -> variableDeclarationR3C2 [weight=100000000]
    variableDeclarationR1C2 -> variableDeclarationR2C2 [weight=100000000]
    variableDeclarationR0C2 -> variableDeclarationR1C2 [weight=100000000]
    variableDeclarationR0C3 [label = <CEA<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C3 [label = <CEB<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    variableDeclarationR2C3 [label = <CEC<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    variableDeclarationR3C3 [label = <CED<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR4C3 [label = <CEE<br/>N getterSetterBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR5C3 [label = <CEF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR4C3 -> variableDeclarationR5C3 [weight=100000000]
    variableDeclarationR3C3 -> variableDeclarationR4C3 [weight=100000000]
    variableDeclarationR2C3 -> variableDeclarationR3C3 [weight=100000000]
    variableDeclarationR1C3 -> variableDeclarationR2C3 [weight=100000000]
    variableDeclarationR0C3 -> variableDeclarationR1C3 [weight=100000000]
    variableDeclarationR0C4 [label = <CEG<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C4 [label = <CEH<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    variableDeclarationR2C4 [label = <CEI<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    variableDeclarationR3C4 [label = <CEJ<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR4C4 [label = <CEK<br/>N getterSetterKeywordBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR5C4 [label = <CEL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR4C4 -> variableDeclarationR5C4 [weight=100000000]
    variableDeclarationR3C4 -> variableDeclarationR4C4 [weight=100000000]
    variableDeclarationR2C4 -> variableDeclarationR3C4 [weight=100000000]
    variableDeclarationR1C4 -> variableDeclarationR2C4 [weight=100000000]
    variableDeclarationR0C4 -> variableDeclarationR1C4 [weight=100000000]
    variableDeclarationR0C5 [label = <CEM<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C5 [label = <CEN<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    variableDeclarationR2C5 [label = <CEO<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["="]<br/>am []<br/>>]
    variableDeclarationR3C5 [label = <CEP<br/>N initializer<br/>fi ["="]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR4C5 [label = <CEQ<br/>N willSetDidSetBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR5C5 [label = <CER<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR4C5 -> variableDeclarationR5C5 [weight=100000000]
    variableDeclarationR3C5 -> variableDeclarationR4C5 [weight=100000000]
    variableDeclarationR2C5 -> variableDeclarationR3C5 [weight=100000000]
    variableDeclarationR1C5 -> variableDeclarationR2C5 [weight=100000000]
    variableDeclarationR0C5 -> variableDeclarationR1C5 [weight=100000000]
    variableDeclarationR0C6 [label = <CES<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    variableDeclarationR1C6 [label = <CET<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    variableDeclarationR2C6 [label = <CEU<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    variableDeclarationR3C6 [label = <CEV<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["=", "{"]<br/>am []<br/>>]
    variableDeclarationR4C6 [label = <CEZ<br/>OPT <br/>fi ["", "="]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR5C6 [label = <CFA<br/>N willSetDidSetBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR6C6 [label = <CFB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    variableDeclarationR5C6 -> variableDeclarationR6C6 [weight=100000000]
    variableDeclarationR4C6 -> variableDeclarationR5C6 [weight=100000000]
    variableDeclarationR4C7 [label = <CEX<br/>ALT <br/>fi ["="]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR5C7 [label = <CEW<br/>N initializer<br/>fi ["="]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR6C7 [label = <CEY<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    variableDeclarationR5C7 -> variableDeclarationR6C7 [weight=100000000]
    variableDeclarationR4C7 -> variableDeclarationR5C7 [weight=100000000]
    rank = same {variableDeclarationR4C6 -> variableDeclarationR4C7}
    variableDeclarationR3C6 -> variableDeclarationR4C6 [weight=100000000]
    variableDeclarationR2C6 -> variableDeclarationR3C6 [weight=100000000]
    variableDeclarationR1C6 -> variableDeclarationR2C6 [weight=100000000]
    variableDeclarationR0C6 -> variableDeclarationR1C6 [weight=100000000]
    rank = same {variableDeclarationR0C5 -> variableDeclarationR0C6}
    rank = same {variableDeclarationR0C4 -> variableDeclarationR0C5}
    rank = same {variableDeclarationR0C3 -> variableDeclarationR0C4}
    rank = same {variableDeclarationR0C2 -> variableDeclarationR0C3}
    rank = same {variableDeclarationR0C1 -> variableDeclarationR0C2}
    rank = same {variableDeclarationR0C0 -> variableDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {variableDeclarationR0C6 -> variableDeclarationR0C7}
    variableDeclarationR0C0 -> variableDeclarationR1C0 [weight=100000000]
    rank = same {variableDeclarationR1C0 -> variableDeclarationR1C1}
    variableDeclarationR0C7 -> variableDeclarationR1C7 [weight=100000000]
    rank = same {variableDeclarationR1C6 -> variableDeclarationR1C7}
    variableDeclarationR1C0 -> variableDeclarationR2C0 [weight=100000000]
    rank = same {variableDeclarationR2C0 -> variableDeclarationR2C1}
    variableDeclarationR1C7 -> variableDeclarationR2C7 [weight=100000000]
    rank = same {variableDeclarationR2C6 -> variableDeclarationR2C7}
    variableDeclarationR2C0 -> variableDeclarationR3C0 [weight=100000000]
    rank = same {variableDeclarationR3C0 -> variableDeclarationR3C1}
    variableDeclarationR2C7 -> variableDeclarationR3C7 [weight=100000000]
    rank = same {variableDeclarationR3C6 -> variableDeclarationR3C7}
    variableDeclarationR3C0 -> variableDeclarationR4C0 [weight=100000000]
    variableDeclarationR3C1 -> variableDeclarationR4C1 [weight=100000000]
    rank = same {variableDeclarationR4C0 -> variableDeclarationR4C1}
    rank = same {variableDeclarationR4C1 -> variableDeclarationR4C2}
    variableDeclarationR3C7 -> variableDeclarationR4C7 [weight=100000000]
    variableDeclarationR4C0 -> variableDeclarationR5C0 [weight=100000000]
    variableDeclarationR4C1 -> variableDeclarationR5C1 [weight=100000000]
    rank = same {variableDeclarationR5C0 -> variableDeclarationR5C1}
    rank = same {variableDeclarationR5C1 -> variableDeclarationR5C2}
    variableDeclarationR5C0 -> variableDeclarationR6C0 [weight=100000000]
    variableDeclarationR5C1 -> variableDeclarationR6C1 [weight=100000000]
    rank = same {variableDeclarationR6C0 -> variableDeclarationR6C1}
    variableDeclarationR5C2 -> variableDeclarationR6C2 [weight=100000000]
    rank = same {variableDeclarationR6C1 -> variableDeclarationR6C2}
    variableDeclarationR5C3 -> variableDeclarationR6C3 [weight=100000000]
    rank = same {variableDeclarationR6C2 -> variableDeclarationR6C3}
    variableDeclarationR5C4 -> variableDeclarationR6C4 [weight=100000000]
    rank = same {variableDeclarationR6C3 -> variableDeclarationR6C4}
    variableDeclarationR5C5 -> variableDeclarationR6C5 [weight=100000000]
    rank = same {variableDeclarationR6C4 -> variableDeclarationR6C5}
    rank = same {variableDeclarationR6C5 -> variableDeclarationR6C6}
  }
  subgraph clustercatchPattern {
    node [shape = box]
    label = <catchPattern = pattern [ whereClause ] .>
    labeljust = l
    catchPatternR0C0 [label = <BLL<br/>N catchPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR0C1 [label = <BLE<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR1C1 [label = <BLF<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "where", "{"]<br/>am []<br/>>]
    catchPatternR2C1 [label = <BLJ<br/>OPT <br/>fi ["", "where"]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR3C1 [label = <BLK<br/>END <br/>fi [""]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR2C1 -> catchPatternR3C1 [weight=100000000]
    catchPatternR2C2 [label = <BLH<br/>ALT <br/>fi ["where"]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR3C2 [label = <BLG<br/>N whereClause<br/>fi ["where"]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR4C2 [label = <BLI<br/>END <br/>fi [""]<br/>fo [",", "{"]<br/>am []<br/>>]
    catchPatternR3C2 -> catchPatternR4C2 [weight=100000000]
    catchPatternR2C2 -> catchPatternR3C2 [weight=100000000]
    rank = same {catchPatternR2C1 -> catchPatternR2C2}
    catchPatternR1C1 -> catchPatternR2C1 [weight=100000000]
    catchPatternR0C1 -> catchPatternR1C1 [weight=100000000]
    rank = same {catchPatternR0C0 -> catchPatternR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {catchPatternR0C1 -> catchPatternR0C2}
    catchPatternR0C0 -> catchPatternR1C0 [weight=100000000]
    rank = same {catchPatternR1C0 -> catchPatternR1C1}
    catchPatternR0C2 -> catchPatternR1C2 [weight=100000000]
    rank = same {catchPatternR1C1 -> catchPatternR1C2}
    catchPatternR1C0 -> catchPatternR2C0 [weight=100000000]
    rank = same {catchPatternR2C0 -> catchPatternR2C1}
    catchPatternR1C2 -> catchPatternR2C2 [weight=100000000]
    catchPatternR2C0 -> catchPatternR3C0 [weight=100000000]
    rank = same {catchPatternR3C0 -> catchPatternR3C1}
    catchPatternR3C0 -> catchPatternR4C0 [weight=100000000]
    catchPatternR3C1 -> catchPatternR4C1 [weight=100000000]
    rank = same {catchPatternR4C0 -> catchPatternR4C1}
    rank = same {catchPatternR4C1 -> catchPatternR4C2}
  }
  subgraph clusterforcedValueExpression {
    node [shape = box]
    label = <forcedValueExpression = postfixExpression "!" .>
    labeljust = l
    forcedValueExpressionR0C0 [label = <AUK<br/>N forcedValueExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    forcedValueExpressionR0C1 [label = <AUG<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    forcedValueExpressionR1C1 [label = <AUH<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!"]<br/>am []<br/>>]
    forcedValueExpressionR2C1 [label = <AUI<br/>T "!"<br/>fi ["!"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    forcedValueExpressionR3C1 [label = <AUJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    forcedValueExpressionR2C1 -> forcedValueExpressionR3C1 [weight=100000000]
    forcedValueExpressionR1C1 -> forcedValueExpressionR2C1 [weight=100000000]
    forcedValueExpressionR0C1 -> forcedValueExpressionR1C1 [weight=100000000]
    rank = same {forcedValueExpressionR0C0 -> forcedValueExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    forcedValueExpressionR0C0 -> forcedValueExpressionR1C0 [weight=100000000]
    rank = same {forcedValueExpressionR1C0 -> forcedValueExpressionR1C1}
    forcedValueExpressionR1C0 -> forcedValueExpressionR2C0 [weight=100000000]
    rank = same {forcedValueExpressionR2C0 -> forcedValueExpressionR2C1}
    forcedValueExpressionR2C0 -> forcedValueExpressionR3C0 [weight=100000000]
    rank = same {forcedValueExpressionR3C0 -> forcedValueExpressionR3C1}
  }
  subgraph clustercaptureListItems {
    node [shape = box]
    label = <captureListItems = captureListItem | captureListItem "," captureListItems .>
    labeljust = l
    captureListItemsR0C0 [label = <AGQ<br/>N captureListItems<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am ["unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>>]
    captureListItemsR0C1 [label = <AGI<br/>ALT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR1C1 [label = <AGJ<br/>N captureListItem<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR2C1 [label = <AGK<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR1C1 -> captureListItemsR2C1 [weight=100000000]
    captureListItemsR0C1 -> captureListItemsR1C1 [weight=100000000]
    captureListItemsR0C2 [label = <AGL<br/>ALT <br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR1C2 [label = <AGM<br/>N captureListItem<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo [","]<br/>am []<br/>>]
    captureListItemsR2C2 [label = <AGN<br/>T ","<br/>fi [","]<br/>fo ["]", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>am []<br/>>]
    captureListItemsR3C2 [label = <AGO<br/>N captureListItems<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR4C2 [label = <AGP<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    captureListItemsR3C2 -> captureListItemsR4C2 [weight=100000000]
    captureListItemsR2C2 -> captureListItemsR3C2 [weight=100000000]
    captureListItemsR1C2 -> captureListItemsR2C2 [weight=100000000]
    captureListItemsR0C2 -> captureListItemsR1C2 [weight=100000000]
    rank = same {captureListItemsR0C1 -> captureListItemsR0C2}
    rank = same {captureListItemsR0C0 -> captureListItemsR0C1}
    node [style = invis]
    edge [style = invis]
    captureListItemsR0C0 -> captureListItemsR1C0 [weight=100000000]
    rank = same {captureListItemsR1C0 -> captureListItemsR1C1}
    captureListItemsR1C0 -> captureListItemsR2C0 [weight=100000000]
    rank = same {captureListItemsR2C0 -> captureListItemsR2C1}
    captureListItemsR2C0 -> captureListItemsR3C0 [weight=100000000]
    captureListItemsR2C1 -> captureListItemsR3C1 [weight=100000000]
    rank = same {captureListItemsR3C0 -> captureListItemsR3C1}
    rank = same {captureListItemsR3C1 -> captureListItemsR3C2}
    captureListItemsR3C0 -> captureListItemsR4C0 [weight=100000000]
    captureListItemsR3C1 -> captureListItemsR4C1 [weight=100000000]
    rank = same {captureListItemsR4C0 -> captureListItemsR4C1}
    rank = same {captureListItemsR4C1 -> captureListItemsR4C2}
  }
  subgraph clustertypealiasName {
    node [shape = box]
    label = <typealiasName = identifier .>
    labeljust = l
    typealiasNameR0C0 [label = <CLX<br/>N typealiasName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ":", "&lt;", "=", "@", "where", "}"]<br/>am []<br/>>]
    typealiasNameR0C1 [label = <CLU<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ":", "&lt;", "=", "@", "where", "}"]<br/>am []<br/>>]
    typealiasNameR1C1 [label = <CLV<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ":", "&lt;", "=", "@", "where", "}"]<br/>am []<br/>>]
    typealiasNameR2C1 [label = <CLW<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ":", "&lt;", "=", "@", "where", "}"]<br/>am []<br/>>]
    typealiasNameR1C1 -> typealiasNameR2C1 [weight=100000000]
    typealiasNameR0C1 -> typealiasNameR1C1 [weight=100000000]
    rank = same {typealiasNameR0C0 -> typealiasNameR0C1}
    node [style = invis]
    edge [style = invis]
    typealiasNameR0C0 -> typealiasNameR1C0 [weight=100000000]
    rank = same {typealiasNameR1C0 -> typealiasNameR1C1}
    typealiasNameR1C0 -> typealiasNameR2C0 [weight=100000000]
    rank = same {typealiasNameR2C0 -> typealiasNameR2C1}
  }
  subgraph clusterunionStyleEnum {
    node [shape = box]
    label = <unionStyleEnum = [ "indirect" ] "enum" enumName [ genericParameterClause ] [ typeInheritanceClause ] [ genericWhereClause ] "{" [ unionStyleEnumMembers ] "}" .>
    labeljust = l
    unionStyleEnumR0C0 [label = <CUH<br/>N unionStyleEnum<br/>fi ["", "indirect"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    unionStyleEnumR0C1 [label = <CTH<br/>ALT <br/>fi ["", "indirect"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    unionStyleEnumR1C1 [label = <CTL<br/>OPT <br/>fi ["", "indirect"]<br/>fo ["enum"]<br/>am []<br/>>]
    unionStyleEnumR2C1 [label = <CTM<br/>T "enum"<br/>fi ["enum"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    unionStyleEnumR3C1 [label = <CTN<br/>N enumName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    unionStyleEnumR4C1 [label = <CTR<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    unionStyleEnumR5C1 [label = <CTV<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    unionStyleEnumR6C1 [label = <CTZ<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    unionStyleEnumR7C1 [label = <CUA<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    unionStyleEnumR8C1 [label = <CUE<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumR9C1 [label = <CUF<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    unionStyleEnumR10C1 [label = <CUG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    unionStyleEnumR9C1 -> unionStyleEnumR10C1 [weight=100000000]
    unionStyleEnumR8C1 -> unionStyleEnumR9C1 [weight=100000000]
    unionStyleEnumR8C2 [label = <CUC<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumR9C2 [label = <CUB<br/>N unionStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumR10C2 [label = <CUD<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumR9C2 -> unionStyleEnumR10C2 [weight=100000000]
    unionStyleEnumR8C2 -> unionStyleEnumR9C2 [weight=100000000]
    rank = same {unionStyleEnumR8C1 -> unionStyleEnumR8C2}
    unionStyleEnumR7C1 -> unionStyleEnumR8C1 [weight=100000000]
    unionStyleEnumR6C1 -> unionStyleEnumR7C1 [weight=100000000]
    unionStyleEnumR6C3 [label = <CTX<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    unionStyleEnumR7C3 [label = <CTW<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    unionStyleEnumR8C3 [label = <CTY<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    unionStyleEnumR7C3 -> unionStyleEnumR8C3 [weight=100000000]
    unionStyleEnumR6C3 -> unionStyleEnumR7C3 [weight=100000000]
    rank = same {unionStyleEnumR6C1 -> unionStyleEnumR6C3}
    unionStyleEnumR5C1 -> unionStyleEnumR6C1 [weight=100000000]
    unionStyleEnumR5C4 [label = <CTT<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    unionStyleEnumR6C4 [label = <CTS<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    unionStyleEnumR7C4 [label = <CTU<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    unionStyleEnumR6C4 -> unionStyleEnumR7C4 [weight=100000000]
    unionStyleEnumR5C4 -> unionStyleEnumR6C4 [weight=100000000]
    rank = same {unionStyleEnumR5C1 -> unionStyleEnumR5C4}
    unionStyleEnumR4C1 -> unionStyleEnumR5C1 [weight=100000000]
    unionStyleEnumR4C5 [label = <CTP<br/>ALT <br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    unionStyleEnumR5C5 [label = <CTO<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    unionStyleEnumR6C5 [label = <CTQ<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    unionStyleEnumR5C5 -> unionStyleEnumR6C5 [weight=100000000]
    unionStyleEnumR4C5 -> unionStyleEnumR5C5 [weight=100000000]
    rank = same {unionStyleEnumR4C1 -> unionStyleEnumR4C5}
    unionStyleEnumR3C1 -> unionStyleEnumR4C1 [weight=100000000]
    unionStyleEnumR2C1 -> unionStyleEnumR3C1 [weight=100000000]
    unionStyleEnumR1C1 -> unionStyleEnumR2C1 [weight=100000000]
    unionStyleEnumR1C6 [label = <CTJ<br/>ALT <br/>fi ["indirect"]<br/>fo ["enum"]<br/>am []<br/>>]
    unionStyleEnumR2C6 [label = <CTI<br/>T "indirect"<br/>fi ["indirect"]<br/>fo ["enum"]<br/>am []<br/>>]
    unionStyleEnumR3C6 [label = <CTK<br/>END <br/>fi [""]<br/>fo ["enum"]<br/>am []<br/>>]
    unionStyleEnumR2C6 -> unionStyleEnumR3C6 [weight=100000000]
    unionStyleEnumR1C6 -> unionStyleEnumR2C6 [weight=100000000]
    rank = same {unionStyleEnumR1C1 -> unionStyleEnumR1C6}
    unionStyleEnumR0C1 -> unionStyleEnumR1C1 [weight=100000000]
    rank = same {unionStyleEnumR0C0 -> unionStyleEnumR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {unionStyleEnumR0C1 -> unionStyleEnumR0C2}
    rank = same {unionStyleEnumR0C2 -> unionStyleEnumR0C3}
    rank = same {unionStyleEnumR0C3 -> unionStyleEnumR0C4}
    rank = same {unionStyleEnumR0C4 -> unionStyleEnumR0C5}
    rank = same {unionStyleEnumR0C5 -> unionStyleEnumR0C6}
    unionStyleEnumR0C0 -> unionStyleEnumR1C0 [weight=100000000]
    rank = same {unionStyleEnumR1C0 -> unionStyleEnumR1C1}
    unionStyleEnumR0C6 -> unionStyleEnumR1C6 [weight=100000000]
    unionStyleEnumR1C0 -> unionStyleEnumR2C0 [weight=100000000]
    rank = same {unionStyleEnumR2C0 -> unionStyleEnumR2C1}
    rank = same {unionStyleEnumR2C1 -> unionStyleEnumR2C2}
    rank = same {unionStyleEnumR2C2 -> unionStyleEnumR2C3}
    rank = same {unionStyleEnumR2C3 -> unionStyleEnumR2C4}
    rank = same {unionStyleEnumR2C4 -> unionStyleEnumR2C5}
    rank = same {unionStyleEnumR2C5 -> unionStyleEnumR2C6}
    unionStyleEnumR2C0 -> unionStyleEnumR3C0 [weight=100000000]
    rank = same {unionStyleEnumR3C0 -> unionStyleEnumR3C1}
    unionStyleEnumR2C2 -> unionStyleEnumR3C2 [weight=100000000]
    rank = same {unionStyleEnumR3C1 -> unionStyleEnumR3C2}
    unionStyleEnumR2C3 -> unionStyleEnumR3C3 [weight=100000000]
    rank = same {unionStyleEnumR3C2 -> unionStyleEnumR3C3}
    unionStyleEnumR2C4 -> unionStyleEnumR3C4 [weight=100000000]
    rank = same {unionStyleEnumR3C3 -> unionStyleEnumR3C4}
    unionStyleEnumR2C5 -> unionStyleEnumR3C5 [weight=100000000]
    rank = same {unionStyleEnumR3C4 -> unionStyleEnumR3C5}
    rank = same {unionStyleEnumR3C5 -> unionStyleEnumR3C6}
    unionStyleEnumR3C0 -> unionStyleEnumR4C0 [weight=100000000]
    rank = same {unionStyleEnumR4C0 -> unionStyleEnumR4C1}
    unionStyleEnumR3C5 -> unionStyleEnumR4C5 [weight=100000000]
    unionStyleEnumR3C6 -> unionStyleEnumR4C6 [weight=100000000]
    rank = same {unionStyleEnumR4C5 -> unionStyleEnumR4C6}
    unionStyleEnumR4C0 -> unionStyleEnumR5C0 [weight=100000000]
    rank = same {unionStyleEnumR5C0 -> unionStyleEnumR5C1}
    unionStyleEnumR4C6 -> unionStyleEnumR5C6 [weight=100000000]
    rank = same {unionStyleEnumR5C5 -> unionStyleEnumR5C6}
    unionStyleEnumR5C0 -> unionStyleEnumR6C0 [weight=100000000]
    rank = same {unionStyleEnumR6C0 -> unionStyleEnumR6C1}
    unionStyleEnumR5C6 -> unionStyleEnumR6C6 [weight=100000000]
    rank = same {unionStyleEnumR6C5 -> unionStyleEnumR6C6}
    unionStyleEnumR6C0 -> unionStyleEnumR7C0 [weight=100000000]
    rank = same {unionStyleEnumR7C0 -> unionStyleEnumR7C1}
    rank = same {unionStyleEnumR7C1 -> unionStyleEnumR7C2}
    rank = same {unionStyleEnumR7C2 -> unionStyleEnumR7C3}
    unionStyleEnumR6C5 -> unionStyleEnumR7C5 [weight=100000000]
    rank = same {unionStyleEnumR7C4 -> unionStyleEnumR7C5}
    unionStyleEnumR6C6 -> unionStyleEnumR7C6 [weight=100000000]
    rank = same {unionStyleEnumR7C5 -> unionStyleEnumR7C6}
    unionStyleEnumR7C0 -> unionStyleEnumR8C0 [weight=100000000]
    rank = same {unionStyleEnumR8C0 -> unionStyleEnumR8C1}
    unionStyleEnumR7C2 -> unionStyleEnumR8C2 [weight=100000000]
    unionStyleEnumR7C4 -> unionStyleEnumR8C4 [weight=100000000]
    rank = same {unionStyleEnumR8C3 -> unionStyleEnumR8C4}
    unionStyleEnumR7C5 -> unionStyleEnumR8C5 [weight=100000000]
    rank = same {unionStyleEnumR8C4 -> unionStyleEnumR8C5}
    unionStyleEnumR7C6 -> unionStyleEnumR8C6 [weight=100000000]
    rank = same {unionStyleEnumR8C5 -> unionStyleEnumR8C6}
    unionStyleEnumR8C0 -> unionStyleEnumR9C0 [weight=100000000]
    rank = same {unionStyleEnumR9C0 -> unionStyleEnumR9C1}
    unionStyleEnumR8C3 -> unionStyleEnumR9C3 [weight=100000000]
    rank = same {unionStyleEnumR9C2 -> unionStyleEnumR9C3}
    unionStyleEnumR8C4 -> unionStyleEnumR9C4 [weight=100000000]
    rank = same {unionStyleEnumR9C3 -> unionStyleEnumR9C4}
    unionStyleEnumR8C5 -> unionStyleEnumR9C5 [weight=100000000]
    rank = same {unionStyleEnumR9C4 -> unionStyleEnumR9C5}
    unionStyleEnumR8C6 -> unionStyleEnumR9C6 [weight=100000000]
    rank = same {unionStyleEnumR9C5 -> unionStyleEnumR9C6}
    unionStyleEnumR9C0 -> unionStyleEnumR10C0 [weight=100000000]
    rank = same {unionStyleEnumR10C0 -> unionStyleEnumR10C1}
    unionStyleEnumR9C3 -> unionStyleEnumR10C3 [weight=100000000]
    rank = same {unionStyleEnumR10C2 -> unionStyleEnumR10C3}
    unionStyleEnumR9C4 -> unionStyleEnumR10C4 [weight=100000000]
    rank = same {unionStyleEnumR10C3 -> unionStyleEnumR10C4}
    unionStyleEnumR9C5 -> unionStyleEnumR10C5 [weight=100000000]
    rank = same {unionStyleEnumR10C4 -> unionStyleEnumR10C5}
    unionStyleEnumR9C6 -> unionStyleEnumR10C6 [weight=100000000]
    rank = same {unionStyleEnumR10C5 -> unionStyleEnumR10C6}
  }
  subgraph clusterinitializerHead {
    node [shape = box]
    label = <initializerHead = [ attributes ] [ declarationModifiers ] "init" | [ attributes ] [ declarationModifiers ] "init" "?" | [ attributes ] [ declarationModifiers ] "init" "!" .>
    labeljust = l
    initializerHeadR0C0 [label = <DOS<br/>N initializerHead<br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am ["@"]<br/>>]
    initializerHeadR0C1 [label = <DOH<br/>ALT <br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR1C1 [label = <DOL<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C1 [label = <DOP<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C1 [label = <DOQ<br/>T "init"<br/>fi ["init"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR4C1 [label = <DOR<br/>END <br/>fi [""]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR3C1 -> initializerHeadR4C1 [weight=100000000]
    initializerHeadR2C1 -> initializerHeadR3C1 [weight=100000000]
    initializerHeadR2C2 [label = <DON<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C2 [label = <DOM<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR4C2 [label = <DOO<br/>END <br/>fi [""]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C2 -> initializerHeadR4C2 [weight=100000000]
    initializerHeadR2C2 -> initializerHeadR3C2 [weight=100000000]
    rank = same {initializerHeadR2C1 -> initializerHeadR2C2}
    initializerHeadR1C1 -> initializerHeadR2C1 [weight=100000000]
    initializerHeadR1C3 [label = <DOJ<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C3 [label = <DOI<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR3C3 [label = <DOK<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C3 -> initializerHeadR3C3 [weight=100000000]
    initializerHeadR1C3 -> initializerHeadR2C3 [weight=100000000]
    rank = same {initializerHeadR1C1 -> initializerHeadR1C3}
    initializerHeadR0C1 -> initializerHeadR1C1 [weight=100000000]
    initializerHeadR0C4 [label = <DOT<br/>ALT <br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR1C4 [label = <DOX<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C4 [label = <DPB<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C4 [label = <DPC<br/>T "init"<br/>fi ["init"]<br/>fo ["?"]<br/>am []<br/>>]
    initializerHeadR4C4 [label = <DPD<br/>T "?"<br/>fi ["?"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR5C4 [label = <DPE<br/>END <br/>fi [""]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR4C4 -> initializerHeadR5C4 [weight=100000000]
    initializerHeadR3C4 -> initializerHeadR4C4 [weight=100000000]
    initializerHeadR2C4 -> initializerHeadR3C4 [weight=100000000]
    initializerHeadR2C5 [label = <DOZ<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C5 [label = <DOY<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR4C5 [label = <DPA<br/>END <br/>fi [""]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C5 -> initializerHeadR4C5 [weight=100000000]
    initializerHeadR2C5 -> initializerHeadR3C5 [weight=100000000]
    rank = same {initializerHeadR2C4 -> initializerHeadR2C5}
    initializerHeadR1C4 -> initializerHeadR2C4 [weight=100000000]
    initializerHeadR1C6 [label = <DOV<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C6 [label = <DOU<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR3C6 [label = <DOW<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C6 -> initializerHeadR3C6 [weight=100000000]
    initializerHeadR1C6 -> initializerHeadR2C6 [weight=100000000]
    rank = same {initializerHeadR1C4 -> initializerHeadR1C6}
    initializerHeadR0C4 -> initializerHeadR1C4 [weight=100000000]
    initializerHeadR0C7 [label = <DPF<br/>ALT <br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR1C7 [label = <DPJ<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C7 [label = <DPN<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C7 [label = <DPO<br/>T "init"<br/>fi ["init"]<br/>fo ["!"]<br/>am []<br/>>]
    initializerHeadR4C7 [label = <DPP<br/>T "!"<br/>fi ["!"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR5C7 [label = <DPQ<br/>END <br/>fi [""]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerHeadR4C7 -> initializerHeadR5C7 [weight=100000000]
    initializerHeadR3C7 -> initializerHeadR4C7 [weight=100000000]
    initializerHeadR2C7 -> initializerHeadR3C7 [weight=100000000]
    initializerHeadR2C8 [label = <DPL<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C8 [label = <DPK<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR4C8 [label = <DPM<br/>END <br/>fi [""]<br/>fo ["init"]<br/>am []<br/>>]
    initializerHeadR3C8 -> initializerHeadR4C8 [weight=100000000]
    initializerHeadR2C8 -> initializerHeadR3C8 [weight=100000000]
    rank = same {initializerHeadR2C7 -> initializerHeadR2C8}
    initializerHeadR1C7 -> initializerHeadR2C7 [weight=100000000]
    initializerHeadR1C9 [label = <DPH<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C9 [label = <DPG<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR3C9 [label = <DPI<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "init", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    initializerHeadR2C9 -> initializerHeadR3C9 [weight=100000000]
    initializerHeadR1C9 -> initializerHeadR2C9 [weight=100000000]
    rank = same {initializerHeadR1C7 -> initializerHeadR1C9}
    initializerHeadR0C7 -> initializerHeadR1C7 [weight=100000000]
    rank = same {initializerHeadR0C4 -> initializerHeadR0C7}
    rank = same {initializerHeadR0C1 -> initializerHeadR0C4}
    rank = same {initializerHeadR0C0 -> initializerHeadR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {initializerHeadR0C7 -> initializerHeadR0C8}
    rank = same {initializerHeadR0C8 -> initializerHeadR0C9}
    initializerHeadR0C0 -> initializerHeadR1C0 [weight=100000000]
    rank = same {initializerHeadR1C0 -> initializerHeadR1C1}
    initializerHeadR0C9 -> initializerHeadR1C9 [weight=100000000]
    initializerHeadR1C0 -> initializerHeadR2C0 [weight=100000000]
    rank = same {initializerHeadR2C0 -> initializerHeadR2C1}
    initializerHeadR2C0 -> initializerHeadR3C0 [weight=100000000]
    rank = same {initializerHeadR3C0 -> initializerHeadR3C1}
    initializerHeadR3C0 -> initializerHeadR4C0 [weight=100000000]
    rank = same {initializerHeadR4C0 -> initializerHeadR4C1}
    initializerHeadR3C3 -> initializerHeadR4C3 [weight=100000000]
    rank = same {initializerHeadR4C2 -> initializerHeadR4C3}
    rank = same {initializerHeadR4C3 -> initializerHeadR4C4}
    initializerHeadR3C6 -> initializerHeadR4C6 [weight=100000000]
    rank = same {initializerHeadR4C5 -> initializerHeadR4C6}
    rank = same {initializerHeadR4C6 -> initializerHeadR4C7}
    initializerHeadR3C9 -> initializerHeadR4C9 [weight=100000000]
    rank = same {initializerHeadR4C8 -> initializerHeadR4C9}
    initializerHeadR4C0 -> initializerHeadR5C0 [weight=100000000]
    initializerHeadR4C1 -> initializerHeadR5C1 [weight=100000000]
    rank = same {initializerHeadR5C0 -> initializerHeadR5C1}
    initializerHeadR4C2 -> initializerHeadR5C2 [weight=100000000]
    rank = same {initializerHeadR5C1 -> initializerHeadR5C2}
    initializerHeadR4C3 -> initializerHeadR5C3 [weight=100000000]
    rank = same {initializerHeadR5C2 -> initializerHeadR5C3}
    rank = same {initializerHeadR5C3 -> initializerHeadR5C4}
    initializerHeadR4C5 -> initializerHeadR5C5 [weight=100000000]
    rank = same {initializerHeadR5C4 -> initializerHeadR5C5}
    initializerHeadR4C6 -> initializerHeadR5C6 [weight=100000000]
    rank = same {initializerHeadR5C5 -> initializerHeadR5C6}
    rank = same {initializerHeadR5C6 -> initializerHeadR5C7}
    initializerHeadR4C8 -> initializerHeadR5C8 [weight=100000000]
    rank = same {initializerHeadR5C7 -> initializerHeadR5C8}
    initializerHeadR4C9 -> initializerHeadR5C9 [weight=100000000]
    rank = same {initializerHeadR5C8 -> initializerHeadR5C9}
  }
  subgraph clusterfunctionCallExpression {
    node [shape = box]
    label = <functionCallExpression = postfixExpression functionCallArgumentClause | postfixExpression [ functionCallArgumentClause ] trailingClosures .>
    labeljust = l
    functionCallExpressionR0C0 [label = <APC<br/>N functionCallExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>>]
    functionCallExpressionR0C1 [label = <AOY<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR1C1 [label = <AOZ<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["("]<br/>am []<br/>>]
    functionCallExpressionR2C1 [label = <APA<br/>N functionCallArgumentClause<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR3C1 [label = <APB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR2C1 -> functionCallExpressionR3C1 [weight=100000000]
    functionCallExpressionR1C1 -> functionCallExpressionR2C1 [weight=100000000]
    functionCallExpressionR0C1 -> functionCallExpressionR1C1 [weight=100000000]
    functionCallExpressionR0C2 [label = <APD<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR1C2 [label = <APE<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["(", "{"]<br/>am []<br/>>]
    functionCallExpressionR2C2 [label = <API<br/>OPT <br/>fi ["", "("]<br/>fo ["{"]<br/>am []<br/>>]
    functionCallExpressionR3C2 [label = <APJ<br/>N trailingClosures<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR4C2 [label = <APK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionCallExpressionR3C2 -> functionCallExpressionR4C2 [weight=100000000]
    functionCallExpressionR2C2 -> functionCallExpressionR3C2 [weight=100000000]
    functionCallExpressionR2C3 [label = <APG<br/>ALT <br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    functionCallExpressionR3C3 [label = <APF<br/>N functionCallArgumentClause<br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    functionCallExpressionR4C3 [label = <APH<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    functionCallExpressionR3C3 -> functionCallExpressionR4C3 [weight=100000000]
    functionCallExpressionR2C3 -> functionCallExpressionR3C3 [weight=100000000]
    rank = same {functionCallExpressionR2C2 -> functionCallExpressionR2C3}
    functionCallExpressionR1C2 -> functionCallExpressionR2C2 [weight=100000000]
    functionCallExpressionR0C2 -> functionCallExpressionR1C2 [weight=100000000]
    rank = same {functionCallExpressionR0C1 -> functionCallExpressionR0C2}
    rank = same {functionCallExpressionR0C0 -> functionCallExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionCallExpressionR0C2 -> functionCallExpressionR0C3}
    functionCallExpressionR0C0 -> functionCallExpressionR1C0 [weight=100000000]
    rank = same {functionCallExpressionR1C0 -> functionCallExpressionR1C1}
    functionCallExpressionR0C3 -> functionCallExpressionR1C3 [weight=100000000]
    rank = same {functionCallExpressionR1C2 -> functionCallExpressionR1C3}
    functionCallExpressionR1C0 -> functionCallExpressionR2C0 [weight=100000000]
    rank = same {functionCallExpressionR2C0 -> functionCallExpressionR2C1}
    functionCallExpressionR1C3 -> functionCallExpressionR2C3 [weight=100000000]
    functionCallExpressionR2C0 -> functionCallExpressionR3C0 [weight=100000000]
    rank = same {functionCallExpressionR3C0 -> functionCallExpressionR3C1}
    functionCallExpressionR3C0 -> functionCallExpressionR4C0 [weight=100000000]
    functionCallExpressionR3C1 -> functionCallExpressionR4C1 [weight=100000000]
    rank = same {functionCallExpressionR4C0 -> functionCallExpressionR4C1}
    rank = same {functionCallExpressionR4C1 -> functionCallExpressionR4C2}
  }
  subgraph clusterswiftVersionContinuation {
    node [shape = box]
    label = <swiftVersionContinuation = "." "decimalDigits" [ swiftVersionContinuation ] .>
    labeljust = l
    swiftVersionContinuationR0C0 [label = <BTK<br/>N swiftVersionContinuation<br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR0C1 [label = <BTC<br/>ALT <br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR1C1 [label = <BTD<br/>T "."<br/>fi ["."]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    swiftVersionContinuationR2C1 [label = <BTE<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo [")", "."]<br/>am []<br/>>]
    swiftVersionContinuationR3C1 [label = <BTI<br/>OPT <br/>fi ["", "."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR4C1 [label = <BTJ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR3C1 -> swiftVersionContinuationR4C1 [weight=100000000]
    swiftVersionContinuationR3C2 [label = <BTG<br/>ALT <br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR4C2 [label = <BTF<br/>N swiftVersionContinuation<br/>fi ["."]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR5C2 [label = <BTH<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    swiftVersionContinuationR4C2 -> swiftVersionContinuationR5C2 [weight=100000000]
    swiftVersionContinuationR3C2 -> swiftVersionContinuationR4C2 [weight=100000000]
    rank = same {swiftVersionContinuationR3C1 -> swiftVersionContinuationR3C2}
    swiftVersionContinuationR2C1 -> swiftVersionContinuationR3C1 [weight=100000000]
    swiftVersionContinuationR1C1 -> swiftVersionContinuationR2C1 [weight=100000000]
    swiftVersionContinuationR0C1 -> swiftVersionContinuationR1C1 [weight=100000000]
    rank = same {swiftVersionContinuationR0C0 -> swiftVersionContinuationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {swiftVersionContinuationR0C1 -> swiftVersionContinuationR0C2}
    swiftVersionContinuationR0C0 -> swiftVersionContinuationR1C0 [weight=100000000]
    rank = same {swiftVersionContinuationR1C0 -> swiftVersionContinuationR1C1}
    swiftVersionContinuationR0C2 -> swiftVersionContinuationR1C2 [weight=100000000]
    rank = same {swiftVersionContinuationR1C1 -> swiftVersionContinuationR1C2}
    swiftVersionContinuationR1C0 -> swiftVersionContinuationR2C0 [weight=100000000]
    rank = same {swiftVersionContinuationR2C0 -> swiftVersionContinuationR2C1}
    swiftVersionContinuationR1C2 -> swiftVersionContinuationR2C2 [weight=100000000]
    rank = same {swiftVersionContinuationR2C1 -> swiftVersionContinuationR2C2}
    swiftVersionContinuationR2C0 -> swiftVersionContinuationR3C0 [weight=100000000]
    rank = same {swiftVersionContinuationR3C0 -> swiftVersionContinuationR3C1}
    swiftVersionContinuationR2C2 -> swiftVersionContinuationR3C2 [weight=100000000]
    swiftVersionContinuationR3C0 -> swiftVersionContinuationR4C0 [weight=100000000]
    rank = same {swiftVersionContinuationR4C0 -> swiftVersionContinuationR4C1}
    swiftVersionContinuationR4C0 -> swiftVersionContinuationR5C0 [weight=100000000]
    swiftVersionContinuationR4C1 -> swiftVersionContinuationR5C1 [weight=100000000]
    rank = same {swiftVersionContinuationR5C0 -> swiftVersionContinuationR5C1}
    rank = same {swiftVersionContinuationR5C1 -> swiftVersionContinuationR5C2}
  }
  subgraph clusterprecedenceGroupName {
    node [shape = box]
    label = <precedenceGroupName = identifier .>
    labeljust = l
    precedenceGroupNameR0C0 [label = <EAA<br/>N precedenceGroupName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "assignment", "associativity", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "infix", "lowerThan", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    precedenceGroupNameR0C1 [label = <DZX<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "assignment", "associativity", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "infix", "lowerThan", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    precedenceGroupNameR1C1 [label = <DZY<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "assignment", "associativity", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "infix", "lowerThan", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    precedenceGroupNameR2C1 [label = <DZZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "assignment", "associativity", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "infix", "lowerThan", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    precedenceGroupNameR1C1 -> precedenceGroupNameR2C1 [weight=100000000]
    precedenceGroupNameR0C1 -> precedenceGroupNameR1C1 [weight=100000000]
    rank = same {precedenceGroupNameR0C0 -> precedenceGroupNameR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupNameR0C0 -> precedenceGroupNameR1C0 [weight=100000000]
    rank = same {precedenceGroupNameR1C0 -> precedenceGroupNameR1C1}
    precedenceGroupNameR1C0 -> precedenceGroupNameR2C0 [weight=100000000]
    rank = same {precedenceGroupNameR2C0 -> precedenceGroupNameR2C1}
  }
  subgraph clustertypeAnnotation {
    node [shape = box]
    label = <typeAnnotation = ":" [ attributes ] [ "inout" ] type .>
    labeljust = l
    typeAnnotationR0C0 [label = <GA<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", "...", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR0C1 [label = <FO<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", "...", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR1C1 [label = <FP<br/>T ":"<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "inout", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR2C1 [label = <FT<br/>OPT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "inout", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    typeAnnotationR3C1 [label = <FX<br/>OPT <br/>fi ["", "inout"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR4C1 [label = <FY<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", "...", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeAnnotationR5C1 [label = <FZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", "...", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR4C1 -> typeAnnotationR5C1 [weight=100000000]
    typeAnnotationR3C1 -> typeAnnotationR4C1 [weight=100000000]
    typeAnnotationR3C2 [label = <FV<br/>ALT <br/>fi ["inout"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR4C2 [label = <FU<br/>T "inout"<br/>fi ["inout"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR5C2 [label = <FW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR4C2 -> typeAnnotationR5C2 [weight=100000000]
    typeAnnotationR3C2 -> typeAnnotationR4C2 [weight=100000000]
    rank = same {typeAnnotationR3C1 -> typeAnnotationR3C2}
    typeAnnotationR2C1 -> typeAnnotationR3C1 [weight=100000000]
    typeAnnotationR2C3 [label = <FR<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "inout", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR3C3 [label = <FQ<br/>N attributes<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "inout", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR4C3 [label = <FS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "inout", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeAnnotationR3C3 -> typeAnnotationR4C3 [weight=100000000]
    typeAnnotationR2C3 -> typeAnnotationR3C3 [weight=100000000]
    rank = same {typeAnnotationR2C1 -> typeAnnotationR2C3}
    typeAnnotationR1C1 -> typeAnnotationR2C1 [weight=100000000]
    typeAnnotationR0C1 -> typeAnnotationR1C1 [weight=100000000]
    rank = same {typeAnnotationR0C0 -> typeAnnotationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {typeAnnotationR0C1 -> typeAnnotationR0C2}
    rank = same {typeAnnotationR0C2 -> typeAnnotationR0C3}
    typeAnnotationR0C0 -> typeAnnotationR1C0 [weight=100000000]
    rank = same {typeAnnotationR1C0 -> typeAnnotationR1C1}
    typeAnnotationR0C2 -> typeAnnotationR1C2 [weight=100000000]
    rank = same {typeAnnotationR1C1 -> typeAnnotationR1C2}
    typeAnnotationR0C3 -> typeAnnotationR1C3 [weight=100000000]
    rank = same {typeAnnotationR1C2 -> typeAnnotationR1C3}
    typeAnnotationR1C0 -> typeAnnotationR2C0 [weight=100000000]
    rank = same {typeAnnotationR2C0 -> typeAnnotationR2C1}
    typeAnnotationR1C3 -> typeAnnotationR2C3 [weight=100000000]
    typeAnnotationR2C0 -> typeAnnotationR3C0 [weight=100000000]
    rank = same {typeAnnotationR3C0 -> typeAnnotationR3C1}
    typeAnnotationR3C0 -> typeAnnotationR4C0 [weight=100000000]
    rank = same {typeAnnotationR4C0 -> typeAnnotationR4C1}
    typeAnnotationR4C0 -> typeAnnotationR5C0 [weight=100000000]
    rank = same {typeAnnotationR5C0 -> typeAnnotationR5C1}
    typeAnnotationR4C3 -> typeAnnotationR5C3 [weight=100000000]
    rank = same {typeAnnotationR5C2 -> typeAnnotationR5C3}
  }
  subgraph clusterimportDeclaration {
    node [shape = box]
    label = <importDeclaration = [ attributes ] "import" [ importKind ] importPath .>
    labeljust = l
    importDeclarationR0C0 [label = <CAX<br/>N importDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    importDeclarationR0C1 [label = <CAL<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    importDeclarationR1C1 [label = <CAP<br/>OPT <br/>fi ["", "@"]<br/>fo ["import"]<br/>am []<br/>>]
    importDeclarationR2C1 [label = <CAQ<br/>T "import"<br/>fi ["import"]<br/>fo ["class", "enum", "escapedIdentifier", "func", "implicitParameterName", "let", "plainIdentifier", "propertyWrapperProjection", "protocol", "struct", "typealias", "var"]<br/>am []<br/>>]
    importDeclarationR3C1 [label = <CAU<br/>OPT <br/>fi ["", "class", "enum", "func", "let", "protocol", "struct", "typealias", "var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importDeclarationR4C1 [label = <CAV<br/>N importPath<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importDeclarationR5C1 [label = <CAW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importDeclarationR4C1 -> importDeclarationR5C1 [weight=100000000]
    importDeclarationR3C1 -> importDeclarationR4C1 [weight=100000000]
    importDeclarationR3C2 [label = <CAS<br/>ALT <br/>fi ["class", "enum", "func", "let", "protocol", "struct", "typealias", "var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importDeclarationR4C2 [label = <CAR<br/>N importKind<br/>fi ["class", "enum", "func", "let", "protocol", "struct", "typealias", "var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importDeclarationR5C2 [label = <CAT<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importDeclarationR4C2 -> importDeclarationR5C2 [weight=100000000]
    importDeclarationR3C2 -> importDeclarationR4C2 [weight=100000000]
    rank = same {importDeclarationR3C1 -> importDeclarationR3C2}
    importDeclarationR2C1 -> importDeclarationR3C1 [weight=100000000]
    importDeclarationR1C1 -> importDeclarationR2C1 [weight=100000000]
    importDeclarationR1C3 [label = <CAN<br/>ALT <br/>fi ["@"]<br/>fo ["import"]<br/>am []<br/>>]
    importDeclarationR2C3 [label = <CAM<br/>N attributes<br/>fi ["@"]<br/>fo ["import"]<br/>am []<br/>>]
    importDeclarationR3C3 [label = <CAO<br/>END <br/>fi [""]<br/>fo ["import"]<br/>am []<br/>>]
    importDeclarationR2C3 -> importDeclarationR3C3 [weight=100000000]
    importDeclarationR1C3 -> importDeclarationR2C3 [weight=100000000]
    rank = same {importDeclarationR1C1 -> importDeclarationR1C3}
    importDeclarationR0C1 -> importDeclarationR1C1 [weight=100000000]
    rank = same {importDeclarationR0C0 -> importDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {importDeclarationR0C1 -> importDeclarationR0C2}
    rank = same {importDeclarationR0C2 -> importDeclarationR0C3}
    importDeclarationR0C0 -> importDeclarationR1C0 [weight=100000000]
    rank = same {importDeclarationR1C0 -> importDeclarationR1C1}
    importDeclarationR0C3 -> importDeclarationR1C3 [weight=100000000]
    importDeclarationR1C0 -> importDeclarationR2C0 [weight=100000000]
    rank = same {importDeclarationR2C0 -> importDeclarationR2C1}
    rank = same {importDeclarationR2C1 -> importDeclarationR2C2}
    rank = same {importDeclarationR2C2 -> importDeclarationR2C3}
    importDeclarationR2C0 -> importDeclarationR3C0 [weight=100000000]
    rank = same {importDeclarationR3C0 -> importDeclarationR3C1}
    importDeclarationR2C2 -> importDeclarationR3C2 [weight=100000000]
    importDeclarationR3C0 -> importDeclarationR4C0 [weight=100000000]
    rank = same {importDeclarationR4C0 -> importDeclarationR4C1}
    importDeclarationR3C3 -> importDeclarationR4C3 [weight=100000000]
    rank = same {importDeclarationR4C2 -> importDeclarationR4C3}
    importDeclarationR4C0 -> importDeclarationR5C0 [weight=100000000]
    rank = same {importDeclarationR5C0 -> importDeclarationR5C1}
    importDeclarationR4C3 -> importDeclarationR5C3 [weight=100000000]
    rank = same {importDeclarationR5C2 -> importDeclarationR5C3}
  }
  subgraph clusteravailabilityCondition {
    node [shape = box]
    label = <availabilityCondition = "#available" "(" availabilityArguments ")" | "#unavailable" "(" availabilityArguments ")" .>
    labeljust = l
    availabilityConditionR0C0 [label = <BVG<br/>N availabilityCondition<br/>fi ["#available", "#unavailable"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR0C1 [label = <BVA<br/>ALT <br/>fi ["#available"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR1C1 [label = <BVB<br/>T "#available"<br/>fi ["#available"]<br/>fo ["("]<br/>am []<br/>>]
    availabilityConditionR2C1 [label = <BVC<br/>T "("<br/>fi ["("]<br/>fo ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>am []<br/>>]
    availabilityConditionR3C1 [label = <BVD<br/>N availabilityArguments<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityConditionR4C1 [label = <BVE<br/>T ")"<br/>fi [")"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR5C1 [label = <BVF<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR4C1 -> availabilityConditionR5C1 [weight=100000000]
    availabilityConditionR3C1 -> availabilityConditionR4C1 [weight=100000000]
    availabilityConditionR2C1 -> availabilityConditionR3C1 [weight=100000000]
    availabilityConditionR1C1 -> availabilityConditionR2C1 [weight=100000000]
    availabilityConditionR0C1 -> availabilityConditionR1C1 [weight=100000000]
    availabilityConditionR0C2 [label = <BVH<br/>ALT <br/>fi ["#unavailable"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR1C2 [label = <BVI<br/>T "#unavailable"<br/>fi ["#unavailable"]<br/>fo ["("]<br/>am []<br/>>]
    availabilityConditionR2C2 [label = <BVJ<br/>T "("<br/>fi ["("]<br/>fo ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>am []<br/>>]
    availabilityConditionR3C2 [label = <BVK<br/>N availabilityArguments<br/>fi ["*", "iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo [")"]<br/>am []<br/>>]
    availabilityConditionR4C2 [label = <BVL<br/>T ")"<br/>fi [")"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR5C2 [label = <BVM<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    availabilityConditionR4C2 -> availabilityConditionR5C2 [weight=100000000]
    availabilityConditionR3C2 -> availabilityConditionR4C2 [weight=100000000]
    availabilityConditionR2C2 -> availabilityConditionR3C2 [weight=100000000]
    availabilityConditionR1C2 -> availabilityConditionR2C2 [weight=100000000]
    availabilityConditionR0C2 -> availabilityConditionR1C2 [weight=100000000]
    rank = same {availabilityConditionR0C1 -> availabilityConditionR0C2}
    rank = same {availabilityConditionR0C0 -> availabilityConditionR0C1}
    node [style = invis]
    edge [style = invis]
    availabilityConditionR0C0 -> availabilityConditionR1C0 [weight=100000000]
    rank = same {availabilityConditionR1C0 -> availabilityConditionR1C1}
    availabilityConditionR1C0 -> availabilityConditionR2C0 [weight=100000000]
    rank = same {availabilityConditionR2C0 -> availabilityConditionR2C1}
    availabilityConditionR2C0 -> availabilityConditionR3C0 [weight=100000000]
    rank = same {availabilityConditionR3C0 -> availabilityConditionR3C1}
    availabilityConditionR3C0 -> availabilityConditionR4C0 [weight=100000000]
    rank = same {availabilityConditionR4C0 -> availabilityConditionR4C1}
    availabilityConditionR4C0 -> availabilityConditionR5C0 [weight=100000000]
    rank = same {availabilityConditionR5C0 -> availabilityConditionR5C1}
  }
  subgraph clusterwhereClause {
    node [shape = box]
    label = <whereClause = "where" whereExpression .>
    labeljust = l
    whereClauseR0C0 [label = <BEP<br/>N whereClause<br/>fi ["where"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereClauseR0C1 [label = <BEL<br/>ALT <br/>fi ["where"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereClauseR1C1 [label = <BEM<br/>T "where"<br/>fi ["where"]<br/>fo [",", ":", "try", "{"]<br/>am []<br/>>]
    whereClauseR2C1 [label = <BEN<br/>N whereExpression<br/>fi ["", "try"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereClauseR3C1 [label = <BEO<br/>END <br/>fi [""]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereClauseR2C1 -> whereClauseR3C1 [weight=100000000]
    whereClauseR1C1 -> whereClauseR2C1 [weight=100000000]
    whereClauseR0C1 -> whereClauseR1C1 [weight=100000000]
    rank = same {whereClauseR0C0 -> whereClauseR0C1}
    node [style = invis]
    edge [style = invis]
    whereClauseR0C0 -> whereClauseR1C0 [weight=100000000]
    rank = same {whereClauseR1C0 -> whereClauseR1C1}
    whereClauseR1C0 -> whereClauseR2C0 [weight=100000000]
    rank = same {whereClauseR2C0 -> whereClauseR2C1}
    whereClauseR2C0 -> whereClauseR3C0 [weight=100000000]
    rank = same {whereClauseR3C0 -> whereClauseR3C1}
  }
  subgraph clusterarrayLiteral {
    node [shape = box]
    label = <arrayLiteral = "[" [ arrayLiteralItems ] "]" .>
    labeljust = l
    arrayLiteralR0C0 [label = <VJ<br/>N arrayLiteral<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayLiteralR0C1 [label = <VB<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayLiteralR1C1 [label = <VC<br/>T "["<br/>fi ["["]<br/>fo ["]", "try"]<br/>am []<br/>>]
    arrayLiteralR2C1 [label = <VG<br/>OPT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralR3C1 [label = <VH<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayLiteralR4C1 [label = <VI<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayLiteralR3C1 -> arrayLiteralR4C1 [weight=100000000]
    arrayLiteralR2C1 -> arrayLiteralR3C1 [weight=100000000]
    arrayLiteralR2C2 [label = <VE<br/>ALT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralR3C2 [label = <VD<br/>N arrayLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralR4C2 [label = <VF<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralR3C2 -> arrayLiteralR4C2 [weight=100000000]
    arrayLiteralR2C2 -> arrayLiteralR3C2 [weight=100000000]
    rank = same {arrayLiteralR2C1 -> arrayLiteralR2C2}
    arrayLiteralR1C1 -> arrayLiteralR2C1 [weight=100000000]
    arrayLiteralR0C1 -> arrayLiteralR1C1 [weight=100000000]
    rank = same {arrayLiteralR0C0 -> arrayLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {arrayLiteralR0C1 -> arrayLiteralR0C2}
    arrayLiteralR0C0 -> arrayLiteralR1C0 [weight=100000000]
    rank = same {arrayLiteralR1C0 -> arrayLiteralR1C1}
    arrayLiteralR0C2 -> arrayLiteralR1C2 [weight=100000000]
    rank = same {arrayLiteralR1C1 -> arrayLiteralR1C2}
    arrayLiteralR1C0 -> arrayLiteralR2C0 [weight=100000000]
    rank = same {arrayLiteralR2C0 -> arrayLiteralR2C1}
    arrayLiteralR1C2 -> arrayLiteralR2C2 [weight=100000000]
    arrayLiteralR2C0 -> arrayLiteralR3C0 [weight=100000000]
    rank = same {arrayLiteralR3C0 -> arrayLiteralR3C1}
    arrayLiteralR3C0 -> arrayLiteralR4C0 [weight=100000000]
    rank = same {arrayLiteralR4C0 -> arrayLiteralR4C1}
  }
  subgraph clusterfloatingPointLiteral {
    node [shape = box]
    label = <floatingPointLiteral = "decimalFloatingPointLiteral" | "hexadecimalFloatingPointLiteral" .>
    labeljust = l
    floatingPointLiteralR0C0 [label = <AY<br/>N floatingPointLiteral<br/>fi ["decimalFloatingPointLiteral", "hexadecimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR0C1 [label = <AS<br/>ALT <br/>fi ["decimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR1C1 [label = <AT<br/>T "decimalFloatingPointLiteral"<br/>fi ["decimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR2C1 [label = <AU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR1C1 -> floatingPointLiteralR2C1 [weight=100000000]
    floatingPointLiteralR0C1 -> floatingPointLiteralR1C1 [weight=100000000]
    floatingPointLiteralR0C2 [label = <AV<br/>ALT <br/>fi ["hexadecimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR1C2 [label = <AW<br/>T "hexadecimalFloatingPointLiteral"<br/>fi ["hexadecimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR2C2 [label = <AX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    floatingPointLiteralR1C2 -> floatingPointLiteralR2C2 [weight=100000000]
    floatingPointLiteralR0C2 -> floatingPointLiteralR1C2 [weight=100000000]
    rank = same {floatingPointLiteralR0C1 -> floatingPointLiteralR0C2}
    rank = same {floatingPointLiteralR0C0 -> floatingPointLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    floatingPointLiteralR0C0 -> floatingPointLiteralR1C0 [weight=100000000]
    rank = same {floatingPointLiteralR1C0 -> floatingPointLiteralR1C1}
    floatingPointLiteralR1C0 -> floatingPointLiteralR2C0 [weight=100000000]
    rank = same {floatingPointLiteralR2C0 -> floatingPointLiteralR2C1}
  }
  subgraph clusterinfixExpression {
    node [shape = box]
    label = <infixExpression = infixOperator prefixExpression | assignmentOperator [ tryOperator ] [ awaitOperator ] prefixExpression | conditionalOperator [ tryOperator ] [ awaitOperator ] prefixExpression | typeCastingOperator .>
    labeljust = l
    infixExpressionR0C0 [label = <QG<br/>N infixExpression<br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR0C1 [label = <QC<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR1C1 [label = <QD<br/>N infixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR2C1 [label = <QE<br/>N prefixExpression<br/>fi ["", "&amp;", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    infixExpressionR3C1 [label = <QF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR2C1 -> infixExpressionR3C1 [weight=100000000]
    infixExpressionR1C1 -> infixExpressionR2C1 [weight=100000000]
    infixExpressionR0C1 -> infixExpressionR1C1 [weight=100000000]
    infixExpressionR0C2 [label = <QH<br/>ALT <br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR1C2 [label = <QI<br/>N assignmentOperator<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR2C2 [label = <QM<br/>OPT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    infixExpressionR3C2 [label = <QQ<br/>OPT <br/>fi ["", "await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C2 [label = <QR<br/>N prefixExpression<br/>fi ["", "&amp;", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    infixExpressionR5C2 [label = <QS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C2 -> infixExpressionR5C2 [weight=100000000]
    infixExpressionR3C2 -> infixExpressionR4C2 [weight=100000000]
    infixExpressionR3C3 [label = <QO<br/>ALT <br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C3 [label = <QN<br/>N awaitOperator<br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR5C3 [label = <QP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C3 -> infixExpressionR5C3 [weight=100000000]
    infixExpressionR3C3 -> infixExpressionR4C3 [weight=100000000]
    rank = same {infixExpressionR3C2 -> infixExpressionR3C3}
    infixExpressionR2C2 -> infixExpressionR3C2 [weight=100000000]
    infixExpressionR2C4 [label = <QK<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR3C4 [label = <QJ<br/>N tryOperator<br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C4 [label = <QL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR3C4 -> infixExpressionR4C4 [weight=100000000]
    infixExpressionR2C4 -> infixExpressionR3C4 [weight=100000000]
    rank = same {infixExpressionR2C2 -> infixExpressionR2C4}
    infixExpressionR1C2 -> infixExpressionR2C2 [weight=100000000]
    infixExpressionR0C2 -> infixExpressionR1C2 [weight=100000000]
    infixExpressionR0C5 [label = <QT<br/>ALT <br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR1C5 [label = <QU<br/>N conditionalOperator<br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR2C5 [label = <QY<br/>OPT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    infixExpressionR3C5 [label = <RC<br/>OPT <br/>fi ["", "await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C5 [label = <RD<br/>N prefixExpression<br/>fi ["", "&amp;", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    infixExpressionR5C5 [label = <RE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C5 -> infixExpressionR5C5 [weight=100000000]
    infixExpressionR3C5 -> infixExpressionR4C5 [weight=100000000]
    infixExpressionR3C6 [label = <RA<br/>ALT <br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C6 [label = <QZ<br/>N awaitOperator<br/>fi ["await"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR5C6 [label = <RB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C6 -> infixExpressionR5C6 [weight=100000000]
    infixExpressionR3C6 -> infixExpressionR4C6 [weight=100000000]
    rank = same {infixExpressionR3C5 -> infixExpressionR3C6}
    infixExpressionR2C5 -> infixExpressionR3C5 [weight=100000000]
    infixExpressionR2C7 [label = <QW<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR3C7 [label = <QV<br/>N tryOperator<br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR4C7 [label = <QX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR3C7 -> infixExpressionR4C7 [weight=100000000]
    infixExpressionR2C7 -> infixExpressionR3C7 [weight=100000000]
    rank = same {infixExpressionR2C5 -> infixExpressionR2C7}
    infixExpressionR1C5 -> infixExpressionR2C5 [weight=100000000]
    infixExpressionR0C5 -> infixExpressionR1C5 [weight=100000000]
    infixExpressionR0C8 [label = <RF<br/>ALT <br/>fi ["as", "is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR1C8 [label = <RG<br/>N typeCastingOperator<br/>fi ["as", "is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR2C8 [label = <RH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionR1C8 -> infixExpressionR2C8 [weight=100000000]
    infixExpressionR0C8 -> infixExpressionR1C8 [weight=100000000]
    rank = same {infixExpressionR0C5 -> infixExpressionR0C8}
    rank = same {infixExpressionR0C2 -> infixExpressionR0C5}
    rank = same {infixExpressionR0C1 -> infixExpressionR0C2}
    rank = same {infixExpressionR0C0 -> infixExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    infixExpressionR0C0 -> infixExpressionR1C0 [weight=100000000]
    rank = same {infixExpressionR1C0 -> infixExpressionR1C1}
    rank = same {infixExpressionR1C2 -> infixExpressionR1C3}
    rank = same {infixExpressionR1C3 -> infixExpressionR1C4}
    rank = same {infixExpressionR1C4 -> infixExpressionR1C5}
    rank = same {infixExpressionR1C5 -> infixExpressionR1C6}
    rank = same {infixExpressionR1C6 -> infixExpressionR1C7}
    rank = same {infixExpressionR1C7 -> infixExpressionR1C8}
    infixExpressionR1C0 -> infixExpressionR2C0 [weight=100000000]
    rank = same {infixExpressionR2C0 -> infixExpressionR2C1}
    infixExpressionR1C4 -> infixExpressionR2C4 [weight=100000000]
    infixExpressionR1C7 -> infixExpressionR2C7 [weight=100000000]
    infixExpressionR2C0 -> infixExpressionR3C0 [weight=100000000]
    rank = same {infixExpressionR3C0 -> infixExpressionR3C1}
    infixExpressionR2C8 -> infixExpressionR3C8 [weight=100000000]
    rank = same {infixExpressionR3C7 -> infixExpressionR3C8}
    infixExpressionR3C0 -> infixExpressionR4C0 [weight=100000000]
    infixExpressionR3C1 -> infixExpressionR4C1 [weight=100000000]
    rank = same {infixExpressionR4C0 -> infixExpressionR4C1}
    rank = same {infixExpressionR4C1 -> infixExpressionR4C2}
    infixExpressionR3C8 -> infixExpressionR4C8 [weight=100000000]
    rank = same {infixExpressionR4C7 -> infixExpressionR4C8}
    infixExpressionR4C0 -> infixExpressionR5C0 [weight=100000000]
    infixExpressionR4C1 -> infixExpressionR5C1 [weight=100000000]
    rank = same {infixExpressionR5C0 -> infixExpressionR5C1}
    rank = same {infixExpressionR5C1 -> infixExpressionR5C2}
    infixExpressionR4C4 -> infixExpressionR5C4 [weight=100000000]
    rank = same {infixExpressionR5C3 -> infixExpressionR5C4}
    rank = same {infixExpressionR5C4 -> infixExpressionR5C5}
    infixExpressionR4C7 -> infixExpressionR5C7 [weight=100000000]
    rank = same {infixExpressionR5C6 -> infixExpressionR5C7}
    infixExpressionR4C8 -> infixExpressionR5C8 [weight=100000000]
    rank = same {infixExpressionR5C7 -> infixExpressionR5C8}
  }
  subgraph clusterrawValueStyleEnum {
    node [shape = box]
    label = <rawValueStyleEnum = "enum" enumName [ genericParameterClause ] typeInheritanceClause [ genericWhereClause ] "{" rawValueStyleEnumMembers "}" .>
    labeljust = l
    rawValueStyleEnumR0C0 [label = <CXC<br/>N rawValueStyleEnum<br/>fi ["enum"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    rawValueStyleEnumR0C1 [label = <CWM<br/>ALT <br/>fi ["enum"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    rawValueStyleEnumR1C1 [label = <CWN<br/>T "enum"<br/>fi ["enum"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    rawValueStyleEnumR2C1 [label = <CWO<br/>N enumName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;"]<br/>am []<br/>>]
    rawValueStyleEnumR3C1 [label = <CWS<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":"]<br/>am []<br/>>]
    rawValueStyleEnumR4C1 [label = <CWT<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    rawValueStyleEnumR5C1 [label = <CWX<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    rawValueStyleEnumR6C1 [label = <CWY<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumR7C1 [label = <CWZ<br/>N rawValueStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumR8C1 [label = <CXA<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    rawValueStyleEnumR9C1 [label = <CXB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    rawValueStyleEnumR8C1 -> rawValueStyleEnumR9C1 [weight=100000000]
    rawValueStyleEnumR7C1 -> rawValueStyleEnumR8C1 [weight=100000000]
    rawValueStyleEnumR6C1 -> rawValueStyleEnumR7C1 [weight=100000000]
    rawValueStyleEnumR5C1 -> rawValueStyleEnumR6C1 [weight=100000000]
    rawValueStyleEnumR5C2 [label = <CWV<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    rawValueStyleEnumR6C2 [label = <CWU<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    rawValueStyleEnumR7C2 [label = <CWW<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    rawValueStyleEnumR6C2 -> rawValueStyleEnumR7C2 [weight=100000000]
    rawValueStyleEnumR5C2 -> rawValueStyleEnumR6C2 [weight=100000000]
    rank = same {rawValueStyleEnumR5C1 -> rawValueStyleEnumR5C2}
    rawValueStyleEnumR4C1 -> rawValueStyleEnumR5C1 [weight=100000000]
    rawValueStyleEnumR3C1 -> rawValueStyleEnumR4C1 [weight=100000000]
    rawValueStyleEnumR3C3 [label = <CWQ<br/>ALT <br/>fi ["&lt;"]<br/>fo [":"]<br/>am []<br/>>]
    rawValueStyleEnumR4C3 [label = <CWP<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":"]<br/>am []<br/>>]
    rawValueStyleEnumR5C3 [label = <CWR<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    rawValueStyleEnumR4C3 -> rawValueStyleEnumR5C3 [weight=100000000]
    rawValueStyleEnumR3C3 -> rawValueStyleEnumR4C3 [weight=100000000]
    rank = same {rawValueStyleEnumR3C1 -> rawValueStyleEnumR3C3}
    rawValueStyleEnumR2C1 -> rawValueStyleEnumR3C1 [weight=100000000]
    rawValueStyleEnumR1C1 -> rawValueStyleEnumR2C1 [weight=100000000]
    rawValueStyleEnumR0C1 -> rawValueStyleEnumR1C1 [weight=100000000]
    rank = same {rawValueStyleEnumR0C0 -> rawValueStyleEnumR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {rawValueStyleEnumR0C1 -> rawValueStyleEnumR0C2}
    rank = same {rawValueStyleEnumR0C2 -> rawValueStyleEnumR0C3}
    rawValueStyleEnumR0C0 -> rawValueStyleEnumR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumR1C0 -> rawValueStyleEnumR1C1}
    rawValueStyleEnumR0C2 -> rawValueStyleEnumR1C2 [weight=100000000]
    rank = same {rawValueStyleEnumR1C1 -> rawValueStyleEnumR1C2}
    rawValueStyleEnumR0C3 -> rawValueStyleEnumR1C3 [weight=100000000]
    rank = same {rawValueStyleEnumR1C2 -> rawValueStyleEnumR1C3}
    rawValueStyleEnumR1C0 -> rawValueStyleEnumR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumR2C0 -> rawValueStyleEnumR2C1}
    rawValueStyleEnumR1C2 -> rawValueStyleEnumR2C2 [weight=100000000]
    rank = same {rawValueStyleEnumR2C1 -> rawValueStyleEnumR2C2}
    rawValueStyleEnumR1C3 -> rawValueStyleEnumR2C3 [weight=100000000]
    rank = same {rawValueStyleEnumR2C2 -> rawValueStyleEnumR2C3}
    rawValueStyleEnumR2C0 -> rawValueStyleEnumR3C0 [weight=100000000]
    rank = same {rawValueStyleEnumR3C0 -> rawValueStyleEnumR3C1}
    rawValueStyleEnumR2C3 -> rawValueStyleEnumR3C3 [weight=100000000]
    rawValueStyleEnumR3C0 -> rawValueStyleEnumR4C0 [weight=100000000]
    rank = same {rawValueStyleEnumR4C0 -> rawValueStyleEnumR4C1}
    rank = same {rawValueStyleEnumR4C1 -> rawValueStyleEnumR4C2}
    rank = same {rawValueStyleEnumR4C2 -> rawValueStyleEnumR4C3}
    rawValueStyleEnumR4C0 -> rawValueStyleEnumR5C0 [weight=100000000]
    rank = same {rawValueStyleEnumR5C0 -> rawValueStyleEnumR5C1}
    rawValueStyleEnumR4C2 -> rawValueStyleEnumR5C2 [weight=100000000]
    rawValueStyleEnumR5C0 -> rawValueStyleEnumR6C0 [weight=100000000]
    rank = same {rawValueStyleEnumR6C0 -> rawValueStyleEnumR6C1}
    rawValueStyleEnumR5C3 -> rawValueStyleEnumR6C3 [weight=100000000]
    rank = same {rawValueStyleEnumR6C2 -> rawValueStyleEnumR6C3}
    rawValueStyleEnumR6C0 -> rawValueStyleEnumR7C0 [weight=100000000]
    rank = same {rawValueStyleEnumR7C0 -> rawValueStyleEnumR7C1}
    rawValueStyleEnumR6C3 -> rawValueStyleEnumR7C3 [weight=100000000]
    rank = same {rawValueStyleEnumR7C2 -> rawValueStyleEnumR7C3}
    rawValueStyleEnumR7C0 -> rawValueStyleEnumR8C0 [weight=100000000]
    rank = same {rawValueStyleEnumR8C0 -> rawValueStyleEnumR8C1}
    rawValueStyleEnumR7C2 -> rawValueStyleEnumR8C2 [weight=100000000]
    rank = same {rawValueStyleEnumR8C1 -> rawValueStyleEnumR8C2}
    rawValueStyleEnumR7C3 -> rawValueStyleEnumR8C3 [weight=100000000]
    rank = same {rawValueStyleEnumR8C2 -> rawValueStyleEnumR8C3}
    rawValueStyleEnumR8C0 -> rawValueStyleEnumR9C0 [weight=100000000]
    rank = same {rawValueStyleEnumR9C0 -> rawValueStyleEnumR9C1}
    rawValueStyleEnumR8C2 -> rawValueStyleEnumR9C2 [weight=100000000]
    rank = same {rawValueStyleEnumR9C1 -> rawValueStyleEnumR9C2}
    rawValueStyleEnumR8C3 -> rawValueStyleEnumR9C3 [weight=100000000]
    rank = same {rawValueStyleEnumR9C2 -> rawValueStyleEnumR9C3}
  }
  subgraph clustertypeCastingOperator {
    node [shape = box]
    label = <typeCastingOperator = "is" type | "as" type | "as" "?" type | "as" "!" type .>
    labeljust = l
    typeCastingOperatorR0C0 [label = <SE<br/>N typeCastingOperator<br/>fi ["as", "is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["as"]<br/>>]
    typeCastingOperatorR0C1 [label = <SA<br/>ALT <br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR1C1 [label = <SB<br/>T "is"<br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR2C1 [label = <SC<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeCastingOperatorR3C1 [label = <SD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR2C1 -> typeCastingOperatorR3C1 [weight=100000000]
    typeCastingOperatorR1C1 -> typeCastingOperatorR2C1 [weight=100000000]
    typeCastingOperatorR0C1 -> typeCastingOperatorR1C1 [weight=100000000]
    typeCastingOperatorR0C2 [label = <SF<br/>ALT <br/>fi ["as"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR1C2 [label = <SG<br/>T "as"<br/>fi ["as"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR2C2 [label = <SH<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeCastingOperatorR3C2 [label = <SI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR2C2 -> typeCastingOperatorR3C2 [weight=100000000]
    typeCastingOperatorR1C2 -> typeCastingOperatorR2C2 [weight=100000000]
    typeCastingOperatorR0C2 -> typeCastingOperatorR1C2 [weight=100000000]
    typeCastingOperatorR0C3 [label = <SJ<br/>ALT <br/>fi ["as"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR1C3 [label = <SK<br/>T "as"<br/>fi ["as"]<br/>fo ["?"]<br/>am []<br/>>]
    typeCastingOperatorR2C3 [label = <SL<br/>T "?"<br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR3C3 [label = <SM<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeCastingOperatorR4C3 [label = <SN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR3C3 -> typeCastingOperatorR4C3 [weight=100000000]
    typeCastingOperatorR2C3 -> typeCastingOperatorR3C3 [weight=100000000]
    typeCastingOperatorR1C3 -> typeCastingOperatorR2C3 [weight=100000000]
    typeCastingOperatorR0C3 -> typeCastingOperatorR1C3 [weight=100000000]
    typeCastingOperatorR0C4 [label = <SO<br/>ALT <br/>fi ["as"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR1C4 [label = <SP<br/>T "as"<br/>fi ["as"]<br/>fo ["!"]<br/>am []<br/>>]
    typeCastingOperatorR2C4 [label = <SQ<br/>T "!"<br/>fi ["!"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR3C4 [label = <SR<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeCastingOperatorR4C4 [label = <SS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeCastingOperatorR3C4 -> typeCastingOperatorR4C4 [weight=100000000]
    typeCastingOperatorR2C4 -> typeCastingOperatorR3C4 [weight=100000000]
    typeCastingOperatorR1C4 -> typeCastingOperatorR2C4 [weight=100000000]
    typeCastingOperatorR0C4 -> typeCastingOperatorR1C4 [weight=100000000]
    rank = same {typeCastingOperatorR0C3 -> typeCastingOperatorR0C4}
    rank = same {typeCastingOperatorR0C2 -> typeCastingOperatorR0C3}
    rank = same {typeCastingOperatorR0C1 -> typeCastingOperatorR0C2}
    rank = same {typeCastingOperatorR0C0 -> typeCastingOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    typeCastingOperatorR0C0 -> typeCastingOperatorR1C0 [weight=100000000]
    rank = same {typeCastingOperatorR1C0 -> typeCastingOperatorR1C1}
    typeCastingOperatorR1C0 -> typeCastingOperatorR2C0 [weight=100000000]
    rank = same {typeCastingOperatorR2C0 -> typeCastingOperatorR2C1}
    typeCastingOperatorR2C0 -> typeCastingOperatorR3C0 [weight=100000000]
    rank = same {typeCastingOperatorR3C0 -> typeCastingOperatorR3C1}
    typeCastingOperatorR3C0 -> typeCastingOperatorR4C0 [weight=100000000]
    typeCastingOperatorR3C1 -> typeCastingOperatorR4C1 [weight=100000000]
    rank = same {typeCastingOperatorR4C0 -> typeCastingOperatorR4C1}
    typeCastingOperatorR3C2 -> typeCastingOperatorR4C2 [weight=100000000]
    rank = same {typeCastingOperatorR4C1 -> typeCastingOperatorR4C2}
    rank = same {typeCastingOperatorR4C2 -> typeCastingOperatorR4C3}
  }
  subgraph clusterrawValueStyleEnumMembers {
    node [shape = box]
    label = <rawValueStyleEnumMembers = rawValueStyleEnumMember [ rawValueStyleEnumMembers ] .>
    labeljust = l
    rawValueStyleEnumMembersR0C0 [label = <CXK<br/>N rawValueStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR0C1 [label = <CXD<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR1C1 [label = <CXE<br/>N rawValueStyleEnumMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    rawValueStyleEnumMembersR2C1 [label = <CXI<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR3C1 [label = <CXJ<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR2C1 -> rawValueStyleEnumMembersR3C1 [weight=100000000]
    rawValueStyleEnumMembersR2C2 [label = <CXG<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR3C2 [label = <CXF<br/>N rawValueStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR4C2 [label = <CXH<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    rawValueStyleEnumMembersR3C2 -> rawValueStyleEnumMembersR4C2 [weight=100000000]
    rawValueStyleEnumMembersR2C2 -> rawValueStyleEnumMembersR3C2 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR2C1 -> rawValueStyleEnumMembersR2C2}
    rawValueStyleEnumMembersR1C1 -> rawValueStyleEnumMembersR2C1 [weight=100000000]
    rawValueStyleEnumMembersR0C1 -> rawValueStyleEnumMembersR1C1 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR0C0 -> rawValueStyleEnumMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {rawValueStyleEnumMembersR0C1 -> rawValueStyleEnumMembersR0C2}
    rawValueStyleEnumMembersR0C0 -> rawValueStyleEnumMembersR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR1C0 -> rawValueStyleEnumMembersR1C1}
    rawValueStyleEnumMembersR0C2 -> rawValueStyleEnumMembersR1C2 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR1C1 -> rawValueStyleEnumMembersR1C2}
    rawValueStyleEnumMembersR1C0 -> rawValueStyleEnumMembersR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR2C0 -> rawValueStyleEnumMembersR2C1}
    rawValueStyleEnumMembersR1C2 -> rawValueStyleEnumMembersR2C2 [weight=100000000]
    rawValueStyleEnumMembersR2C0 -> rawValueStyleEnumMembersR3C0 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR3C0 -> rawValueStyleEnumMembersR3C1}
    rawValueStyleEnumMembersR3C0 -> rawValueStyleEnumMembersR4C0 [weight=100000000]
    rawValueStyleEnumMembersR3C1 -> rawValueStyleEnumMembersR4C1 [weight=100000000]
    rank = same {rawValueStyleEnumMembersR4C0 -> rawValueStyleEnumMembersR4C1}
    rank = same {rawValueStyleEnumMembersR4C1 -> rawValueStyleEnumMembersR4C2}
  }
  subgraph clusterclosureSignature {
    node [shape = box]
    label = <closureSignature = [ captureList ] closureParameterClause [ "async" ] [ throwsClause ] [ functionResult ] "in" | captureList "in" .>
    labeljust = l
    closureSignatureR0C0 [label = <AEK<br/>N closureSignature<br/>fi ["", "["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["["]<br/>>]
    closureSignatureR0C1 [label = <ADQ<br/>ALT <br/>fi ["", "["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR1C1 [label = <ADU<br/>OPT <br/>fi ["", "["]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureSignatureR2C1 [label = <ADV<br/>N closureParameterClause<br/>fi ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureSignatureR3C1 [label = <ADZ<br/>OPT <br/>fi ["", "async"]<br/>fo ["&gt;", "in", "throws"]<br/>am []<br/>>]
    closureSignatureR4C1 [label = <AED<br/>OPT <br/>fi ["", "throws"]<br/>fo ["&gt;", "in"]<br/>am []<br/>>]
    closureSignatureR5C1 [label = <AEH<br/>OPT <br/>fi ["", "&gt;"]<br/>fo ["in"]<br/>am []<br/>>]
    closureSignatureR6C1 [label = <AEI<br/>T "in"<br/>fi ["in"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR7C1 [label = <AEJ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR6C1 -> closureSignatureR7C1 [weight=100000000]
    closureSignatureR5C1 -> closureSignatureR6C1 [weight=100000000]
    closureSignatureR5C2 [label = <AEF<br/>ALT <br/>fi ["&gt;"]<br/>fo ["in"]<br/>am []<br/>>]
    closureSignatureR6C2 [label = <AEE<br/>N functionResult<br/>fi ["&gt;"]<br/>fo ["in"]<br/>am []<br/>>]
    closureSignatureR7C2 [label = <AEG<br/>END <br/>fi [""]<br/>fo ["in"]<br/>am []<br/>>]
    closureSignatureR6C2 -> closureSignatureR7C2 [weight=100000000]
    closureSignatureR5C2 -> closureSignatureR6C2 [weight=100000000]
    rank = same {closureSignatureR5C1 -> closureSignatureR5C2}
    closureSignatureR4C1 -> closureSignatureR5C1 [weight=100000000]
    closureSignatureR4C3 [label = <AEB<br/>ALT <br/>fi ["throws"]<br/>fo ["&gt;", "in"]<br/>am []<br/>>]
    closureSignatureR5C3 [label = <AEA<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["&gt;", "in"]<br/>am []<br/>>]
    closureSignatureR6C3 [label = <AEC<br/>END <br/>fi [""]<br/>fo ["&gt;", "in"]<br/>am []<br/>>]
    closureSignatureR5C3 -> closureSignatureR6C3 [weight=100000000]
    closureSignatureR4C3 -> closureSignatureR5C3 [weight=100000000]
    rank = same {closureSignatureR4C1 -> closureSignatureR4C3}
    closureSignatureR3C1 -> closureSignatureR4C1 [weight=100000000]
    closureSignatureR3C4 [label = <ADX<br/>ALT <br/>fi ["async"]<br/>fo ["&gt;", "in", "throws"]<br/>am []<br/>>]
    closureSignatureR4C4 [label = <ADW<br/>T "async"<br/>fi ["async"]<br/>fo ["&gt;", "in", "throws"]<br/>am []<br/>>]
    closureSignatureR5C4 [label = <ADY<br/>END <br/>fi [""]<br/>fo ["&gt;", "in", "throws"]<br/>am []<br/>>]
    closureSignatureR4C4 -> closureSignatureR5C4 [weight=100000000]
    closureSignatureR3C4 -> closureSignatureR4C4 [weight=100000000]
    rank = same {closureSignatureR3C1 -> closureSignatureR3C4}
    closureSignatureR2C1 -> closureSignatureR3C1 [weight=100000000]
    closureSignatureR1C1 -> closureSignatureR2C1 [weight=100000000]
    closureSignatureR1C5 [label = <ADS<br/>ALT <br/>fi ["["]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureSignatureR2C5 [label = <ADR<br/>N captureList<br/>fi ["["]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureSignatureR3C5 [label = <ADT<br/>END <br/>fi [""]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureSignatureR2C5 -> closureSignatureR3C5 [weight=100000000]
    closureSignatureR1C5 -> closureSignatureR2C5 [weight=100000000]
    rank = same {closureSignatureR1C1 -> closureSignatureR1C5}
    closureSignatureR0C1 -> closureSignatureR1C1 [weight=100000000]
    closureSignatureR0C6 [label = <AEL<br/>ALT <br/>fi ["["]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR1C6 [label = <AEM<br/>N captureList<br/>fi ["["]<br/>fo ["in"]<br/>am []<br/>>]
    closureSignatureR2C6 [label = <AEN<br/>T "in"<br/>fi ["in"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR3C6 [label = <AEO<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    closureSignatureR2C6 -> closureSignatureR3C6 [weight=100000000]
    closureSignatureR1C6 -> closureSignatureR2C6 [weight=100000000]
    closureSignatureR0C6 -> closureSignatureR1C6 [weight=100000000]
    rank = same {closureSignatureR0C1 -> closureSignatureR0C6}
    rank = same {closureSignatureR0C0 -> closureSignatureR0C1}
    node [style = invis]
    edge [style = invis]
    closureSignatureR0C0 -> closureSignatureR1C0 [weight=100000000]
    rank = same {closureSignatureR1C0 -> closureSignatureR1C1}
    closureSignatureR1C0 -> closureSignatureR2C0 [weight=100000000]
    rank = same {closureSignatureR2C0 -> closureSignatureR2C1}
    rank = same {closureSignatureR2C1 -> closureSignatureR2C2}
    rank = same {closureSignatureR2C2 -> closureSignatureR2C3}
    rank = same {closureSignatureR2C3 -> closureSignatureR2C4}
    rank = same {closureSignatureR2C4 -> closureSignatureR2C5}
    closureSignatureR2C0 -> closureSignatureR3C0 [weight=100000000]
    rank = same {closureSignatureR3C0 -> closureSignatureR3C1}
    closureSignatureR2C4 -> closureSignatureR3C4 [weight=100000000]
    closureSignatureR3C0 -> closureSignatureR4C0 [weight=100000000]
    rank = same {closureSignatureR4C0 -> closureSignatureR4C1}
    closureSignatureR3C5 -> closureSignatureR4C5 [weight=100000000]
    rank = same {closureSignatureR4C4 -> closureSignatureR4C5}
    closureSignatureR3C6 -> closureSignatureR4C6 [weight=100000000]
    rank = same {closureSignatureR4C5 -> closureSignatureR4C6}
    closureSignatureR4C0 -> closureSignatureR5C0 [weight=100000000]
    rank = same {closureSignatureR5C0 -> closureSignatureR5C1}
    closureSignatureR4C5 -> closureSignatureR5C5 [weight=100000000]
    rank = same {closureSignatureR5C4 -> closureSignatureR5C5}
    closureSignatureR4C6 -> closureSignatureR5C6 [weight=100000000]
    rank = same {closureSignatureR5C5 -> closureSignatureR5C6}
    closureSignatureR5C0 -> closureSignatureR6C0 [weight=100000000]
    rank = same {closureSignatureR6C0 -> closureSignatureR6C1}
    closureSignatureR5C4 -> closureSignatureR6C4 [weight=100000000]
    rank = same {closureSignatureR6C3 -> closureSignatureR6C4}
    closureSignatureR5C5 -> closureSignatureR6C5 [weight=100000000]
    rank = same {closureSignatureR6C4 -> closureSignatureR6C5}
    closureSignatureR5C6 -> closureSignatureR6C6 [weight=100000000]
    rank = same {closureSignatureR6C5 -> closureSignatureR6C6}
    closureSignatureR6C0 -> closureSignatureR7C0 [weight=100000000]
    rank = same {closureSignatureR7C0 -> closureSignatureR7C1}
    closureSignatureR6C3 -> closureSignatureR7C3 [weight=100000000]
    rank = same {closureSignatureR7C2 -> closureSignatureR7C3}
    closureSignatureR6C4 -> closureSignatureR7C4 [weight=100000000]
    rank = same {closureSignatureR7C3 -> closureSignatureR7C4}
    closureSignatureR6C5 -> closureSignatureR7C5 [weight=100000000]
    rank = same {closureSignatureR7C4 -> closureSignatureR7C5}
    closureSignatureR6C6 -> closureSignatureR7C6 [weight=100000000]
    rank = same {closureSignatureR7C5 -> closureSignatureR7C6}
  }
  subgraph clusterprecedenceGroupDeclaration {
    node [shape = box]
    label = <precedenceGroupDeclaration = "precedencegroup" precedenceGroupName "{" [ precedenceGroupAttributes ] "}" .>
    labeljust = l
    precedenceGroupDeclarationR0C0 [label = <DXO<br/>N precedenceGroupDeclaration<br/>fi ["precedencegroup"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR0C1 [label = <DXE<br/>ALT <br/>fi ["precedencegroup"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR1C1 [label = <DXF<br/>T "precedencegroup"<br/>fi ["precedencegroup"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    precedenceGroupDeclarationR2C1 [label = <DXG<br/>N precedenceGroupName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["{"]<br/>am []<br/>>]
    precedenceGroupDeclarationR3C1 [label = <DXH<br/>T "{"<br/>fi ["{"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR4C1 [label = <DXL<br/>OPT <br/>fi ["", "assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR5C1 [label = <DXM<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR6C1 [label = <DXN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR5C1 -> precedenceGroupDeclarationR6C1 [weight=100000000]
    precedenceGroupDeclarationR4C1 -> precedenceGroupDeclarationR5C1 [weight=100000000]
    precedenceGroupDeclarationR4C2 [label = <DXJ<br/>ALT <br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR5C2 [label = <DXI<br/>N precedenceGroupAttributes<br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR6C2 [label = <DXK<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    precedenceGroupDeclarationR5C2 -> precedenceGroupDeclarationR6C2 [weight=100000000]
    precedenceGroupDeclarationR4C2 -> precedenceGroupDeclarationR5C2 [weight=100000000]
    rank = same {precedenceGroupDeclarationR4C1 -> precedenceGroupDeclarationR4C2}
    precedenceGroupDeclarationR3C1 -> precedenceGroupDeclarationR4C1 [weight=100000000]
    precedenceGroupDeclarationR2C1 -> precedenceGroupDeclarationR3C1 [weight=100000000]
    precedenceGroupDeclarationR1C1 -> precedenceGroupDeclarationR2C1 [weight=100000000]
    precedenceGroupDeclarationR0C1 -> precedenceGroupDeclarationR1C1 [weight=100000000]
    rank = same {precedenceGroupDeclarationR0C0 -> precedenceGroupDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {precedenceGroupDeclarationR0C1 -> precedenceGroupDeclarationR0C2}
    precedenceGroupDeclarationR0C0 -> precedenceGroupDeclarationR1C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR1C0 -> precedenceGroupDeclarationR1C1}
    precedenceGroupDeclarationR0C2 -> precedenceGroupDeclarationR1C2 [weight=100000000]
    rank = same {precedenceGroupDeclarationR1C1 -> precedenceGroupDeclarationR1C2}
    precedenceGroupDeclarationR1C0 -> precedenceGroupDeclarationR2C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR2C0 -> precedenceGroupDeclarationR2C1}
    precedenceGroupDeclarationR1C2 -> precedenceGroupDeclarationR2C2 [weight=100000000]
    rank = same {precedenceGroupDeclarationR2C1 -> precedenceGroupDeclarationR2C2}
    precedenceGroupDeclarationR2C0 -> precedenceGroupDeclarationR3C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR3C0 -> precedenceGroupDeclarationR3C1}
    precedenceGroupDeclarationR2C2 -> precedenceGroupDeclarationR3C2 [weight=100000000]
    rank = same {precedenceGroupDeclarationR3C1 -> precedenceGroupDeclarationR3C2}
    precedenceGroupDeclarationR3C0 -> precedenceGroupDeclarationR4C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR4C0 -> precedenceGroupDeclarationR4C1}
    precedenceGroupDeclarationR3C2 -> precedenceGroupDeclarationR4C2 [weight=100000000]
    precedenceGroupDeclarationR4C0 -> precedenceGroupDeclarationR5C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR5C0 -> precedenceGroupDeclarationR5C1}
    precedenceGroupDeclarationR5C0 -> precedenceGroupDeclarationR6C0 [weight=100000000]
    rank = same {precedenceGroupDeclarationR6C0 -> precedenceGroupDeclarationR6C1}
  }
  subgraph clusterpostfixOperator {
    node [shape = box]
    label = <postfixOperator = Operator .>
    labeljust = l
    postfixOperatorR0C0 [label = <DX<br/>N postfixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixOperatorR0C1 [label = <DU<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixOperatorR1C1 [label = <DV<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixOperatorR2C1 [label = <DW<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    postfixOperatorR1C1 -> postfixOperatorR2C1 [weight=100000000]
    postfixOperatorR0C1 -> postfixOperatorR1C1 [weight=100000000]
    rank = same {postfixOperatorR0C0 -> postfixOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    postfixOperatorR0C0 -> postfixOperatorR1C0 [weight=100000000]
    rank = same {postfixOperatorR1C0 -> postfixOperatorR1C1}
    postfixOperatorR1C0 -> postfixOperatorR2C0 [weight=100000000]
    rank = same {postfixOperatorR2C0 -> postfixOperatorR2C1}
  }
  subgraph clusterpattern {
    node [shape = box]
    label = <pattern = wildcardPattern [ typeAnnotation ] | identifierPattern [ typeAnnotation ] | valueBindingPattern | tuplePattern [ typeAnnotation ] | enumCasePattern | optionalPattern | typeCastingPattern | expressionPattern .>
    labeljust = l
    patternR0C0 [label = <EJC<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["(", "_", "escapedIdentifier", "implicitParameterName", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>>]
    patternR0C1 [label = <EIV<br/>ALT <br/>fi ["_"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C1 [label = <EIW<br/>N wildcardPattern<br/>fi ["_"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C1 [label = <EJA<br/>OPT <br/>fi ["", ":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am [":"]<br/>>]
    patternR3C1 [label = <EJB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C1 -> patternR3C1 [weight=100000000]
    patternR2C2 [label = <EIY<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C2 [label = <EIX<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR4C2 [label = <EIZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C2 -> patternR4C2 [weight=100000000]
    patternR2C2 -> patternR3C2 [weight=100000000]
    rank = same {patternR2C1 -> patternR2C2}
    patternR1C1 -> patternR2C1 [weight=100000000]
    patternR0C1 -> patternR1C1 [weight=100000000]
    patternR0C3 [label = <EJD<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C3 [label = <EJE<br/>N identifierPattern<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C3 [label = <EJI<br/>OPT <br/>fi ["", ":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am [":"]<br/>>]
    patternR3C3 [label = <EJJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C3 -> patternR3C3 [weight=100000000]
    patternR2C4 [label = <EJG<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C4 [label = <EJF<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR4C4 [label = <EJH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C4 -> patternR4C4 [weight=100000000]
    patternR2C4 -> patternR3C4 [weight=100000000]
    rank = same {patternR2C3 -> patternR2C4}
    patternR1C3 -> patternR2C3 [weight=100000000]
    patternR0C3 -> patternR1C3 [weight=100000000]
    patternR0C5 [label = <EJK<br/>ALT <br/>fi ["let", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C5 [label = <EJL<br/>N valueBindingPattern<br/>fi ["let", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C5 [label = <EJM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C5 -> patternR2C5 [weight=100000000]
    patternR0C5 -> patternR1C5 [weight=100000000]
    patternR0C6 [label = <EJN<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C6 [label = <EJO<br/>N tuplePattern<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C6 [label = <EJS<br/>OPT <br/>fi ["", ":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am [":"]<br/>>]
    patternR3C6 [label = <EJT<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C6 -> patternR3C6 [weight=100000000]
    patternR2C7 [label = <EJQ<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C7 [label = <EJP<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR4C7 [label = <EJR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR3C7 -> patternR4C7 [weight=100000000]
    patternR2C7 -> patternR3C7 [weight=100000000]
    rank = same {patternR2C6 -> patternR2C7}
    patternR1C6 -> patternR2C6 [weight=100000000]
    patternR0C6 -> patternR1C6 [weight=100000000]
    patternR0C8 [label = <EJU<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    patternR1C8 [label = <EJV<br/>N enumCasePattern<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    patternR2C8 [label = <EJW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C8 -> patternR2C8 [weight=100000000]
    patternR0C8 -> patternR1C8 [weight=100000000]
    patternR0C9 [label = <EJX<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C9 [label = <EJY<br/>N optionalPattern<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR2C9 [label = <EJZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C9 -> patternR2C9 [weight=100000000]
    patternR0C9 -> patternR1C9 [weight=100000000]
    patternR0C10 [label = <EKA<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternR1C10 [label = <EKB<br/>N typeCastingPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternR2C10 [label = <EKC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C10 -> patternR2C10 [weight=100000000]
    patternR0C10 -> patternR1C10 [weight=100000000]
    patternR0C11 [label = <EKD<br/>ALT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    patternR1C11 [label = <EKE<br/>N expressionPattern<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    patternR2C11 [label = <EKF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    patternR1C11 -> patternR2C11 [weight=100000000]
    patternR0C11 -> patternR1C11 [weight=100000000]
    rank = same {patternR0C10 -> patternR0C11}
    rank = same {patternR0C9 -> patternR0C10}
    rank = same {patternR0C8 -> patternR0C9}
    rank = same {patternR0C6 -> patternR0C8}
    rank = same {patternR0C5 -> patternR0C6}
    rank = same {patternR0C3 -> patternR0C5}
    rank = same {patternR0C1 -> patternR0C3}
    rank = same {patternR0C0 -> patternR0C1}
    node [style = invis]
    edge [style = invis]
    patternR0C0 -> patternR1C0 [weight=100000000]
    rank = same {patternR1C0 -> patternR1C1}
    rank = same {patternR1C1 -> patternR1C2}
    rank = same {patternR1C2 -> patternR1C3}
    rank = same {patternR1C3 -> patternR1C4}
    rank = same {patternR1C4 -> patternR1C5}
    rank = same {patternR1C6 -> patternR1C7}
    rank = same {patternR1C7 -> patternR1C8}
    patternR1C0 -> patternR2C0 [weight=100000000]
    rank = same {patternR2C0 -> patternR2C1}
    patternR1C2 -> patternR2C2 [weight=100000000]
    patternR1C4 -> patternR2C4 [weight=100000000]
    patternR1C7 -> patternR2C7 [weight=100000000]
    patternR2C0 -> patternR3C0 [weight=100000000]
    rank = same {patternR3C0 -> patternR3C1}
    patternR2C5 -> patternR3C5 [weight=100000000]
    rank = same {patternR3C4 -> patternR3C5}
    rank = same {patternR3C5 -> patternR3C6}
    patternR2C8 -> patternR3C8 [weight=100000000]
    rank = same {patternR3C7 -> patternR3C8}
    patternR2C9 -> patternR3C9 [weight=100000000]
    rank = same {patternR3C8 -> patternR3C9}
    patternR2C10 -> patternR3C10 [weight=100000000]
    rank = same {patternR3C9 -> patternR3C10}
    patternR2C11 -> patternR3C11 [weight=100000000]
    rank = same {patternR3C10 -> patternR3C11}
    patternR3C0 -> patternR4C0 [weight=100000000]
    patternR3C1 -> patternR4C1 [weight=100000000]
    rank = same {patternR4C0 -> patternR4C1}
    rank = same {patternR4C1 -> patternR4C2}
    patternR3C3 -> patternR4C3 [weight=100000000]
    rank = same {patternR4C2 -> patternR4C3}
    rank = same {patternR4C3 -> patternR4C4}
    patternR3C5 -> patternR4C5 [weight=100000000]
    rank = same {patternR4C4 -> patternR4C5}
    patternR3C6 -> patternR4C6 [weight=100000000]
    rank = same {patternR4C5 -> patternR4C6}
    rank = same {patternR4C6 -> patternR4C7}
    patternR3C8 -> patternR4C8 [weight=100000000]
    rank = same {patternR4C7 -> patternR4C8}
    patternR3C9 -> patternR4C9 [weight=100000000]
    rank = same {patternR4C8 -> patternR4C9}
    patternR3C10 -> patternR4C10 [weight=100000000]
    rank = same {patternR4C9 -> patternR4C10}
    patternR3C11 -> patternR4C11 [weight=100000000]
    rank = same {patternR4C10 -> patternR4C11}
  }
  subgraph clustergenericParameter {
    node [shape = box]
    label = <genericParameter = typeName | typeName ":" typeIdentifier | typeName ":" protocolCompositionType .>
    labeljust = l
    genericParameterR0C0 [label = <EOE<br/>N genericParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    genericParameterR0C1 [label = <EOB<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR1C1 [label = <EOC<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR2C1 [label = <EOD<br/>END <br/>fi [""]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR1C1 -> genericParameterR2C1 [weight=100000000]
    genericParameterR0C1 -> genericParameterR1C1 [weight=100000000]
    genericParameterR0C2 [label = <EOF<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR1C2 [label = <EOG<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    genericParameterR2C2 [label = <EOH<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    genericParameterR3C2 [label = <EOI<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR4C2 [label = <EOJ<br/>END <br/>fi [""]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR3C2 -> genericParameterR4C2 [weight=100000000]
    genericParameterR2C2 -> genericParameterR3C2 [weight=100000000]
    genericParameterR1C2 -> genericParameterR2C2 [weight=100000000]
    genericParameterR0C2 -> genericParameterR1C2 [weight=100000000]
    genericParameterR0C3 [label = <EOK<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR1C3 [label = <EOL<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    genericParameterR2C3 [label = <EOM<br/>T ":"<br/>fi [":"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    genericParameterR3C3 [label = <EON<br/>N protocolCompositionType<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR4C3 [label = <EOO<br/>END <br/>fi [""]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericParameterR3C3 -> genericParameterR4C3 [weight=100000000]
    genericParameterR2C3 -> genericParameterR3C3 [weight=100000000]
    genericParameterR1C3 -> genericParameterR2C3 [weight=100000000]
    genericParameterR0C3 -> genericParameterR1C3 [weight=100000000]
    rank = same {genericParameterR0C2 -> genericParameterR0C3}
    rank = same {genericParameterR0C1 -> genericParameterR0C2}
    rank = same {genericParameterR0C0 -> genericParameterR0C1}
    node [style = invis]
    edge [style = invis]
    genericParameterR0C0 -> genericParameterR1C0 [weight=100000000]
    rank = same {genericParameterR1C0 -> genericParameterR1C1}
    genericParameterR1C0 -> genericParameterR2C0 [weight=100000000]
    rank = same {genericParameterR2C0 -> genericParameterR2C1}
    genericParameterR2C0 -> genericParameterR3C0 [weight=100000000]
    genericParameterR2C1 -> genericParameterR3C1 [weight=100000000]
    rank = same {genericParameterR3C0 -> genericParameterR3C1}
    rank = same {genericParameterR3C1 -> genericParameterR3C2}
    genericParameterR3C0 -> genericParameterR4C0 [weight=100000000]
    genericParameterR3C1 -> genericParameterR4C1 [weight=100000000]
    rank = same {genericParameterR4C0 -> genericParameterR4C1}
    rank = same {genericParameterR4C1 -> genericParameterR4C2}
  }
  subgraph clustersuperclassMethodExpression {
    node [shape = box]
    label = <superclassMethodExpression = "super" "." identifier .>
    labeljust = l
    superclassMethodExpressionR0C0 [label = <AAL<br/>N superclassMethodExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassMethodExpressionR0C1 [label = <AAG<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassMethodExpressionR1C1 [label = <AAH<br/>T "super"<br/>fi ["super"]<br/>fo ["."]<br/>am []<br/>>]
    superclassMethodExpressionR2C1 [label = <AAI<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    superclassMethodExpressionR3C1 [label = <AAJ<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassMethodExpressionR4C1 [label = <AAK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassMethodExpressionR3C1 -> superclassMethodExpressionR4C1 [weight=100000000]
    superclassMethodExpressionR2C1 -> superclassMethodExpressionR3C1 [weight=100000000]
    superclassMethodExpressionR1C1 -> superclassMethodExpressionR2C1 [weight=100000000]
    superclassMethodExpressionR0C1 -> superclassMethodExpressionR1C1 [weight=100000000]
    rank = same {superclassMethodExpressionR0C0 -> superclassMethodExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    superclassMethodExpressionR0C0 -> superclassMethodExpressionR1C0 [weight=100000000]
    rank = same {superclassMethodExpressionR1C0 -> superclassMethodExpressionR1C1}
    superclassMethodExpressionR1C0 -> superclassMethodExpressionR2C0 [weight=100000000]
    rank = same {superclassMethodExpressionR2C0 -> superclassMethodExpressionR2C1}
    superclassMethodExpressionR2C0 -> superclassMethodExpressionR3C0 [weight=100000000]
    rank = same {superclassMethodExpressionR3C0 -> superclassMethodExpressionR3C1}
    superclassMethodExpressionR3C0 -> superclassMethodExpressionR4C0 [weight=100000000]
    rank = same {superclassMethodExpressionR4C0 -> superclassMethodExpressionR4C1}
  }
  subgraph clusterarrayLiteralItems {
    node [shape = box]
    label = <arrayLiteralItems = arrayLiteralItem [ "," ] | arrayLiteralItem "," arrayLiteralItems .>
    labeljust = l
    arrayLiteralItemsR0C0 [label = <VW<br/>N arrayLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am ["try"]<br/>>]
    arrayLiteralItemsR0C1 [label = <VK<br/>ALT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR1C1 [label = <VL<br/>N arrayLiteralItem<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    arrayLiteralItemsR2C1 [label = <VP<br/>OPT <br/>fi ["", ","]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR3C1 [label = <VQ<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR2C1 -> arrayLiteralItemsR3C1 [weight=100000000]
    arrayLiteralItemsR2C2 [label = <VN<br/>ALT <br/>fi [","]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR3C2 [label = <VM<br/>T ","<br/>fi [","]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR4C2 [label = <VO<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR3C2 -> arrayLiteralItemsR4C2 [weight=100000000]
    arrayLiteralItemsR2C2 -> arrayLiteralItemsR3C2 [weight=100000000]
    rank = same {arrayLiteralItemsR2C1 -> arrayLiteralItemsR2C2}
    arrayLiteralItemsR1C1 -> arrayLiteralItemsR2C1 [weight=100000000]
    arrayLiteralItemsR0C1 -> arrayLiteralItemsR1C1 [weight=100000000]
    arrayLiteralItemsR0C3 [label = <VR<br/>ALT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR1C3 [label = <VS<br/>N arrayLiteralItem<br/>fi ["", "try"]<br/>fo [","]<br/>am []<br/>>]
    arrayLiteralItemsR2C3 [label = <VT<br/>T ","<br/>fi [","]<br/>fo ["]", "try"]<br/>am []<br/>>]
    arrayLiteralItemsR3C3 [label = <VU<br/>N arrayLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR4C3 [label = <VV<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    arrayLiteralItemsR3C3 -> arrayLiteralItemsR4C3 [weight=100000000]
    arrayLiteralItemsR2C3 -> arrayLiteralItemsR3C3 [weight=100000000]
    arrayLiteralItemsR1C3 -> arrayLiteralItemsR2C3 [weight=100000000]
    arrayLiteralItemsR0C3 -> arrayLiteralItemsR1C3 [weight=100000000]
    rank = same {arrayLiteralItemsR0C1 -> arrayLiteralItemsR0C3}
    rank = same {arrayLiteralItemsR0C0 -> arrayLiteralItemsR0C1}
    node [style = invis]
    edge [style = invis]
    arrayLiteralItemsR0C0 -> arrayLiteralItemsR1C0 [weight=100000000]
    rank = same {arrayLiteralItemsR1C0 -> arrayLiteralItemsR1C1}
    rank = same {arrayLiteralItemsR1C1 -> arrayLiteralItemsR1C2}
    rank = same {arrayLiteralItemsR1C2 -> arrayLiteralItemsR1C3}
    arrayLiteralItemsR1C0 -> arrayLiteralItemsR2C0 [weight=100000000]
    rank = same {arrayLiteralItemsR2C0 -> arrayLiteralItemsR2C1}
    arrayLiteralItemsR1C2 -> arrayLiteralItemsR2C2 [weight=100000000]
    arrayLiteralItemsR2C0 -> arrayLiteralItemsR3C0 [weight=100000000]
    rank = same {arrayLiteralItemsR3C0 -> arrayLiteralItemsR3C1}
    arrayLiteralItemsR3C0 -> arrayLiteralItemsR4C0 [weight=100000000]
    arrayLiteralItemsR3C1 -> arrayLiteralItemsR4C1 [weight=100000000]
    rank = same {arrayLiteralItemsR4C0 -> arrayLiteralItemsR4C1}
    rank = same {arrayLiteralItemsR4C1 -> arrayLiteralItemsR4C2}
  }
  subgraph clustersubscriptExpression {
    node [shape = box]
    label = <subscriptExpression = postfixExpression "[" functionCallArgumentList "]" .>
    labeljust = l
    subscriptExpressionR0C0 [label = <AUF<br/>N subscriptExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    subscriptExpressionR0C1 [label = <ATZ<br/>ALT <br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    subscriptExpressionR1C1 [label = <AUA<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["["]<br/>am []<br/>>]
    subscriptExpressionR2C1 [label = <AUB<br/>T "["<br/>fi ["["]<br/>fo ["]", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    subscriptExpressionR3C1 [label = <AUC<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    subscriptExpressionR4C1 [label = <AUD<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    subscriptExpressionR5C1 [label = <AUE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    subscriptExpressionR4C1 -> subscriptExpressionR5C1 [weight=100000000]
    subscriptExpressionR3C1 -> subscriptExpressionR4C1 [weight=100000000]
    subscriptExpressionR2C1 -> subscriptExpressionR3C1 [weight=100000000]
    subscriptExpressionR1C1 -> subscriptExpressionR2C1 [weight=100000000]
    subscriptExpressionR0C1 -> subscriptExpressionR1C1 [weight=100000000]
    rank = same {subscriptExpressionR0C0 -> subscriptExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    subscriptExpressionR0C0 -> subscriptExpressionR1C0 [weight=100000000]
    rank = same {subscriptExpressionR1C0 -> subscriptExpressionR1C1}
    subscriptExpressionR1C0 -> subscriptExpressionR2C0 [weight=100000000]
    rank = same {subscriptExpressionR2C0 -> subscriptExpressionR2C1}
    subscriptExpressionR2C0 -> subscriptExpressionR3C0 [weight=100000000]
    rank = same {subscriptExpressionR3C0 -> subscriptExpressionR3C1}
    subscriptExpressionR3C0 -> subscriptExpressionR4C0 [weight=100000000]
    rank = same {subscriptExpressionR4C0 -> subscriptExpressionR4C1}
    subscriptExpressionR4C0 -> subscriptExpressionR5C0 [weight=100000000]
    rank = same {subscriptExpressionR5C0 -> subscriptExpressionR5C1}
  }
  subgraph clusteroptionalPattern {
    node [shape = box]
    label = <optionalPattern = identifierPattern "?" .>
    labeljust = l
    optionalPatternR0C0 [label = <EMP<br/>N optionalPattern<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalPatternR0C1 [label = <EML<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalPatternR1C1 [label = <EMM<br/>N identifierPattern<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["?"]<br/>am []<br/>>]
    optionalPatternR2C1 [label = <EMN<br/>T "?"<br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalPatternR3C1 [label = <EMO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalPatternR2C1 -> optionalPatternR3C1 [weight=100000000]
    optionalPatternR1C1 -> optionalPatternR2C1 [weight=100000000]
    optionalPatternR0C1 -> optionalPatternR1C1 [weight=100000000]
    rank = same {optionalPatternR0C0 -> optionalPatternR0C1}
    node [style = invis]
    edge [style = invis]
    optionalPatternR0C0 -> optionalPatternR1C0 [weight=100000000]
    rank = same {optionalPatternR1C0 -> optionalPatternR1C1}
    optionalPatternR1C0 -> optionalPatternR2C0 [weight=100000000]
    rank = same {optionalPatternR2C0 -> optionalPatternR2C1}
    optionalPatternR2C0 -> optionalPatternR3C0 [weight=100000000]
    rank = same {optionalPatternR3C0 -> optionalPatternR3C1}
  }
  subgraph clusterarrayLiteralItem {
    node [shape = box]
    label = <arrayLiteralItem = expression .>
    labeljust = l
    arrayLiteralItemR0C0 [label = <WA<br/>N arrayLiteralItem<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    arrayLiteralItemR0C1 [label = <VX<br/>ALT <br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    arrayLiteralItemR1C1 [label = <VY<br/>N expression<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    arrayLiteralItemR2C1 [label = <VZ<br/>END <br/>fi [""]<br/>fo [",", "]"]<br/>am []<br/>>]
    arrayLiteralItemR1C1 -> arrayLiteralItemR2C1 [weight=100000000]
    arrayLiteralItemR0C1 -> arrayLiteralItemR1C1 [weight=100000000]
    rank = same {arrayLiteralItemR0C0 -> arrayLiteralItemR0C1}
    node [style = invis]
    edge [style = invis]
    arrayLiteralItemR0C0 -> arrayLiteralItemR1C0 [weight=100000000]
    rank = same {arrayLiteralItemR1C0 -> arrayLiteralItemR1C1}
    arrayLiteralItemR1C0 -> arrayLiteralItemR2C0 [weight=100000000]
    rank = same {arrayLiteralItemR2C0 -> arrayLiteralItemR2C1}
  }
  subgraph clustergetterKeywordClause {
    node [shape = box]
    label = <getterKeywordClause = [ attributes ] [ mutationModifier ] "get" .>
    labeljust = l
    getterKeywordClauseR0C0 [label = <CIW<br/>N getterKeywordClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterKeywordClauseR0C1 [label = <CIL<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterKeywordClauseR1C1 [label = <CIP<br/>OPT <br/>fi ["", "@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterKeywordClauseR2C1 [label = <CIT<br/>OPT <br/>fi ["", "mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterKeywordClauseR3C1 [label = <CIU<br/>T "get"<br/>fi ["get"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterKeywordClauseR4C1 [label = <CIV<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterKeywordClauseR3C1 -> getterKeywordClauseR4C1 [weight=100000000]
    getterKeywordClauseR2C1 -> getterKeywordClauseR3C1 [weight=100000000]
    getterKeywordClauseR2C2 [label = <CIR<br/>ALT <br/>fi ["mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterKeywordClauseR3C2 [label = <CIQ<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["get"]<br/>am []<br/>>]
    getterKeywordClauseR4C2 [label = <CIS<br/>END <br/>fi [""]<br/>fo ["get"]<br/>am []<br/>>]
    getterKeywordClauseR3C2 -> getterKeywordClauseR4C2 [weight=100000000]
    getterKeywordClauseR2C2 -> getterKeywordClauseR3C2 [weight=100000000]
    rank = same {getterKeywordClauseR2C1 -> getterKeywordClauseR2C2}
    getterKeywordClauseR1C1 -> getterKeywordClauseR2C1 [weight=100000000]
    getterKeywordClauseR1C3 [label = <CIN<br/>ALT <br/>fi ["@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterKeywordClauseR2C3 [label = <CIM<br/>N attributes<br/>fi ["@"]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterKeywordClauseR3C3 [label = <CIO<br/>END <br/>fi [""]<br/>fo ["get", "mutating", "nonmutating"]<br/>am []<br/>>]
    getterKeywordClauseR2C3 -> getterKeywordClauseR3C3 [weight=100000000]
    getterKeywordClauseR1C3 -> getterKeywordClauseR2C3 [weight=100000000]
    rank = same {getterKeywordClauseR1C1 -> getterKeywordClauseR1C3}
    getterKeywordClauseR0C1 -> getterKeywordClauseR1C1 [weight=100000000]
    rank = same {getterKeywordClauseR0C0 -> getterKeywordClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {getterKeywordClauseR0C1 -> getterKeywordClauseR0C2}
    rank = same {getterKeywordClauseR0C2 -> getterKeywordClauseR0C3}
    getterKeywordClauseR0C0 -> getterKeywordClauseR1C0 [weight=100000000]
    rank = same {getterKeywordClauseR1C0 -> getterKeywordClauseR1C1}
    getterKeywordClauseR0C3 -> getterKeywordClauseR1C3 [weight=100000000]
    getterKeywordClauseR1C0 -> getterKeywordClauseR2C0 [weight=100000000]
    rank = same {getterKeywordClauseR2C0 -> getterKeywordClauseR2C1}
    getterKeywordClauseR2C0 -> getterKeywordClauseR3C0 [weight=100000000]
    rank = same {getterKeywordClauseR3C0 -> getterKeywordClauseR3C1}
    getterKeywordClauseR3C0 -> getterKeywordClauseR4C0 [weight=100000000]
    rank = same {getterKeywordClauseR4C0 -> getterKeywordClauseR4C1}
    getterKeywordClauseR3C3 -> getterKeywordClauseR4C3 [weight=100000000]
    rank = same {getterKeywordClauseR4C2 -> getterKeywordClauseR4C3}
  }
  subgraph clusterfunctionBody {
    node [shape = box]
    label = <functionBody = codeBlock .>
    labeljust = l
    functionBodyR0C0 [label = <CPC<br/>N functionBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionBodyR0C1 [label = <COZ<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionBodyR1C1 [label = <CPA<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionBodyR2C1 [label = <CPB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionBodyR1C1 -> functionBodyR2C1 [weight=100000000]
    functionBodyR0C1 -> functionBodyR1C1 [weight=100000000]
    rank = same {functionBodyR0C0 -> functionBodyR0C1}
    node [style = invis]
    edge [style = invis]
    functionBodyR0C0 -> functionBodyR1C0 [weight=100000000]
    rank = same {functionBodyR1C0 -> functionBodyR1C1}
    functionBodyR1C0 -> functionBodyR2C0 [weight=100000000]
    rank = same {functionBodyR2C0 -> functionBodyR2C1}
  }
  subgraph clusterclosureParameter {
    node [shape = box]
    label = <closureParameter = closureParameterName [ typeAnnotation ] | closureParameterName typeAnnotation "..." .>
    labeljust = l
    closureParameterR0C0 [label = <AFS<br/>N closureParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    closureParameterR0C1 [label = <AFL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR1C1 [label = <AFM<br/>N closureParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", ":"]<br/>am []<br/>>]
    closureParameterR2C1 [label = <AFQ<br/>OPT <br/>fi ["", ":"]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR3C1 [label = <AFR<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR2C1 -> closureParameterR3C1 [weight=100000000]
    closureParameterR2C2 [label = <AFO<br/>ALT <br/>fi [":"]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR3C2 [label = <AFN<br/>N typeAnnotation<br/>fi [":"]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR4C2 [label = <AFP<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR3C2 -> closureParameterR4C2 [weight=100000000]
    closureParameterR2C2 -> closureParameterR3C2 [weight=100000000]
    rank = same {closureParameterR2C1 -> closureParameterR2C2}
    closureParameterR1C1 -> closureParameterR2C1 [weight=100000000]
    closureParameterR0C1 -> closureParameterR1C1 [weight=100000000]
    closureParameterR0C3 [label = <AFT<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR1C3 [label = <AFU<br/>N closureParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    closureParameterR2C3 [label = <AFV<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["..."]<br/>am []<br/>>]
    closureParameterR3C3 [label = <AFW<br/>T "..."<br/>fi ["..."]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR4C3 [label = <AFX<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    closureParameterR3C3 -> closureParameterR4C3 [weight=100000000]
    closureParameterR2C3 -> closureParameterR3C3 [weight=100000000]
    closureParameterR1C3 -> closureParameterR2C3 [weight=100000000]
    closureParameterR0C3 -> closureParameterR1C3 [weight=100000000]
    rank = same {closureParameterR0C1 -> closureParameterR0C3}
    rank = same {closureParameterR0C0 -> closureParameterR0C1}
    node [style = invis]
    edge [style = invis]
    closureParameterR0C0 -> closureParameterR1C0 [weight=100000000]
    rank = same {closureParameterR1C0 -> closureParameterR1C1}
    rank = same {closureParameterR1C1 -> closureParameterR1C2}
    rank = same {closureParameterR1C2 -> closureParameterR1C3}
    closureParameterR1C0 -> closureParameterR2C0 [weight=100000000]
    rank = same {closureParameterR2C0 -> closureParameterR2C1}
    closureParameterR1C2 -> closureParameterR2C2 [weight=100000000]
    closureParameterR2C0 -> closureParameterR3C0 [weight=100000000]
    rank = same {closureParameterR3C0 -> closureParameterR3C1}
    closureParameterR3C0 -> closureParameterR4C0 [weight=100000000]
    closureParameterR3C1 -> closureParameterR4C1 [weight=100000000]
    rank = same {closureParameterR4C0 -> closureParameterR4C1}
    rank = same {closureParameterR4C1 -> closureParameterR4C2}
  }
  subgraph clustermetatypeType {
    node [shape = box]
    label = <metatypeType = type "." "Type" | type "." "Protocol" .>
    labeljust = l
    metatypeTypeR0C0 [label = <NB<br/>N metatypeType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>>]
    metatypeTypeR0C1 [label = <MR<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    metatypeTypeR1C1 [label = <MS<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["."]<br/>am []<br/>>]
    metatypeTypeR2C1 [label = <MT<br/>T "."<br/>fi ["."]<br/>fo ["Type"]<br/>am []<br/>>]
    metatypeTypeR3C1 [label = <MU<br/>T "Type"<br/>fi ["Type"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    metatypeTypeR4C1 [label = <MV<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    metatypeTypeR3C1 -> metatypeTypeR4C1 [weight=100000000]
    metatypeTypeR2C1 -> metatypeTypeR3C1 [weight=100000000]
    metatypeTypeR1C1 -> metatypeTypeR2C1 [weight=100000000]
    metatypeTypeR0C1 -> metatypeTypeR1C1 [weight=100000000]
    metatypeTypeR0C2 [label = <MW<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    metatypeTypeR1C2 [label = <MX<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["."]<br/>am []<br/>>]
    metatypeTypeR2C2 [label = <MY<br/>T "."<br/>fi ["."]<br/>fo ["Protocol"]<br/>am []<br/>>]
    metatypeTypeR3C2 [label = <MZ<br/>T "Protocol"<br/>fi ["Protocol"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    metatypeTypeR4C2 [label = <NA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    metatypeTypeR3C2 -> metatypeTypeR4C2 [weight=100000000]
    metatypeTypeR2C2 -> metatypeTypeR3C2 [weight=100000000]
    metatypeTypeR1C2 -> metatypeTypeR2C2 [weight=100000000]
    metatypeTypeR0C2 -> metatypeTypeR1C2 [weight=100000000]
    rank = same {metatypeTypeR0C1 -> metatypeTypeR0C2}
    rank = same {metatypeTypeR0C0 -> metatypeTypeR0C1}
    node [style = invis]
    edge [style = invis]
    metatypeTypeR0C0 -> metatypeTypeR1C0 [weight=100000000]
    rank = same {metatypeTypeR1C0 -> metatypeTypeR1C1}
    metatypeTypeR1C0 -> metatypeTypeR2C0 [weight=100000000]
    rank = same {metatypeTypeR2C0 -> metatypeTypeR2C1}
    metatypeTypeR2C0 -> metatypeTypeR3C0 [weight=100000000]
    rank = same {metatypeTypeR3C0 -> metatypeTypeR3C1}
    metatypeTypeR3C0 -> metatypeTypeR4C0 [weight=100000000]
    rank = same {metatypeTypeR4C0 -> metatypeTypeR4C1}
  }
  subgraph clusterclosureParameterClause {
    node [shape = box]
    label = <closureParameterClause = "(" ")" | "(" closureParameterList ")" | identifierList .>
    labeljust = l
    closureParameterClauseR0C0 [label = <AFB<br/>N closureParameterClause<br/>fi ["(", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am ["("]<br/>>]
    closureParameterClauseR0C1 [label = <AEP<br/>ALT <br/>fi ["("]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR1C1 [label = <AEQ<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterClauseR2C1 [label = <AER<br/>T ")"<br/>fi [")"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR3C1 [label = <AES<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR2C1 -> closureParameterClauseR3C1 [weight=100000000]
    closureParameterClauseR1C1 -> closureParameterClauseR2C1 [weight=100000000]
    closureParameterClauseR0C1 -> closureParameterClauseR1C1 [weight=100000000]
    closureParameterClauseR0C2 [label = <AET<br/>ALT <br/>fi ["("]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR1C2 [label = <AEU<br/>T "("<br/>fi ["("]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    closureParameterClauseR2C2 [label = <AEV<br/>N closureParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    closureParameterClauseR3C2 [label = <AEW<br/>T ")"<br/>fi [")"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR4C2 [label = <AEX<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR3C2 -> closureParameterClauseR4C2 [weight=100000000]
    closureParameterClauseR2C2 -> closureParameterClauseR3C2 [weight=100000000]
    closureParameterClauseR1C2 -> closureParameterClauseR2C2 [weight=100000000]
    closureParameterClauseR0C2 -> closureParameterClauseR1C2 [weight=100000000]
    closureParameterClauseR0C3 [label = <AEY<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR1C3 [label = <AEZ<br/>N identifierList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR2C3 [label = <AFA<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "in", "throws"]<br/>am []<br/>>]
    closureParameterClauseR1C3 -> closureParameterClauseR2C3 [weight=100000000]
    closureParameterClauseR0C3 -> closureParameterClauseR1C3 [weight=100000000]
    rank = same {closureParameterClauseR0C2 -> closureParameterClauseR0C3}
    rank = same {closureParameterClauseR0C1 -> closureParameterClauseR0C2}
    rank = same {closureParameterClauseR0C0 -> closureParameterClauseR0C1}
    node [style = invis]
    edge [style = invis]
    closureParameterClauseR0C0 -> closureParameterClauseR1C0 [weight=100000000]
    rank = same {closureParameterClauseR1C0 -> closureParameterClauseR1C1}
    closureParameterClauseR1C0 -> closureParameterClauseR2C0 [weight=100000000]
    rank = same {closureParameterClauseR2C0 -> closureParameterClauseR2C1}
    closureParameterClauseR2C0 -> closureParameterClauseR3C0 [weight=100000000]
    rank = same {closureParameterClauseR3C0 -> closureParameterClauseR3C1}
    closureParameterClauseR2C3 -> closureParameterClauseR3C3 [weight=100000000]
    rank = same {closureParameterClauseR3C2 -> closureParameterClauseR3C3}
    closureParameterClauseR3C0 -> closureParameterClauseR4C0 [weight=100000000]
    closureParameterClauseR3C1 -> closureParameterClauseR4C1 [weight=100000000]
    rank = same {closureParameterClauseR4C0 -> closureParameterClauseR4C1}
    rank = same {closureParameterClauseR4C1 -> closureParameterClauseR4C2}
    closureParameterClauseR3C3 -> closureParameterClauseR4C3 [weight=100000000]
    rank = same {closureParameterClauseR4C2 -> closureParameterClauseR4C3}
  }
  subgraph clusterswitchElseifDirectiveClause {
    node [shape = box]
    label = <switchElseifDirectiveClause = elseifDirective compilationCondition [ switchCases ] .>
    labeljust = l
    switchElseifDirectiveClauseR0C0 [label = <BGG<br/>N switchElseifDirectiveClause<br/>fi ["#elseif"]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR0C1 [label = <BFY<br/>ALT <br/>fi ["#elseif"]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR1C1 [label = <BFZ<br/>N elseifDirective<br/>fi ["#elseif"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    switchElseifDirectiveClauseR2C1 [label = <BGA<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#if", "@"]<br/>am []<br/>>]
    switchElseifDirectiveClauseR3C1 [label = <BGE<br/>OPT <br/>fi ["", "#if", "@"]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR4C1 [label = <BGF<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR3C1 -> switchElseifDirectiveClauseR4C1 [weight=100000000]
    switchElseifDirectiveClauseR3C2 [label = <BGC<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR4C2 [label = <BGB<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR5C2 [label = <BGD<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    switchElseifDirectiveClauseR4C2 -> switchElseifDirectiveClauseR5C2 [weight=100000000]
    switchElseifDirectiveClauseR3C2 -> switchElseifDirectiveClauseR4C2 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR3C1 -> switchElseifDirectiveClauseR3C2}
    switchElseifDirectiveClauseR2C1 -> switchElseifDirectiveClauseR3C1 [weight=100000000]
    switchElseifDirectiveClauseR1C1 -> switchElseifDirectiveClauseR2C1 [weight=100000000]
    switchElseifDirectiveClauseR0C1 -> switchElseifDirectiveClauseR1C1 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR0C0 -> switchElseifDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchElseifDirectiveClauseR0C1 -> switchElseifDirectiveClauseR0C2}
    switchElseifDirectiveClauseR0C0 -> switchElseifDirectiveClauseR1C0 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR1C0 -> switchElseifDirectiveClauseR1C1}
    switchElseifDirectiveClauseR0C2 -> switchElseifDirectiveClauseR1C2 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR1C1 -> switchElseifDirectiveClauseR1C2}
    switchElseifDirectiveClauseR1C0 -> switchElseifDirectiveClauseR2C0 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR2C0 -> switchElseifDirectiveClauseR2C1}
    switchElseifDirectiveClauseR1C2 -> switchElseifDirectiveClauseR2C2 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR2C1 -> switchElseifDirectiveClauseR2C2}
    switchElseifDirectiveClauseR2C0 -> switchElseifDirectiveClauseR3C0 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR3C0 -> switchElseifDirectiveClauseR3C1}
    switchElseifDirectiveClauseR2C2 -> switchElseifDirectiveClauseR3C2 [weight=100000000]
    switchElseifDirectiveClauseR3C0 -> switchElseifDirectiveClauseR4C0 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR4C0 -> switchElseifDirectiveClauseR4C1}
    switchElseifDirectiveClauseR4C0 -> switchElseifDirectiveClauseR5C0 [weight=100000000]
    switchElseifDirectiveClauseR4C1 -> switchElseifDirectiveClauseR5C1 [weight=100000000]
    rank = same {switchElseifDirectiveClauseR5C0 -> switchElseifDirectiveClauseR5C1}
    rank = same {switchElseifDirectiveClauseR5C1 -> switchElseifDirectiveClauseR5C2}
  }
  subgraph clusterlineControlStatement {
    node [shape = box]
    label = <lineControlStatement = "#sourceLocation" "(" "file:" filePath "," "line:" "lineNumber" ")" | "#sourceLocation" "(" ")" .>
    labeljust = l
    lineControlStatementR0C0 [label = <BUD<br/>N lineControlStatement<br/>fi ["#sourceLocation"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["#sourceLocation"]<br/>>]
    lineControlStatementR0C1 [label = <BTT<br/>ALT <br/>fi ["#sourceLocation"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR1C1 [label = <BTU<br/>T "#sourceLocation"<br/>fi ["#sourceLocation"]<br/>fo ["("]<br/>am []<br/>>]
    lineControlStatementR2C1 [label = <BTV<br/>T "("<br/>fi ["("]<br/>fo ["file:"]<br/>am []<br/>>]
    lineControlStatementR3C1 [label = <BTW<br/>T "file:"<br/>fi ["file:"]<br/>fo ["staticStringLiteral"]<br/>am []<br/>>]
    lineControlStatementR4C1 [label = <BTX<br/>N filePath<br/>fi ["staticStringLiteral"]<br/>fo [","]<br/>am []<br/>>]
    lineControlStatementR5C1 [label = <BTY<br/>T ","<br/>fi [","]<br/>fo ["line:"]<br/>am []<br/>>]
    lineControlStatementR6C1 [label = <BTZ<br/>T "line:"<br/>fi ["line:"]<br/>fo ["lineNumber"]<br/>am []<br/>>]
    lineControlStatementR7C1 [label = <BUA<br/>T "lineNumber"<br/>fi ["lineNumber"]<br/>fo [")"]<br/>am []<br/>>]
    lineControlStatementR8C1 [label = <BUB<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR9C1 [label = <BUC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR8C1 -> lineControlStatementR9C1 [weight=100000000]
    lineControlStatementR7C1 -> lineControlStatementR8C1 [weight=100000000]
    lineControlStatementR6C1 -> lineControlStatementR7C1 [weight=100000000]
    lineControlStatementR5C1 -> lineControlStatementR6C1 [weight=100000000]
    lineControlStatementR4C1 -> lineControlStatementR5C1 [weight=100000000]
    lineControlStatementR3C1 -> lineControlStatementR4C1 [weight=100000000]
    lineControlStatementR2C1 -> lineControlStatementR3C1 [weight=100000000]
    lineControlStatementR1C1 -> lineControlStatementR2C1 [weight=100000000]
    lineControlStatementR0C1 -> lineControlStatementR1C1 [weight=100000000]
    lineControlStatementR0C2 [label = <BUE<br/>ALT <br/>fi ["#sourceLocation"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR1C2 [label = <BUF<br/>T "#sourceLocation"<br/>fi ["#sourceLocation"]<br/>fo ["("]<br/>am []<br/>>]
    lineControlStatementR2C2 [label = <BUG<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    lineControlStatementR3C2 [label = <BUH<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR4C2 [label = <BUI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    lineControlStatementR3C2 -> lineControlStatementR4C2 [weight=100000000]
    lineControlStatementR2C2 -> lineControlStatementR3C2 [weight=100000000]
    lineControlStatementR1C2 -> lineControlStatementR2C2 [weight=100000000]
    lineControlStatementR0C2 -> lineControlStatementR1C2 [weight=100000000]
    rank = same {lineControlStatementR0C1 -> lineControlStatementR0C2}
    rank = same {lineControlStatementR0C0 -> lineControlStatementR0C1}
    node [style = invis]
    edge [style = invis]
    lineControlStatementR0C0 -> lineControlStatementR1C0 [weight=100000000]
    rank = same {lineControlStatementR1C0 -> lineControlStatementR1C1}
    lineControlStatementR1C0 -> lineControlStatementR2C0 [weight=100000000]
    rank = same {lineControlStatementR2C0 -> lineControlStatementR2C1}
    lineControlStatementR2C0 -> lineControlStatementR3C0 [weight=100000000]
    rank = same {lineControlStatementR3C0 -> lineControlStatementR3C1}
    lineControlStatementR3C0 -> lineControlStatementR4C0 [weight=100000000]
    rank = same {lineControlStatementR4C0 -> lineControlStatementR4C1}
    lineControlStatementR4C0 -> lineControlStatementR5C0 [weight=100000000]
    rank = same {lineControlStatementR5C0 -> lineControlStatementR5C1}
    lineControlStatementR4C2 -> lineControlStatementR5C2 [weight=100000000]
    rank = same {lineControlStatementR5C1 -> lineControlStatementR5C2}
    lineControlStatementR5C0 -> lineControlStatementR6C0 [weight=100000000]
    rank = same {lineControlStatementR6C0 -> lineControlStatementR6C1}
    lineControlStatementR5C2 -> lineControlStatementR6C2 [weight=100000000]
    rank = same {lineControlStatementR6C1 -> lineControlStatementR6C2}
    lineControlStatementR6C0 -> lineControlStatementR7C0 [weight=100000000]
    rank = same {lineControlStatementR7C0 -> lineControlStatementR7C1}
    lineControlStatementR6C2 -> lineControlStatementR7C2 [weight=100000000]
    rank = same {lineControlStatementR7C1 -> lineControlStatementR7C2}
    lineControlStatementR7C0 -> lineControlStatementR8C0 [weight=100000000]
    rank = same {lineControlStatementR8C0 -> lineControlStatementR8C1}
    lineControlStatementR7C2 -> lineControlStatementR8C2 [weight=100000000]
    rank = same {lineControlStatementR8C1 -> lineControlStatementR8C2}
    lineControlStatementR8C0 -> lineControlStatementR9C0 [weight=100000000]
    rank = same {lineControlStatementR9C0 -> lineControlStatementR9C1}
    lineControlStatementR8C2 -> lineControlStatementR9C2 [weight=100000000]
    rank = same {lineControlStatementR9C1 -> lineControlStatementR9C2}
  }
  subgraph clustercondition {
    node [shape = box]
    label = <condition = expression | availabilityCondition | caseCondition | optionalBindingCondition .>
    labeljust = l
    conditionR0C0 [label = <AZH<br/>N condition<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR0C1 [label = <AYV<br/>ALT <br/>fi ["", "try"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C1 [label = <AYW<br/>N expression<br/>fi ["", "try"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR2C1 [label = <AYX<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C1 -> conditionR2C1 [weight=100000000]
    conditionR0C1 -> conditionR1C1 [weight=100000000]
    conditionR0C2 [label = <AYY<br/>ALT <br/>fi ["#available", "#unavailable"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C2 [label = <AYZ<br/>N availabilityCondition<br/>fi ["#available", "#unavailable"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR2C2 [label = <AZA<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C2 -> conditionR2C2 [weight=100000000]
    conditionR0C2 -> conditionR1C2 [weight=100000000]
    conditionR0C3 [label = <AZB<br/>ALT <br/>fi ["case"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C3 [label = <AZC<br/>N caseCondition<br/>fi ["case"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR2C3 [label = <AZD<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C3 -> conditionR2C3 [weight=100000000]
    conditionR0C3 -> conditionR1C3 [weight=100000000]
    conditionR0C4 [label = <AZE<br/>ALT <br/>fi ["let", "var"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C4 [label = <AZF<br/>N optionalBindingCondition<br/>fi ["let", "var"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR2C4 [label = <AZG<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    conditionR1C4 -> conditionR2C4 [weight=100000000]
    conditionR0C4 -> conditionR1C4 [weight=100000000]
    rank = same {conditionR0C3 -> conditionR0C4}
    rank = same {conditionR0C2 -> conditionR0C3}
    rank = same {conditionR0C1 -> conditionR0C2}
    rank = same {conditionR0C0 -> conditionR0C1}
    node [style = invis]
    edge [style = invis]
    conditionR0C0 -> conditionR1C0 [weight=100000000]
    rank = same {conditionR1C0 -> conditionR1C1}
    conditionR1C0 -> conditionR2C0 [weight=100000000]
    rank = same {conditionR2C0 -> conditionR2C1}
  }
  subgraph clustertypeInheritanceList {
    node [shape = box]
    label = <typeInheritanceList = [ attributes ] typeIdentifier | [ attributes ] typeIdentifier "," typeInheritanceList .>
    labeljust = l
    typeInheritanceListR0C0 [label = <OF<br/>N typeInheritanceList<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am ["@"]<br/>>]
    typeInheritanceListR0C1 [label = <NP<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am ["@"]<br/>>]
    typeInheritanceListR1C1 [label = <NT<br/>OPT <br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C1 [label = <NU<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceListR3C1 [label = <NV<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceListR2C1 -> typeInheritanceListR3C1 [weight=100000000]
    typeInheritanceListR1C1 -> typeInheritanceListR2C1 [weight=100000000]
    typeInheritanceListR1C2 [label = <NR<br/>ALT <br/>fi ["@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C2 [label = <NQ<br/>N attributes<br/>fi ["@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR3C2 [label = <NS<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C2 -> typeInheritanceListR3C2 [weight=100000000]
    typeInheritanceListR1C2 -> typeInheritanceListR2C2 [weight=100000000]
    rank = same {typeInheritanceListR1C1 -> typeInheritanceListR1C2}
    typeInheritanceListR0C1 -> typeInheritanceListR1C1 [weight=100000000]
    typeInheritanceListR0C3 [label = <NW<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am ["@"]<br/>>]
    typeInheritanceListR1C3 [label = <OA<br/>OPT <br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C3 [label = <OB<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    typeInheritanceListR3C3 [label = <OC<br/>T ","<br/>fi [","]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceListR4C3 [label = <OD<br/>N typeInheritanceList<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am ["@"]<br/>>]
    typeInheritanceListR5C3 [label = <OE<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceListR4C3 -> typeInheritanceListR5C3 [weight=100000000]
    typeInheritanceListR3C3 -> typeInheritanceListR4C3 [weight=100000000]
    typeInheritanceListR2C3 -> typeInheritanceListR3C3 [weight=100000000]
    typeInheritanceListR1C3 -> typeInheritanceListR2C3 [weight=100000000]
    typeInheritanceListR1C4 [label = <NY<br/>ALT <br/>fi ["@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C4 [label = <NX<br/>N attributes<br/>fi ["@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR3C4 [label = <NZ<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeInheritanceListR2C4 -> typeInheritanceListR3C4 [weight=100000000]
    typeInheritanceListR1C4 -> typeInheritanceListR2C4 [weight=100000000]
    rank = same {typeInheritanceListR1C3 -> typeInheritanceListR1C4}
    typeInheritanceListR0C3 -> typeInheritanceListR1C3 [weight=100000000]
    rank = same {typeInheritanceListR0C1 -> typeInheritanceListR0C3}
    rank = same {typeInheritanceListR0C0 -> typeInheritanceListR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {typeInheritanceListR0C3 -> typeInheritanceListR0C4}
    typeInheritanceListR0C0 -> typeInheritanceListR1C0 [weight=100000000]
    rank = same {typeInheritanceListR1C0 -> typeInheritanceListR1C1}
    typeInheritanceListR0C4 -> typeInheritanceListR1C4 [weight=100000000]
    typeInheritanceListR1C0 -> typeInheritanceListR2C0 [weight=100000000]
    rank = same {typeInheritanceListR2C0 -> typeInheritanceListR2C1}
    typeInheritanceListR2C0 -> typeInheritanceListR3C0 [weight=100000000]
    rank = same {typeInheritanceListR3C0 -> typeInheritanceListR3C1}
    typeInheritanceListR3C0 -> typeInheritanceListR4C0 [weight=100000000]
    typeInheritanceListR3C1 -> typeInheritanceListR4C1 [weight=100000000]
    rank = same {typeInheritanceListR4C0 -> typeInheritanceListR4C1}
    typeInheritanceListR3C2 -> typeInheritanceListR4C2 [weight=100000000]
    rank = same {typeInheritanceListR4C1 -> typeInheritanceListR4C2}
    rank = same {typeInheritanceListR4C2 -> typeInheritanceListR4C3}
    typeInheritanceListR3C4 -> typeInheritanceListR4C4 [weight=100000000]
    rank = same {typeInheritanceListR4C3 -> typeInheritanceListR4C4}
    typeInheritanceListR4C0 -> typeInheritanceListR5C0 [weight=100000000]
    typeInheritanceListR4C1 -> typeInheritanceListR5C1 [weight=100000000]
    rank = same {typeInheritanceListR5C0 -> typeInheritanceListR5C1}
    typeInheritanceListR4C2 -> typeInheritanceListR5C2 [weight=100000000]
    rank = same {typeInheritanceListR5C1 -> typeInheritanceListR5C2}
    rank = same {typeInheritanceListR5C2 -> typeInheritanceListR5C3}
    typeInheritanceListR4C4 -> typeInheritanceListR5C4 [weight=100000000]
    rank = same {typeInheritanceListR5C3 -> typeInheritanceListR5C4}
  }
  subgraph clusterelseDirective {
    node [shape = box]
    label = <elseDirective = "#else" .>
    labeljust = l
    elseDirectiveR0C0 [label = <BOC<br/>N elseDirective<br/>fi ["#else"]<br/>fo ["#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseDirectiveR0C1 [label = <BNZ<br/>ALT <br/>fi ["#else"]<br/>fo ["#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseDirectiveR1C1 [label = <BOA<br/>T "#else"<br/>fi ["#else"]<br/>fo ["#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseDirectiveR2C1 [label = <BOB<br/>END <br/>fi [""]<br/>fo ["#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseDirectiveR1C1 -> elseDirectiveR2C1 [weight=100000000]
    elseDirectiveR0C1 -> elseDirectiveR1C1 [weight=100000000]
    rank = same {elseDirectiveR0C0 -> elseDirectiveR0C1}
    node [style = invis]
    edge [style = invis]
    elseDirectiveR0C0 -> elseDirectiveR1C0 [weight=100000000]
    rank = same {elseDirectiveR1C0 -> elseDirectiveR1C1}
    elseDirectiveR1C0 -> elseDirectiveR2C0 [weight=100000000]
    rank = same {elseDirectiveR2C0 -> elseDirectiveR2C1}
  }
  subgraph clusteroperatorDeclaration {
    node [shape = box]
    label = <operatorDeclaration = prefixOperatorDeclaration | postfixOperatorDeclaration | infixOperatorDeclaration .>
    labeljust = l
    operatorDeclarationR0C0 [label = <DWC<br/>N operatorDeclaration<br/>fi ["infix", "postfix", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR0C1 [label = <DVT<br/>ALT <br/>fi ["prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C1 [label = <DVU<br/>N prefixOperatorDeclaration<br/>fi ["prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR2C1 [label = <DVV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C1 -> operatorDeclarationR2C1 [weight=100000000]
    operatorDeclarationR0C1 -> operatorDeclarationR1C1 [weight=100000000]
    operatorDeclarationR0C2 [label = <DVW<br/>ALT <br/>fi ["postfix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C2 [label = <DVX<br/>N postfixOperatorDeclaration<br/>fi ["postfix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR2C2 [label = <DVY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C2 -> operatorDeclarationR2C2 [weight=100000000]
    operatorDeclarationR0C2 -> operatorDeclarationR1C2 [weight=100000000]
    operatorDeclarationR0C3 [label = <DVZ<br/>ALT <br/>fi ["infix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C3 [label = <DWA<br/>N infixOperatorDeclaration<br/>fi ["infix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR2C3 [label = <DWB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    operatorDeclarationR1C3 -> operatorDeclarationR2C3 [weight=100000000]
    operatorDeclarationR0C3 -> operatorDeclarationR1C3 [weight=100000000]
    rank = same {operatorDeclarationR0C2 -> operatorDeclarationR0C3}
    rank = same {operatorDeclarationR0C1 -> operatorDeclarationR0C2}
    rank = same {operatorDeclarationR0C0 -> operatorDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    operatorDeclarationR0C0 -> operatorDeclarationR1C0 [weight=100000000]
    rank = same {operatorDeclarationR1C0 -> operatorDeclarationR1C1}
    operatorDeclarationR1C0 -> operatorDeclarationR2C0 [weight=100000000]
    rank = same {operatorDeclarationR2C0 -> operatorDeclarationR2C1}
  }
  subgraph clusterbreakStatement {
    node [shape = box]
    label = <breakStatement = "break" [ labelName ] .>
    labeljust = l
    breakStatementR0C0 [label = <BIM<br/>N breakStatement<br/>fi ["break"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR0C1 [label = <BIF<br/>ALT <br/>fi ["break"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR1C1 [label = <BIG<br/>T "break"<br/>fi ["break"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR2C1 [label = <BIK<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    breakStatementR3C1 [label = <BIL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR2C1 -> breakStatementR3C1 [weight=100000000]
    breakStatementR2C2 [label = <BII<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR3C2 [label = <BIH<br/>N labelName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR4C2 [label = <BIJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    breakStatementR3C2 -> breakStatementR4C2 [weight=100000000]
    breakStatementR2C2 -> breakStatementR3C2 [weight=100000000]
    rank = same {breakStatementR2C1 -> breakStatementR2C2}
    breakStatementR1C1 -> breakStatementR2C1 [weight=100000000]
    breakStatementR0C1 -> breakStatementR1C1 [weight=100000000]
    rank = same {breakStatementR0C0 -> breakStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {breakStatementR0C1 -> breakStatementR0C2}
    breakStatementR0C0 -> breakStatementR1C0 [weight=100000000]
    rank = same {breakStatementR1C0 -> breakStatementR1C1}
    breakStatementR0C2 -> breakStatementR1C2 [weight=100000000]
    rank = same {breakStatementR1C1 -> breakStatementR1C2}
    breakStatementR1C0 -> breakStatementR2C0 [weight=100000000]
    rank = same {breakStatementR2C0 -> breakStatementR2C1}
    breakStatementR1C2 -> breakStatementR2C2 [weight=100000000]
    breakStatementR2C0 -> breakStatementR3C0 [weight=100000000]
    rank = same {breakStatementR3C0 -> breakStatementR3C1}
    breakStatementR3C0 -> breakStatementR4C0 [weight=100000000]
    breakStatementR3C1 -> breakStatementR4C1 [weight=100000000]
    rank = same {breakStatementR4C0 -> breakStatementR4C1}
    rank = same {breakStatementR4C1 -> breakStatementR4C2}
  }
  subgraph clusteractorDeclaration {
    node [shape = box]
    label = <actorDeclaration = [ attributes ] [ accessLevelModifier ] "actor" actorName [ genericParameterClause ] [ typeInheritanceClause ] [ genericWhereClause ] actorBody .>
    labeljust = l
    actorDeclarationR0C0 [label = <DFR<br/>N actorDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    actorDeclarationR0C1 [label = <DES<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    actorDeclarationR1C1 [label = <DEW<br/>OPT <br/>fi ["", "@"]<br/>fo ["actor", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    actorDeclarationR2C1 [label = <DFA<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["actor"]<br/>am []<br/>>]
    actorDeclarationR3C1 [label = <DFB<br/>T "actor"<br/>fi ["actor"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    actorDeclarationR4C1 [label = <DFC<br/>N actorName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    actorDeclarationR5C1 [label = <DFG<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    actorDeclarationR6C1 [label = <DFK<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    actorDeclarationR7C1 [label = <DFO<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    actorDeclarationR8C1 [label = <DFP<br/>N actorBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorDeclarationR9C1 [label = <DFQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorDeclarationR8C1 -> actorDeclarationR9C1 [weight=100000000]
    actorDeclarationR7C1 -> actorDeclarationR8C1 [weight=100000000]
    actorDeclarationR7C2 [label = <DFM<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    actorDeclarationR8C2 [label = <DFL<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    actorDeclarationR9C2 [label = <DFN<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    actorDeclarationR8C2 -> actorDeclarationR9C2 [weight=100000000]
    actorDeclarationR7C2 -> actorDeclarationR8C2 [weight=100000000]
    rank = same {actorDeclarationR7C1 -> actorDeclarationR7C2}
    actorDeclarationR6C1 -> actorDeclarationR7C1 [weight=100000000]
    actorDeclarationR6C3 [label = <DFI<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    actorDeclarationR7C3 [label = <DFH<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    actorDeclarationR8C3 [label = <DFJ<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    actorDeclarationR7C3 -> actorDeclarationR8C3 [weight=100000000]
    actorDeclarationR6C3 -> actorDeclarationR7C3 [weight=100000000]
    rank = same {actorDeclarationR6C1 -> actorDeclarationR6C3}
    actorDeclarationR5C1 -> actorDeclarationR6C1 [weight=100000000]
    actorDeclarationR5C4 [label = <DFE<br/>ALT <br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    actorDeclarationR6C4 [label = <DFD<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    actorDeclarationR7C4 [label = <DFF<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    actorDeclarationR6C4 -> actorDeclarationR7C4 [weight=100000000]
    actorDeclarationR5C4 -> actorDeclarationR6C4 [weight=100000000]
    rank = same {actorDeclarationR5C1 -> actorDeclarationR5C4}
    actorDeclarationR4C1 -> actorDeclarationR5C1 [weight=100000000]
    actorDeclarationR3C1 -> actorDeclarationR4C1 [weight=100000000]
    actorDeclarationR2C1 -> actorDeclarationR3C1 [weight=100000000]
    actorDeclarationR2C5 [label = <DEY<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["actor"]<br/>am []<br/>>]
    actorDeclarationR3C5 [label = <DEX<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["actor"]<br/>am []<br/>>]
    actorDeclarationR4C5 [label = <DEZ<br/>END <br/>fi [""]<br/>fo ["actor"]<br/>am []<br/>>]
    actorDeclarationR3C5 -> actorDeclarationR4C5 [weight=100000000]
    actorDeclarationR2C5 -> actorDeclarationR3C5 [weight=100000000]
    rank = same {actorDeclarationR2C1 -> actorDeclarationR2C5}
    actorDeclarationR1C1 -> actorDeclarationR2C1 [weight=100000000]
    actorDeclarationR1C6 [label = <DEU<br/>ALT <br/>fi ["@"]<br/>fo ["actor", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    actorDeclarationR2C6 [label = <DET<br/>N attributes<br/>fi ["@"]<br/>fo ["actor", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    actorDeclarationR3C6 [label = <DEV<br/>END <br/>fi [""]<br/>fo ["actor", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    actorDeclarationR2C6 -> actorDeclarationR3C6 [weight=100000000]
    actorDeclarationR1C6 -> actorDeclarationR2C6 [weight=100000000]
    rank = same {actorDeclarationR1C1 -> actorDeclarationR1C6}
    actorDeclarationR0C1 -> actorDeclarationR1C1 [weight=100000000]
    rank = same {actorDeclarationR0C0 -> actorDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {actorDeclarationR0C1 -> actorDeclarationR0C2}
    rank = same {actorDeclarationR0C2 -> actorDeclarationR0C3}
    rank = same {actorDeclarationR0C3 -> actorDeclarationR0C4}
    rank = same {actorDeclarationR0C4 -> actorDeclarationR0C5}
    rank = same {actorDeclarationR0C5 -> actorDeclarationR0C6}
    actorDeclarationR0C0 -> actorDeclarationR1C0 [weight=100000000]
    rank = same {actorDeclarationR1C0 -> actorDeclarationR1C1}
    actorDeclarationR0C6 -> actorDeclarationR1C6 [weight=100000000]
    actorDeclarationR1C0 -> actorDeclarationR2C0 [weight=100000000]
    rank = same {actorDeclarationR2C0 -> actorDeclarationR2C1}
    actorDeclarationR2C0 -> actorDeclarationR3C0 [weight=100000000]
    rank = same {actorDeclarationR3C0 -> actorDeclarationR3C1}
    rank = same {actorDeclarationR3C1 -> actorDeclarationR3C2}
    rank = same {actorDeclarationR3C2 -> actorDeclarationR3C3}
    rank = same {actorDeclarationR3C3 -> actorDeclarationR3C4}
    rank = same {actorDeclarationR3C4 -> actorDeclarationR3C5}
    actorDeclarationR3C0 -> actorDeclarationR4C0 [weight=100000000]
    rank = same {actorDeclarationR4C0 -> actorDeclarationR4C1}
    actorDeclarationR3C2 -> actorDeclarationR4C2 [weight=100000000]
    rank = same {actorDeclarationR4C1 -> actorDeclarationR4C2}
    actorDeclarationR3C3 -> actorDeclarationR4C3 [weight=100000000]
    rank = same {actorDeclarationR4C2 -> actorDeclarationR4C3}
    actorDeclarationR3C4 -> actorDeclarationR4C4 [weight=100000000]
    rank = same {actorDeclarationR4C3 -> actorDeclarationR4C4}
    rank = same {actorDeclarationR4C4 -> actorDeclarationR4C5}
    actorDeclarationR3C6 -> actorDeclarationR4C6 [weight=100000000]
    rank = same {actorDeclarationR4C5 -> actorDeclarationR4C6}
    actorDeclarationR4C0 -> actorDeclarationR5C0 [weight=100000000]
    rank = same {actorDeclarationR5C0 -> actorDeclarationR5C1}
    actorDeclarationR4C4 -> actorDeclarationR5C4 [weight=100000000]
    actorDeclarationR4C5 -> actorDeclarationR5C5 [weight=100000000]
    rank = same {actorDeclarationR5C4 -> actorDeclarationR5C5}
    actorDeclarationR4C6 -> actorDeclarationR5C6 [weight=100000000]
    rank = same {actorDeclarationR5C5 -> actorDeclarationR5C6}
    actorDeclarationR5C0 -> actorDeclarationR6C0 [weight=100000000]
    rank = same {actorDeclarationR6C0 -> actorDeclarationR6C1}
    actorDeclarationR5C5 -> actorDeclarationR6C5 [weight=100000000]
    rank = same {actorDeclarationR6C4 -> actorDeclarationR6C5}
    actorDeclarationR5C6 -> actorDeclarationR6C6 [weight=100000000]
    rank = same {actorDeclarationR6C5 -> actorDeclarationR6C6}
    actorDeclarationR6C0 -> actorDeclarationR7C0 [weight=100000000]
    rank = same {actorDeclarationR7C0 -> actorDeclarationR7C1}
    actorDeclarationR6C5 -> actorDeclarationR7C5 [weight=100000000]
    rank = same {actorDeclarationR7C4 -> actorDeclarationR7C5}
    actorDeclarationR6C6 -> actorDeclarationR7C6 [weight=100000000]
    rank = same {actorDeclarationR7C5 -> actorDeclarationR7C6}
    actorDeclarationR7C0 -> actorDeclarationR8C0 [weight=100000000]
    rank = same {actorDeclarationR8C0 -> actorDeclarationR8C1}
    actorDeclarationR7C4 -> actorDeclarationR8C4 [weight=100000000]
    rank = same {actorDeclarationR8C3 -> actorDeclarationR8C4}
    actorDeclarationR7C5 -> actorDeclarationR8C5 [weight=100000000]
    rank = same {actorDeclarationR8C4 -> actorDeclarationR8C5}
    actorDeclarationR7C6 -> actorDeclarationR8C6 [weight=100000000]
    rank = same {actorDeclarationR8C5 -> actorDeclarationR8C6}
    actorDeclarationR8C0 -> actorDeclarationR9C0 [weight=100000000]
    rank = same {actorDeclarationR9C0 -> actorDeclarationR9C1}
    actorDeclarationR8C3 -> actorDeclarationR9C3 [weight=100000000]
    rank = same {actorDeclarationR9C2 -> actorDeclarationR9C3}
    actorDeclarationR8C4 -> actorDeclarationR9C4 [weight=100000000]
    rank = same {actorDeclarationR9C3 -> actorDeclarationR9C4}
    actorDeclarationR8C5 -> actorDeclarationR9C5 [weight=100000000]
    rank = same {actorDeclarationR9C4 -> actorDeclarationR9C5}
    actorDeclarationR8C6 -> actorDeclarationR9C6 [weight=100000000]
    rank = same {actorDeclarationR9C5 -> actorDeclarationR9C6}
  }
  subgraph clustercompilationCondition {
    node [shape = box]
    label = <compilationCondition = platformCondition | identifier | booleanLiteral | "(" compilationCondition ")" | "!" compilationCondition | compilationCondition "&amp;&amp;" compilationCondition | compilationCondition "||" compilationCondition .>
    labeljust = l
    compilationConditionR0C0 [label = <BOK<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>>]
    compilationConditionR0C1 [label = <BOH<br/>ALT <br/>fi ["arch", "canImport", "compiler", "os", "swift", "targetEnvironment"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C1 [label = <BOI<br/>N platformCondition<br/>fi ["arch", "canImport", "compiler", "os", "swift", "targetEnvironment"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR2C1 [label = <BOJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C1 -> compilationConditionR2C1 [weight=100000000]
    compilationConditionR0C1 -> compilationConditionR1C1 [weight=100000000]
    compilationConditionR0C2 [label = <BOL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C2 [label = <BOM<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR2C2 [label = <BON<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C2 -> compilationConditionR2C2 [weight=100000000]
    compilationConditionR0C2 -> compilationConditionR1C2 [weight=100000000]
    compilationConditionR0C3 [label = <BOO<br/>ALT <br/>fi ["false", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C3 [label = <BOP<br/>N booleanLiteral<br/>fi ["false", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR2C3 [label = <BOQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C3 -> compilationConditionR2C3 [weight=100000000]
    compilationConditionR0C3 -> compilationConditionR1C3 [weight=100000000]
    compilationConditionR0C4 [label = <BOR<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C4 [label = <BOS<br/>T "("<br/>fi ["("]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    compilationConditionR2C4 [label = <BOT<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo [")"]<br/>am []<br/>>]
    compilationConditionR3C4 [label = <BOU<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR4C4 [label = <BOV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR3C4 -> compilationConditionR4C4 [weight=100000000]
    compilationConditionR2C4 -> compilationConditionR3C4 [weight=100000000]
    compilationConditionR1C4 -> compilationConditionR2C4 [weight=100000000]
    compilationConditionR0C4 -> compilationConditionR1C4 [weight=100000000]
    compilationConditionR0C5 [label = <BOW<br/>ALT <br/>fi ["!"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C5 [label = <BOX<br/>T "!"<br/>fi ["!"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    compilationConditionR2C5 [label = <BOY<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR3C5 [label = <BOZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR2C5 -> compilationConditionR3C5 [weight=100000000]
    compilationConditionR1C5 -> compilationConditionR2C5 [weight=100000000]
    compilationConditionR0C5 -> compilationConditionR1C5 [weight=100000000]
    compilationConditionR0C6 [label = <BPA<br/>ALT <br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C6 [label = <BPB<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["&amp;&amp;"]<br/>am []<br/>>]
    compilationConditionR2C6 [label = <BPC<br/>T "&amp;&amp;"<br/>fi ["&amp;&amp;"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    compilationConditionR3C6 [label = <BPD<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR4C6 [label = <BPE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR3C6 -> compilationConditionR4C6 [weight=100000000]
    compilationConditionR2C6 -> compilationConditionR3C6 [weight=100000000]
    compilationConditionR1C6 -> compilationConditionR2C6 [weight=100000000]
    compilationConditionR0C6 -> compilationConditionR1C6 [weight=100000000]
    compilationConditionR0C7 [label = <BPF<br/>ALT <br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR1C7 [label = <BPG<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["||"]<br/>am []<br/>>]
    compilationConditionR2C7 [label = <BPH<br/>T "||"<br/>fi ["||"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    compilationConditionR3C7 [label = <BPI<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR4C7 [label = <BPJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "&amp;&amp;", ")", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "||"]<br/>am []<br/>>]
    compilationConditionR3C7 -> compilationConditionR4C7 [weight=100000000]
    compilationConditionR2C7 -> compilationConditionR3C7 [weight=100000000]
    compilationConditionR1C7 -> compilationConditionR2C7 [weight=100000000]
    compilationConditionR0C7 -> compilationConditionR1C7 [weight=100000000]
    rank = same {compilationConditionR0C6 -> compilationConditionR0C7}
    rank = same {compilationConditionR0C5 -> compilationConditionR0C6}
    rank = same {compilationConditionR0C4 -> compilationConditionR0C5}
    rank = same {compilationConditionR0C3 -> compilationConditionR0C4}
    rank = same {compilationConditionR0C2 -> compilationConditionR0C3}
    rank = same {compilationConditionR0C1 -> compilationConditionR0C2}
    rank = same {compilationConditionR0C0 -> compilationConditionR0C1}
    node [style = invis]
    edge [style = invis]
    compilationConditionR0C0 -> compilationConditionR1C0 [weight=100000000]
    rank = same {compilationConditionR1C0 -> compilationConditionR1C1}
    compilationConditionR1C0 -> compilationConditionR2C0 [weight=100000000]
    rank = same {compilationConditionR2C0 -> compilationConditionR2C1}
    compilationConditionR2C0 -> compilationConditionR3C0 [weight=100000000]
    compilationConditionR2C1 -> compilationConditionR3C1 [weight=100000000]
    rank = same {compilationConditionR3C0 -> compilationConditionR3C1}
    compilationConditionR2C2 -> compilationConditionR3C2 [weight=100000000]
    rank = same {compilationConditionR3C1 -> compilationConditionR3C2}
    compilationConditionR2C3 -> compilationConditionR3C3 [weight=100000000]
    rank = same {compilationConditionR3C2 -> compilationConditionR3C3}
    rank = same {compilationConditionR3C3 -> compilationConditionR3C4}
    compilationConditionR3C0 -> compilationConditionR4C0 [weight=100000000]
    compilationConditionR3C1 -> compilationConditionR4C1 [weight=100000000]
    rank = same {compilationConditionR4C0 -> compilationConditionR4C1}
    compilationConditionR3C2 -> compilationConditionR4C2 [weight=100000000]
    rank = same {compilationConditionR4C1 -> compilationConditionR4C2}
    compilationConditionR3C3 -> compilationConditionR4C3 [weight=100000000]
    rank = same {compilationConditionR4C2 -> compilationConditionR4C3}
    rank = same {compilationConditionR4C3 -> compilationConditionR4C4}
    compilationConditionR3C5 -> compilationConditionR4C5 [weight=100000000]
    rank = same {compilationConditionR4C4 -> compilationConditionR4C5}
    rank = same {compilationConditionR4C5 -> compilationConditionR4C6}
  }
  subgraph clusterrawValueStyleEnumCase {
    node [shape = box]
    label = <rawValueStyleEnumCase = enumCaseName [ rawValueAssignment ] .>
    labeljust = l
    rawValueStyleEnumCaseR0C0 [label = <CYU<br/>N rawValueStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR0C1 [label = <CYN<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR1C1 [label = <CYO<br/>N enumCaseName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "=", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR2C1 [label = <CYS<br/>OPT <br/>fi ["", "="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR3C1 [label = <CYT<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR2C1 -> rawValueStyleEnumCaseR3C1 [weight=100000000]
    rawValueStyleEnumCaseR2C2 [label = <CYQ<br/>ALT <br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR3C2 [label = <CYP<br/>N rawValueAssignment<br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR4C2 [label = <CYR<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ",", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseR3C2 -> rawValueStyleEnumCaseR4C2 [weight=100000000]
    rawValueStyleEnumCaseR2C2 -> rawValueStyleEnumCaseR3C2 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR2C1 -> rawValueStyleEnumCaseR2C2}
    rawValueStyleEnumCaseR1C1 -> rawValueStyleEnumCaseR2C1 [weight=100000000]
    rawValueStyleEnumCaseR0C1 -> rawValueStyleEnumCaseR1C1 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR0C0 -> rawValueStyleEnumCaseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {rawValueStyleEnumCaseR0C1 -> rawValueStyleEnumCaseR0C2}
    rawValueStyleEnumCaseR0C0 -> rawValueStyleEnumCaseR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR1C0 -> rawValueStyleEnumCaseR1C1}
    rawValueStyleEnumCaseR0C2 -> rawValueStyleEnumCaseR1C2 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR1C1 -> rawValueStyleEnumCaseR1C2}
    rawValueStyleEnumCaseR1C0 -> rawValueStyleEnumCaseR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR2C0 -> rawValueStyleEnumCaseR2C1}
    rawValueStyleEnumCaseR1C2 -> rawValueStyleEnumCaseR2C2 [weight=100000000]
    rawValueStyleEnumCaseR2C0 -> rawValueStyleEnumCaseR3C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR3C0 -> rawValueStyleEnumCaseR3C1}
    rawValueStyleEnumCaseR3C0 -> rawValueStyleEnumCaseR4C0 [weight=100000000]
    rawValueStyleEnumCaseR3C1 -> rawValueStyleEnumCaseR4C1 [weight=100000000]
    rank = same {rawValueStyleEnumCaseR4C0 -> rawValueStyleEnumCaseR4C1}
    rank = same {rawValueStyleEnumCaseR4C1 -> rawValueStyleEnumCaseR4C2}
  }
  subgraph clusterifExpression {
    node [shape = box]
    label = <ifExpression = "if" conditionList "{" statement "}" ifExpressionTail .>
    labeljust = l
    ifExpressionR0C0 [label = <ABO<br/>N ifExpression<br/>fi ["if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionR0C1 [label = <ABG<br/>ALT <br/>fi ["if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionR1C1 [label = <ABH<br/>T "if"<br/>fi ["if"]<br/>fo ["#available", "#unavailable", "case", "let", "try", "var", "{"]<br/>am []<br/>>]
    ifExpressionR2C1 [label = <ABI<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    ifExpressionR3C1 [label = <ABJ<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifExpressionR4C1 [label = <ABK<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    ifExpressionR5C1 [label = <ABL<br/>T "}"<br/>fi ["}"]<br/>fo ["else"]<br/>am []<br/>>]
    ifExpressionR6C1 [label = <ABM<br/>N ifExpressionTail<br/>fi ["else"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionR7C1 [label = <ABN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionR6C1 -> ifExpressionR7C1 [weight=100000000]
    ifExpressionR5C1 -> ifExpressionR6C1 [weight=100000000]
    ifExpressionR4C1 -> ifExpressionR5C1 [weight=100000000]
    ifExpressionR3C1 -> ifExpressionR4C1 [weight=100000000]
    ifExpressionR2C1 -> ifExpressionR3C1 [weight=100000000]
    ifExpressionR1C1 -> ifExpressionR2C1 [weight=100000000]
    ifExpressionR0C1 -> ifExpressionR1C1 [weight=100000000]
    rank = same {ifExpressionR0C0 -> ifExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    ifExpressionR0C0 -> ifExpressionR1C0 [weight=100000000]
    rank = same {ifExpressionR1C0 -> ifExpressionR1C1}
    ifExpressionR1C0 -> ifExpressionR2C0 [weight=100000000]
    rank = same {ifExpressionR2C0 -> ifExpressionR2C1}
    ifExpressionR2C0 -> ifExpressionR3C0 [weight=100000000]
    rank = same {ifExpressionR3C0 -> ifExpressionR3C1}
    ifExpressionR3C0 -> ifExpressionR4C0 [weight=100000000]
    rank = same {ifExpressionR4C0 -> ifExpressionR4C1}
    ifExpressionR4C0 -> ifExpressionR5C0 [weight=100000000]
    rank = same {ifExpressionR5C0 -> ifExpressionR5C1}
    ifExpressionR5C0 -> ifExpressionR6C0 [weight=100000000]
    rank = same {ifExpressionR6C0 -> ifExpressionR6C1}
    ifExpressionR6C0 -> ifExpressionR7C0 [weight=100000000]
    rank = same {ifExpressionR7C0 -> ifExpressionR7C1}
  }
  subgraph clusterselfMethodExpression {
    node [shape = box]
    label = <selfMethodExpression = "self" "." identifier .>
    labeljust = l
    selfMethodExpressionR0C0 [label = <ZI<br/>N selfMethodExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfMethodExpressionR0C1 [label = <ZD<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfMethodExpressionR1C1 [label = <ZE<br/>T "self"<br/>fi ["self"]<br/>fo ["."]<br/>am []<br/>>]
    selfMethodExpressionR2C1 [label = <ZF<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    selfMethodExpressionR3C1 [label = <ZG<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfMethodExpressionR4C1 [label = <ZH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfMethodExpressionR3C1 -> selfMethodExpressionR4C1 [weight=100000000]
    selfMethodExpressionR2C1 -> selfMethodExpressionR3C1 [weight=100000000]
    selfMethodExpressionR1C1 -> selfMethodExpressionR2C1 [weight=100000000]
    selfMethodExpressionR0C1 -> selfMethodExpressionR1C1 [weight=100000000]
    rank = same {selfMethodExpressionR0C0 -> selfMethodExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    selfMethodExpressionR0C0 -> selfMethodExpressionR1C0 [weight=100000000]
    rank = same {selfMethodExpressionR1C0 -> selfMethodExpressionR1C1}
    selfMethodExpressionR1C0 -> selfMethodExpressionR2C0 [weight=100000000]
    rank = same {selfMethodExpressionR2C0 -> selfMethodExpressionR2C1}
    selfMethodExpressionR2C0 -> selfMethodExpressionR3C0 [weight=100000000]
    rank = same {selfMethodExpressionR3C0 -> selfMethodExpressionR3C1}
    selfMethodExpressionR3C0 -> selfMethodExpressionR4C0 [weight=100000000]
    rank = same {selfMethodExpressionR4C0 -> selfMethodExpressionR4C1}
  }
  subgraph clusterenvironment {
    node [shape = box]
    label = <environment = "simulator" | "macCatalyst" .>
    labeljust = l
    environmentR0C0 [label = <BTR<br/>N environment<br/>fi ["macCatalyst", "simulator"]<br/>fo [")"]<br/>am []<br/>>]
    environmentR0C1 [label = <BTL<br/>ALT <br/>fi ["simulator"]<br/>fo [")"]<br/>am []<br/>>]
    environmentR1C1 [label = <BTM<br/>T "simulator"<br/>fi ["simulator"]<br/>fo [")"]<br/>am []<br/>>]
    environmentR2C1 [label = <BTN<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    environmentR1C1 -> environmentR2C1 [weight=100000000]
    environmentR0C1 -> environmentR1C1 [weight=100000000]
    environmentR0C2 [label = <BTO<br/>ALT <br/>fi ["macCatalyst"]<br/>fo [")"]<br/>am []<br/>>]
    environmentR1C2 [label = <BTP<br/>T "macCatalyst"<br/>fi ["macCatalyst"]<br/>fo [")"]<br/>am []<br/>>]
    environmentR2C2 [label = <BTQ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    environmentR1C2 -> environmentR2C2 [weight=100000000]
    environmentR0C2 -> environmentR1C2 [weight=100000000]
    rank = same {environmentR0C1 -> environmentR0C2}
    rank = same {environmentR0C0 -> environmentR0C1}
    node [style = invis]
    edge [style = invis]
    environmentR0C0 -> environmentR1C0 [weight=100000000]
    rank = same {environmentR1C0 -> environmentR1C1}
    environmentR1C0 -> environmentR2C0 [weight=100000000]
    rank = same {environmentR2C0 -> environmentR2C1}
  }
  subgraph clusterkeyPathExpression {
    node [shape = box]
    label = <keyPathExpression = "\" [ type ] "." keyPathComponents .>
    labeljust = l
    keyPathExpressionR0C0 [label = <ALB<br/>N keyPathExpression<br/>fi ["\\"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathExpressionR0C1 [label = <AKS<br/>ALT <br/>fi ["\\"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathExpressionR1C1 [label = <AKT<br/>T "\"<br/>fi ["\\"]<br/>fo ["(", ".", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    keyPathExpressionR2C1 [label = <AKX<br/>OPT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["."]<br/>am []<br/>>]
    keyPathExpressionR3C1 [label = <AKY<br/>T "."<br/>fi ["."]<br/>fo ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>am []<br/>>]
    keyPathExpressionR4C1 [label = <AKZ<br/>N keyPathComponents<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathExpressionR5C1 [label = <ALA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathExpressionR4C1 -> keyPathExpressionR5C1 [weight=100000000]
    keyPathExpressionR3C1 -> keyPathExpressionR4C1 [weight=100000000]
    keyPathExpressionR2C1 -> keyPathExpressionR3C1 [weight=100000000]
    keyPathExpressionR2C2 [label = <AKV<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["."]<br/>am []<br/>>]
    keyPathExpressionR3C2 [label = <AKU<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["."]<br/>am []<br/>>]
    keyPathExpressionR4C2 [label = <AKW<br/>END <br/>fi [""]<br/>fo ["."]<br/>am []<br/>>]
    keyPathExpressionR3C2 -> keyPathExpressionR4C2 [weight=100000000]
    keyPathExpressionR2C2 -> keyPathExpressionR3C2 [weight=100000000]
    rank = same {keyPathExpressionR2C1 -> keyPathExpressionR2C2}
    keyPathExpressionR1C1 -> keyPathExpressionR2C1 [weight=100000000]
    keyPathExpressionR0C1 -> keyPathExpressionR1C1 [weight=100000000]
    rank = same {keyPathExpressionR0C0 -> keyPathExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {keyPathExpressionR0C1 -> keyPathExpressionR0C2}
    keyPathExpressionR0C0 -> keyPathExpressionR1C0 [weight=100000000]
    rank = same {keyPathExpressionR1C0 -> keyPathExpressionR1C1}
    keyPathExpressionR0C2 -> keyPathExpressionR1C2 [weight=100000000]
    rank = same {keyPathExpressionR1C1 -> keyPathExpressionR1C2}
    keyPathExpressionR1C0 -> keyPathExpressionR2C0 [weight=100000000]
    rank = same {keyPathExpressionR2C0 -> keyPathExpressionR2C1}
    keyPathExpressionR1C2 -> keyPathExpressionR2C2 [weight=100000000]
    keyPathExpressionR2C0 -> keyPathExpressionR3C0 [weight=100000000]
    rank = same {keyPathExpressionR3C0 -> keyPathExpressionR3C1}
    keyPathExpressionR3C0 -> keyPathExpressionR4C0 [weight=100000000]
    rank = same {keyPathExpressionR4C0 -> keyPathExpressionR4C1}
    keyPathExpressionR4C0 -> keyPathExpressionR5C0 [weight=100000000]
    rank = same {keyPathExpressionR5C0 -> keyPathExpressionR5C1}
    keyPathExpressionR4C2 -> keyPathExpressionR5C2 [weight=100000000]
    rank = same {keyPathExpressionR5C1 -> keyPathExpressionR5C2}
  }
  subgraph clusterbranchStatement {
    node [shape = box]
    label = <branchStatement = ifStatement | guardStatement | switchStatement .>
    labeljust = l
    branchStatementR0C0 [label = <BAP<br/>N branchStatement<br/>fi ["guard", "if", "switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR0C1 [label = <BAM<br/>ALT <br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C1 [label = <BAN<br/>N ifStatement<br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR2C1 [label = <BAO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C1 -> branchStatementR2C1 [weight=100000000]
    branchStatementR0C1 -> branchStatementR1C1 [weight=100000000]
    branchStatementR0C2 [label = <BAQ<br/>ALT <br/>fi ["guard"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C2 [label = <BAR<br/>N guardStatement<br/>fi ["guard"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR2C2 [label = <BAS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C2 -> branchStatementR2C2 [weight=100000000]
    branchStatementR0C2 -> branchStatementR1C2 [weight=100000000]
    branchStatementR0C3 [label = <BAT<br/>ALT <br/>fi ["switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C3 [label = <BAU<br/>N switchStatement<br/>fi ["switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR2C3 [label = <BAV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    branchStatementR1C3 -> branchStatementR2C3 [weight=100000000]
    branchStatementR0C3 -> branchStatementR1C3 [weight=100000000]
    rank = same {branchStatementR0C2 -> branchStatementR0C3}
    rank = same {branchStatementR0C1 -> branchStatementR0C2}
    rank = same {branchStatementR0C0 -> branchStatementR0C1}
    node [style = invis]
    edge [style = invis]
    branchStatementR0C0 -> branchStatementR1C0 [weight=100000000]
    rank = same {branchStatementR1C0 -> branchStatementR1C1}
    branchStatementR1C0 -> branchStatementR2C0 [weight=100000000]
    rank = same {branchStatementR2C0 -> branchStatementR2C1}
  }
  subgraph clusterswitchExpressionCases {
    node [shape = box]
    label = <switchExpressionCases = switchExpressionCase [ switchExpressionCases ] .>
    labeljust = l
    switchExpressionCasesR0C0 [label = <ACP<br/>N switchExpressionCases<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR0C1 [label = <ACI<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR1C1 [label = <ACJ<br/>N switchExpressionCase<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    switchExpressionCasesR2C1 [label = <ACN<br/>OPT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR3C1 [label = <ACO<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR2C1 -> switchExpressionCasesR3C1 [weight=100000000]
    switchExpressionCasesR2C2 [label = <ACL<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR3C2 [label = <ACK<br/>N switchExpressionCases<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR4C2 [label = <ACM<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionCasesR3C2 -> switchExpressionCasesR4C2 [weight=100000000]
    switchExpressionCasesR2C2 -> switchExpressionCasesR3C2 [weight=100000000]
    rank = same {switchExpressionCasesR2C1 -> switchExpressionCasesR2C2}
    switchExpressionCasesR1C1 -> switchExpressionCasesR2C1 [weight=100000000]
    switchExpressionCasesR0C1 -> switchExpressionCasesR1C1 [weight=100000000]
    rank = same {switchExpressionCasesR0C0 -> switchExpressionCasesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchExpressionCasesR0C1 -> switchExpressionCasesR0C2}
    switchExpressionCasesR0C0 -> switchExpressionCasesR1C0 [weight=100000000]
    rank = same {switchExpressionCasesR1C0 -> switchExpressionCasesR1C1}
    switchExpressionCasesR0C2 -> switchExpressionCasesR1C2 [weight=100000000]
    rank = same {switchExpressionCasesR1C1 -> switchExpressionCasesR1C2}
    switchExpressionCasesR1C0 -> switchExpressionCasesR2C0 [weight=100000000]
    rank = same {switchExpressionCasesR2C0 -> switchExpressionCasesR2C1}
    switchExpressionCasesR1C2 -> switchExpressionCasesR2C2 [weight=100000000]
    switchExpressionCasesR2C0 -> switchExpressionCasesR3C0 [weight=100000000]
    rank = same {switchExpressionCasesR3C0 -> switchExpressionCasesR3C1}
    switchExpressionCasesR3C0 -> switchExpressionCasesR4C0 [weight=100000000]
    switchExpressionCasesR3C1 -> switchExpressionCasesR4C1 [weight=100000000]
    rank = same {switchExpressionCasesR4C0 -> switchExpressionCasesR4C1}
    rank = same {switchExpressionCasesR4C1 -> switchExpressionCasesR4C2}
  }
  subgraph clusterelementName {
    node [shape = box]
    label = <elementName = identifier .>
    labeljust = l
    elementNameR0C0 [label = <IC<br/>N elementName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    elementNameR0C1 [label = <HZ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    elementNameR1C1 [label = <IA<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    elementNameR2C1 [label = <IB<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    elementNameR1C1 -> elementNameR2C1 [weight=100000000]
    elementNameR0C1 -> elementNameR1C1 [weight=100000000]
    rank = same {elementNameR0C0 -> elementNameR0C1}
    node [style = invis]
    edge [style = invis]
    elementNameR0C0 -> elementNameR1C0 [weight=100000000]
    rank = same {elementNameR1C0 -> elementNameR1C1}
    elementNameR1C0 -> elementNameR2C0 [weight=100000000]
    rank = same {elementNameR2C0 -> elementNameR2C1}
  }
  subgraph clusterintegerLiteral {
    node [shape = box]
    label = <integerLiteral = "binaryLiteral" | "octalLiteral" | "decimalLiteral" | "hexadecimalLiteral" .>
    labeljust = l
    integerLiteralR0C0 [label = <CK<br/>N integerLiteral<br/>fi ["binaryLiteral", "decimalLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR0C1 [label = <CH<br/>ALT <br/>fi ["binaryLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C1 [label = <CI<br/>T "binaryLiteral"<br/>fi ["binaryLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR2C1 [label = <CJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C1 -> integerLiteralR2C1 [weight=100000000]
    integerLiteralR0C1 -> integerLiteralR1C1 [weight=100000000]
    integerLiteralR0C2 [label = <CL<br/>ALT <br/>fi ["octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C2 [label = <CM<br/>T "octalLiteral"<br/>fi ["octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR2C2 [label = <CN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C2 -> integerLiteralR2C2 [weight=100000000]
    integerLiteralR0C2 -> integerLiteralR1C2 [weight=100000000]
    integerLiteralR0C3 [label = <CO<br/>ALT <br/>fi ["decimalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C3 [label = <CP<br/>T "decimalLiteral"<br/>fi ["decimalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR2C3 [label = <CQ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C3 -> integerLiteralR2C3 [weight=100000000]
    integerLiteralR0C3 -> integerLiteralR1C3 [weight=100000000]
    integerLiteralR0C4 [label = <CR<br/>ALT <br/>fi ["hexadecimalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C4 [label = <CS<br/>T "hexadecimalLiteral"<br/>fi ["hexadecimalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR2C4 [label = <CT<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    integerLiteralR1C4 -> integerLiteralR2C4 [weight=100000000]
    integerLiteralR0C4 -> integerLiteralR1C4 [weight=100000000]
    rank = same {integerLiteralR0C3 -> integerLiteralR0C4}
    rank = same {integerLiteralR0C2 -> integerLiteralR0C3}
    rank = same {integerLiteralR0C1 -> integerLiteralR0C2}
    rank = same {integerLiteralR0C0 -> integerLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    integerLiteralR0C0 -> integerLiteralR1C0 [weight=100000000]
    rank = same {integerLiteralR1C0 -> integerLiteralR1C1}
    integerLiteralR1C0 -> integerLiteralR2C0 [weight=100000000]
    rank = same {integerLiteralR2C0 -> integerLiteralR2C1}
  }
  subgraph clusterfunctionDeclaration {
    node [shape = box]
    label = <functionDeclaration = functionHead functionName [ genericParameterClause ] functionSignature [ genericWhereClause ] [ functionBody ] .>
    labeljust = l
    functionDeclarationR0C0 [label = <CMU<br/>N functionDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    functionDeclarationR0C1 [label = <CMD<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    functionDeclarationR1C1 [label = <CME<br/>N functionHead<br/>fi ["", "@"]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionDeclarationR2C1 [label = <CMF<br/>N functionName<br/>fi ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionDeclarationR3C1 [label = <CMJ<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    functionDeclarationR4C1 [label = <CMK<br/>N functionSignature<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionDeclarationR5C1 [label = <CMO<br/>OPT <br/>fi ["", "where"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    functionDeclarationR6C1 [label = <CMS<br/>OPT <br/>fi ["", "{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionDeclarationR7C1 [label = <CMT<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionDeclarationR6C1 -> functionDeclarationR7C1 [weight=100000000]
    functionDeclarationR6C2 [label = <CMQ<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionDeclarationR7C2 [label = <CMP<br/>N functionBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionDeclarationR8C2 [label = <CMR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    functionDeclarationR7C2 -> functionDeclarationR8C2 [weight=100000000]
    functionDeclarationR6C2 -> functionDeclarationR7C2 [weight=100000000]
    rank = same {functionDeclarationR6C1 -> functionDeclarationR6C2}
    functionDeclarationR5C1 -> functionDeclarationR6C1 [weight=100000000]
    functionDeclarationR5C3 [label = <CMM<br/>ALT <br/>fi ["where"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    functionDeclarationR6C3 [label = <CML<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    functionDeclarationR7C3 [label = <CMN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    functionDeclarationR6C3 -> functionDeclarationR7C3 [weight=100000000]
    functionDeclarationR5C3 -> functionDeclarationR6C3 [weight=100000000]
    rank = same {functionDeclarationR5C1 -> functionDeclarationR5C3}
    functionDeclarationR4C1 -> functionDeclarationR5C1 [weight=100000000]
    functionDeclarationR3C1 -> functionDeclarationR4C1 [weight=100000000]
    functionDeclarationR3C4 [label = <CMH<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    functionDeclarationR4C4 [label = <CMG<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    functionDeclarationR5C4 [label = <CMI<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    functionDeclarationR4C4 -> functionDeclarationR5C4 [weight=100000000]
    functionDeclarationR3C4 -> functionDeclarationR4C4 [weight=100000000]
    rank = same {functionDeclarationR3C1 -> functionDeclarationR3C4}
    functionDeclarationR2C1 -> functionDeclarationR3C1 [weight=100000000]
    functionDeclarationR1C1 -> functionDeclarationR2C1 [weight=100000000]
    functionDeclarationR0C1 -> functionDeclarationR1C1 [weight=100000000]
    rank = same {functionDeclarationR0C0 -> functionDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionDeclarationR0C1 -> functionDeclarationR0C2}
    rank = same {functionDeclarationR0C2 -> functionDeclarationR0C3}
    rank = same {functionDeclarationR0C3 -> functionDeclarationR0C4}
    functionDeclarationR0C0 -> functionDeclarationR1C0 [weight=100000000]
    rank = same {functionDeclarationR1C0 -> functionDeclarationR1C1}
    functionDeclarationR0C2 -> functionDeclarationR1C2 [weight=100000000]
    rank = same {functionDeclarationR1C1 -> functionDeclarationR1C2}
    functionDeclarationR0C3 -> functionDeclarationR1C3 [weight=100000000]
    rank = same {functionDeclarationR1C2 -> functionDeclarationR1C3}
    functionDeclarationR0C4 -> functionDeclarationR1C4 [weight=100000000]
    rank = same {functionDeclarationR1C3 -> functionDeclarationR1C4}
    functionDeclarationR1C0 -> functionDeclarationR2C0 [weight=100000000]
    rank = same {functionDeclarationR2C0 -> functionDeclarationR2C1}
    functionDeclarationR1C2 -> functionDeclarationR2C2 [weight=100000000]
    rank = same {functionDeclarationR2C1 -> functionDeclarationR2C2}
    functionDeclarationR1C3 -> functionDeclarationR2C3 [weight=100000000]
    rank = same {functionDeclarationR2C2 -> functionDeclarationR2C3}
    functionDeclarationR1C4 -> functionDeclarationR2C4 [weight=100000000]
    rank = same {functionDeclarationR2C3 -> functionDeclarationR2C4}
    functionDeclarationR2C0 -> functionDeclarationR3C0 [weight=100000000]
    rank = same {functionDeclarationR3C0 -> functionDeclarationR3C1}
    functionDeclarationR2C4 -> functionDeclarationR3C4 [weight=100000000]
    functionDeclarationR3C0 -> functionDeclarationR4C0 [weight=100000000]
    rank = same {functionDeclarationR4C0 -> functionDeclarationR4C1}
    rank = same {functionDeclarationR4C1 -> functionDeclarationR4C2}
    rank = same {functionDeclarationR4C2 -> functionDeclarationR4C3}
    rank = same {functionDeclarationR4C3 -> functionDeclarationR4C4}
    functionDeclarationR4C0 -> functionDeclarationR5C0 [weight=100000000]
    rank = same {functionDeclarationR5C0 -> functionDeclarationR5C1}
    functionDeclarationR4C3 -> functionDeclarationR5C3 [weight=100000000]
    functionDeclarationR5C0 -> functionDeclarationR6C0 [weight=100000000]
    rank = same {functionDeclarationR6C0 -> functionDeclarationR6C1}
    functionDeclarationR5C4 -> functionDeclarationR6C4 [weight=100000000]
    rank = same {functionDeclarationR6C3 -> functionDeclarationR6C4}
    functionDeclarationR6C0 -> functionDeclarationR7C0 [weight=100000000]
    rank = same {functionDeclarationR7C0 -> functionDeclarationR7C1}
    functionDeclarationR6C4 -> functionDeclarationR7C4 [weight=100000000]
    rank = same {functionDeclarationR7C3 -> functionDeclarationR7C4}
    functionDeclarationR7C0 -> functionDeclarationR8C0 [weight=100000000]
    functionDeclarationR7C1 -> functionDeclarationR8C1 [weight=100000000]
    rank = same {functionDeclarationR8C0 -> functionDeclarationR8C1}
    rank = same {functionDeclarationR8C1 -> functionDeclarationR8C2}
    functionDeclarationR7C3 -> functionDeclarationR8C3 [weight=100000000]
    rank = same {functionDeclarationR8C2 -> functionDeclarationR8C3}
    functionDeclarationR7C4 -> functionDeclarationR8C4 [weight=100000000]
    rank = same {functionDeclarationR8C3 -> functionDeclarationR8C4}
  }
  subgraph clusterselfType {
    node [shape = box]
    label = <selfType = "Self" .>
    labeljust = l
    selfTypeR0C0 [label = <NJ<br/>N selfType<br/>fi ["Self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfTypeR0C1 [label = <NG<br/>ALT <br/>fi ["Self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfTypeR1C1 [label = <NH<br/>T "Self"<br/>fi ["Self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfTypeR2C1 [label = <NI<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfTypeR1C1 -> selfTypeR2C1 [weight=100000000]
    selfTypeR0C1 -> selfTypeR1C1 [weight=100000000]
    rank = same {selfTypeR0C0 -> selfTypeR0C1}
    node [style = invis]
    edge [style = invis]
    selfTypeR0C0 -> selfTypeR1C0 [weight=100000000]
    rank = same {selfTypeR1C0 -> selfTypeR1C1}
    selfTypeR1C0 -> selfTypeR2C0 [weight=100000000]
    rank = same {selfTypeR2C0 -> selfTypeR2C1}
  }
  subgraph clusterclassDeclaration {
    node [shape = box]
    label = <classDeclaration = [ attributes ] [ accessLevelModifier ] [ "final" ] "class" className [ genericParameterClause ] [ typeInheritanceClause ] [ genericWhereClause ] classBody | [ attributes ] "final" [ accessLevelModifier ] "class" className [ genericParameterClause ] [ typeInheritanceClause ] [ genericWhereClause ] classBody .>
    labeljust = l
    classDeclarationR0C0 [label = <DCP<br/>N classDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    classDeclarationR0C1 [label = <DBM<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    classDeclarationR1C1 [label = <DBQ<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "fileprivate", "final", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    classDeclarationR2C1 [label = <DBU<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class", "final"]<br/>am []<br/>>]
    classDeclarationR3C1 [label = <DBY<br/>OPT <br/>fi ["", "final"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C1 [label = <DBZ<br/>T "class"<br/>fi ["class"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    classDeclarationR5C1 [label = <DCA<br/>N className<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classDeclarationR6C1 [label = <DCE<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C1 [label = <DCI<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C1 [label = <DCM<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C1 [label = <DCN<br/>N classBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classDeclarationR10C1 [label = <DCO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classDeclarationR9C1 -> classDeclarationR10C1 [weight=100000000]
    classDeclarationR8C1 -> classDeclarationR9C1 [weight=100000000]
    classDeclarationR8C2 [label = <DCK<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C2 [label = <DCJ<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR10C2 [label = <DCL<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C2 -> classDeclarationR10C2 [weight=100000000]
    classDeclarationR8C2 -> classDeclarationR9C2 [weight=100000000]
    rank = same {classDeclarationR8C1 -> classDeclarationR8C2}
    classDeclarationR7C1 -> classDeclarationR8C1 [weight=100000000]
    classDeclarationR7C3 [label = <DCG<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C3 [label = <DCF<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR9C3 [label = <DCH<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C3 -> classDeclarationR9C3 [weight=100000000]
    classDeclarationR7C3 -> classDeclarationR8C3 [weight=100000000]
    rank = same {classDeclarationR7C1 -> classDeclarationR7C3}
    classDeclarationR6C1 -> classDeclarationR7C1 [weight=100000000]
    classDeclarationR6C4 [label = <DCC<br/>ALT <br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C4 [label = <DCB<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR8C4 [label = <DCD<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C4 -> classDeclarationR8C4 [weight=100000000]
    classDeclarationR6C4 -> classDeclarationR7C4 [weight=100000000]
    rank = same {classDeclarationR6C1 -> classDeclarationR6C4}
    classDeclarationR5C1 -> classDeclarationR6C1 [weight=100000000]
    classDeclarationR4C1 -> classDeclarationR5C1 [weight=100000000]
    classDeclarationR3C1 -> classDeclarationR4C1 [weight=100000000]
    classDeclarationR3C5 [label = <DBW<br/>ALT <br/>fi ["final"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C5 [label = <DBV<br/>T "final"<br/>fi ["final"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR5C5 [label = <DBX<br/>END <br/>fi [""]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C5 -> classDeclarationR5C5 [weight=100000000]
    classDeclarationR3C5 -> classDeclarationR4C5 [weight=100000000]
    rank = same {classDeclarationR3C1 -> classDeclarationR3C5}
    classDeclarationR2C1 -> classDeclarationR3C1 [weight=100000000]
    classDeclarationR2C6 [label = <DBS<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class", "final"]<br/>am []<br/>>]
    classDeclarationR3C6 [label = <DBR<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class", "final"]<br/>am []<br/>>]
    classDeclarationR4C6 [label = <DBT<br/>END <br/>fi [""]<br/>fo ["class", "final"]<br/>am []<br/>>]
    classDeclarationR3C6 -> classDeclarationR4C6 [weight=100000000]
    classDeclarationR2C6 -> classDeclarationR3C6 [weight=100000000]
    rank = same {classDeclarationR2C1 -> classDeclarationR2C6}
    classDeclarationR1C1 -> classDeclarationR2C1 [weight=100000000]
    classDeclarationR1C7 [label = <DBO<br/>ALT <br/>fi ["@"]<br/>fo ["class", "fileprivate", "final", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    classDeclarationR2C7 [label = <DBN<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "fileprivate", "final", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    classDeclarationR3C7 [label = <DBP<br/>END <br/>fi [""]<br/>fo ["class", "fileprivate", "final", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    classDeclarationR2C7 -> classDeclarationR3C7 [weight=100000000]
    classDeclarationR1C7 -> classDeclarationR2C7 [weight=100000000]
    rank = same {classDeclarationR1C1 -> classDeclarationR1C7}
    classDeclarationR0C1 -> classDeclarationR1C1 [weight=100000000]
    classDeclarationR0C8 [label = <DCQ<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    classDeclarationR1C8 [label = <DCU<br/>OPT <br/>fi ["", "@"]<br/>fo ["final"]<br/>am []<br/>>]
    classDeclarationR2C8 [label = <DCV<br/>T "final"<br/>fi ["final"]<br/>fo ["class", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    classDeclarationR3C8 [label = <DCZ<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C8 [label = <DDA<br/>T "class"<br/>fi ["class"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    classDeclarationR5C8 [label = <DDB<br/>N className<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    classDeclarationR6C8 [label = <DDF<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C8 [label = <DDJ<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C8 [label = <DDN<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C8 [label = <DDO<br/>N classBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classDeclarationR10C8 [label = <DDP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    classDeclarationR9C8 -> classDeclarationR10C8 [weight=100000000]
    classDeclarationR8C8 -> classDeclarationR9C8 [weight=100000000]
    classDeclarationR8C9 [label = <DDL<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C9 [label = <DDK<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR10C9 [label = <DDM<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    classDeclarationR9C9 -> classDeclarationR10C9 [weight=100000000]
    classDeclarationR8C9 -> classDeclarationR9C9 [weight=100000000]
    rank = same {classDeclarationR8C8 -> classDeclarationR8C9}
    classDeclarationR7C8 -> classDeclarationR8C8 [weight=100000000]
    classDeclarationR7C10 [label = <DDH<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C10 [label = <DDG<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR9C10 [label = <DDI<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    classDeclarationR8C10 -> classDeclarationR9C10 [weight=100000000]
    classDeclarationR7C10 -> classDeclarationR8C10 [weight=100000000]
    rank = same {classDeclarationR7C8 -> classDeclarationR7C10}
    classDeclarationR6C8 -> classDeclarationR7C8 [weight=100000000]
    classDeclarationR6C11 [label = <DDD<br/>ALT <br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C11 [label = <DDC<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR8C11 [label = <DDE<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    classDeclarationR7C11 -> classDeclarationR8C11 [weight=100000000]
    classDeclarationR6C11 -> classDeclarationR7C11 [weight=100000000]
    rank = same {classDeclarationR6C8 -> classDeclarationR6C11}
    classDeclarationR5C8 -> classDeclarationR6C8 [weight=100000000]
    classDeclarationR4C8 -> classDeclarationR5C8 [weight=100000000]
    classDeclarationR3C8 -> classDeclarationR4C8 [weight=100000000]
    classDeclarationR3C12 [label = <DCX<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C12 [label = <DCW<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR5C12 [label = <DCY<br/>END <br/>fi [""]<br/>fo ["class"]<br/>am []<br/>>]
    classDeclarationR4C12 -> classDeclarationR5C12 [weight=100000000]
    classDeclarationR3C12 -> classDeclarationR4C12 [weight=100000000]
    rank = same {classDeclarationR3C8 -> classDeclarationR3C12}
    classDeclarationR2C8 -> classDeclarationR3C8 [weight=100000000]
    classDeclarationR1C8 -> classDeclarationR2C8 [weight=100000000]
    classDeclarationR1C13 [label = <DCS<br/>ALT <br/>fi ["@"]<br/>fo ["final"]<br/>am []<br/>>]
    classDeclarationR2C13 [label = <DCR<br/>N attributes<br/>fi ["@"]<br/>fo ["final"]<br/>am []<br/>>]
    classDeclarationR3C13 [label = <DCT<br/>END <br/>fi [""]<br/>fo ["final"]<br/>am []<br/>>]
    classDeclarationR2C13 -> classDeclarationR3C13 [weight=100000000]
    classDeclarationR1C13 -> classDeclarationR2C13 [weight=100000000]
    rank = same {classDeclarationR1C8 -> classDeclarationR1C13}
    classDeclarationR0C8 -> classDeclarationR1C8 [weight=100000000]
    rank = same {classDeclarationR0C1 -> classDeclarationR0C8}
    rank = same {classDeclarationR0C0 -> classDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {classDeclarationR0C8 -> classDeclarationR0C9}
    rank = same {classDeclarationR0C9 -> classDeclarationR0C10}
    rank = same {classDeclarationR0C10 -> classDeclarationR0C11}
    rank = same {classDeclarationR0C11 -> classDeclarationR0C12}
    rank = same {classDeclarationR0C12 -> classDeclarationR0C13}
    classDeclarationR0C0 -> classDeclarationR1C0 [weight=100000000]
    rank = same {classDeclarationR1C0 -> classDeclarationR1C1}
    classDeclarationR0C13 -> classDeclarationR1C13 [weight=100000000]
    classDeclarationR1C0 -> classDeclarationR2C0 [weight=100000000]
    rank = same {classDeclarationR2C0 -> classDeclarationR2C1}
    rank = same {classDeclarationR2C8 -> classDeclarationR2C9}
    rank = same {classDeclarationR2C9 -> classDeclarationR2C10}
    rank = same {classDeclarationR2C10 -> classDeclarationR2C11}
    rank = same {classDeclarationR2C11 -> classDeclarationR2C12}
    rank = same {classDeclarationR2C12 -> classDeclarationR2C13}
    classDeclarationR2C0 -> classDeclarationR3C0 [weight=100000000]
    rank = same {classDeclarationR3C0 -> classDeclarationR3C1}
    classDeclarationR2C12 -> classDeclarationR3C12 [weight=100000000]
    classDeclarationR3C0 -> classDeclarationR4C0 [weight=100000000]
    rank = same {classDeclarationR4C0 -> classDeclarationR4C1}
    rank = same {classDeclarationR4C1 -> classDeclarationR4C2}
    rank = same {classDeclarationR4C2 -> classDeclarationR4C3}
    rank = same {classDeclarationR4C3 -> classDeclarationR4C4}
    rank = same {classDeclarationR4C4 -> classDeclarationR4C5}
    classDeclarationR3C7 -> classDeclarationR4C7 [weight=100000000]
    rank = same {classDeclarationR4C6 -> classDeclarationR4C7}
    rank = same {classDeclarationR4C7 -> classDeclarationR4C8}
    rank = same {classDeclarationR4C8 -> classDeclarationR4C9}
    rank = same {classDeclarationR4C9 -> classDeclarationR4C10}
    rank = same {classDeclarationR4C10 -> classDeclarationR4C11}
    rank = same {classDeclarationR4C11 -> classDeclarationR4C12}
    classDeclarationR3C13 -> classDeclarationR4C13 [weight=100000000]
    rank = same {classDeclarationR4C12 -> classDeclarationR4C13}
    classDeclarationR4C0 -> classDeclarationR5C0 [weight=100000000]
    rank = same {classDeclarationR5C0 -> classDeclarationR5C1}
    classDeclarationR4C2 -> classDeclarationR5C2 [weight=100000000]
    rank = same {classDeclarationR5C1 -> classDeclarationR5C2}
    classDeclarationR4C3 -> classDeclarationR5C3 [weight=100000000]
    rank = same {classDeclarationR5C2 -> classDeclarationR5C3}
    classDeclarationR4C4 -> classDeclarationR5C4 [weight=100000000]
    rank = same {classDeclarationR5C3 -> classDeclarationR5C4}
    rank = same {classDeclarationR5C4 -> classDeclarationR5C5}
    classDeclarationR4C6 -> classDeclarationR5C6 [weight=100000000]
    rank = same {classDeclarationR5C5 -> classDeclarationR5C6}
    classDeclarationR4C7 -> classDeclarationR5C7 [weight=100000000]
    rank = same {classDeclarationR5C6 -> classDeclarationR5C7}
    rank = same {classDeclarationR5C7 -> classDeclarationR5C8}
    classDeclarationR4C9 -> classDeclarationR5C9 [weight=100000000]
    rank = same {classDeclarationR5C8 -> classDeclarationR5C9}
    classDeclarationR4C10 -> classDeclarationR5C10 [weight=100000000]
    rank = same {classDeclarationR5C9 -> classDeclarationR5C10}
    classDeclarationR4C11 -> classDeclarationR5C11 [weight=100000000]
    rank = same {classDeclarationR5C10 -> classDeclarationR5C11}
    rank = same {classDeclarationR5C11 -> classDeclarationR5C12}
    classDeclarationR4C13 -> classDeclarationR5C13 [weight=100000000]
    rank = same {classDeclarationR5C12 -> classDeclarationR5C13}
    classDeclarationR5C0 -> classDeclarationR6C0 [weight=100000000]
    rank = same {classDeclarationR6C0 -> classDeclarationR6C1}
    classDeclarationR5C4 -> classDeclarationR6C4 [weight=100000000]
    classDeclarationR5C5 -> classDeclarationR6C5 [weight=100000000]
    rank = same {classDeclarationR6C4 -> classDeclarationR6C5}
    classDeclarationR5C6 -> classDeclarationR6C6 [weight=100000000]
    rank = same {classDeclarationR6C5 -> classDeclarationR6C6}
    classDeclarationR5C7 -> classDeclarationR6C7 [weight=100000000]
    rank = same {classDeclarationR6C6 -> classDeclarationR6C7}
    rank = same {classDeclarationR6C7 -> classDeclarationR6C8}
    classDeclarationR5C11 -> classDeclarationR6C11 [weight=100000000]
    classDeclarationR5C12 -> classDeclarationR6C12 [weight=100000000]
    rank = same {classDeclarationR6C11 -> classDeclarationR6C12}
    classDeclarationR5C13 -> classDeclarationR6C13 [weight=100000000]
    rank = same {classDeclarationR6C12 -> classDeclarationR6C13}
    classDeclarationR6C0 -> classDeclarationR7C0 [weight=100000000]
    rank = same {classDeclarationR7C0 -> classDeclarationR7C1}
    classDeclarationR6C5 -> classDeclarationR7C5 [weight=100000000]
    rank = same {classDeclarationR7C4 -> classDeclarationR7C5}
    classDeclarationR6C6 -> classDeclarationR7C6 [weight=100000000]
    rank = same {classDeclarationR7C5 -> classDeclarationR7C6}
    classDeclarationR6C7 -> classDeclarationR7C7 [weight=100000000]
    rank = same {classDeclarationR7C6 -> classDeclarationR7C7}
    rank = same {classDeclarationR7C7 -> classDeclarationR7C8}
    classDeclarationR6C12 -> classDeclarationR7C12 [weight=100000000]
    rank = same {classDeclarationR7C11 -> classDeclarationR7C12}
    classDeclarationR6C13 -> classDeclarationR7C13 [weight=100000000]
    rank = same {classDeclarationR7C12 -> classDeclarationR7C13}
    classDeclarationR7C0 -> classDeclarationR8C0 [weight=100000000]
    rank = same {classDeclarationR8C0 -> classDeclarationR8C1}
    classDeclarationR7C5 -> classDeclarationR8C5 [weight=100000000]
    rank = same {classDeclarationR8C4 -> classDeclarationR8C5}
    classDeclarationR7C6 -> classDeclarationR8C6 [weight=100000000]
    rank = same {classDeclarationR8C5 -> classDeclarationR8C6}
    classDeclarationR7C7 -> classDeclarationR8C7 [weight=100000000]
    rank = same {classDeclarationR8C6 -> classDeclarationR8C7}
    rank = same {classDeclarationR8C7 -> classDeclarationR8C8}
    classDeclarationR7C12 -> classDeclarationR8C12 [weight=100000000]
    rank = same {classDeclarationR8C11 -> classDeclarationR8C12}
    classDeclarationR7C13 -> classDeclarationR8C13 [weight=100000000]
    rank = same {classDeclarationR8C12 -> classDeclarationR8C13}
    classDeclarationR8C0 -> classDeclarationR9C0 [weight=100000000]
    rank = same {classDeclarationR9C0 -> classDeclarationR9C1}
    classDeclarationR8C4 -> classDeclarationR9C4 [weight=100000000]
    rank = same {classDeclarationR9C3 -> classDeclarationR9C4}
    classDeclarationR8C5 -> classDeclarationR9C5 [weight=100000000]
    rank = same {classDeclarationR9C4 -> classDeclarationR9C5}
    classDeclarationR8C6 -> classDeclarationR9C6 [weight=100000000]
    rank = same {classDeclarationR9C5 -> classDeclarationR9C6}
    classDeclarationR8C7 -> classDeclarationR9C7 [weight=100000000]
    rank = same {classDeclarationR9C6 -> classDeclarationR9C7}
    rank = same {classDeclarationR9C7 -> classDeclarationR9C8}
    classDeclarationR8C11 -> classDeclarationR9C11 [weight=100000000]
    rank = same {classDeclarationR9C10 -> classDeclarationR9C11}
    classDeclarationR8C12 -> classDeclarationR9C12 [weight=100000000]
    rank = same {classDeclarationR9C11 -> classDeclarationR9C12}
    classDeclarationR8C13 -> classDeclarationR9C13 [weight=100000000]
    rank = same {classDeclarationR9C12 -> classDeclarationR9C13}
    classDeclarationR9C0 -> classDeclarationR10C0 [weight=100000000]
    rank = same {classDeclarationR10C0 -> classDeclarationR10C1}
    classDeclarationR9C3 -> classDeclarationR10C3 [weight=100000000]
    rank = same {classDeclarationR10C2 -> classDeclarationR10C3}
    classDeclarationR9C4 -> classDeclarationR10C4 [weight=100000000]
    rank = same {classDeclarationR10C3 -> classDeclarationR10C4}
    classDeclarationR9C5 -> classDeclarationR10C5 [weight=100000000]
    rank = same {classDeclarationR10C4 -> classDeclarationR10C5}
    classDeclarationR9C6 -> classDeclarationR10C6 [weight=100000000]
    rank = same {classDeclarationR10C5 -> classDeclarationR10C6}
    classDeclarationR9C7 -> classDeclarationR10C7 [weight=100000000]
    rank = same {classDeclarationR10C6 -> classDeclarationR10C7}
    rank = same {classDeclarationR10C7 -> classDeclarationR10C8}
    classDeclarationR9C10 -> classDeclarationR10C10 [weight=100000000]
    rank = same {classDeclarationR10C9 -> classDeclarationR10C10}
    classDeclarationR9C11 -> classDeclarationR10C11 [weight=100000000]
    rank = same {classDeclarationR10C10 -> classDeclarationR10C11}
    classDeclarationR9C12 -> classDeclarationR10C12 [weight=100000000]
    rank = same {classDeclarationR10C11 -> classDeclarationR10C12}
    classDeclarationR9C13 -> classDeclarationR10C13 [weight=100000000]
    rank = same {classDeclarationR10C12 -> classDeclarationR10C13}
  }
  subgraph clusterextensionBody {
    node [shape = box]
    label = <extensionBody = "{" [ extensionMembers ] "}" .>
    labeljust = l
    extensionBodyR0C0 [label = <DRI<br/>N extensionBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionBodyR0C1 [label = <DRA<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionBodyR1C1 [label = <DRB<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    extensionBodyR2C1 [label = <DRF<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionBodyR3C1 [label = <DRG<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionBodyR4C1 [label = <DRH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionBodyR3C1 -> extensionBodyR4C1 [weight=100000000]
    extensionBodyR2C1 -> extensionBodyR3C1 [weight=100000000]
    extensionBodyR2C2 [label = <DRD<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionBodyR3C2 [label = <DRC<br/>N extensionMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionBodyR4C2 [label = <DRE<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    extensionBodyR3C2 -> extensionBodyR4C2 [weight=100000000]
    extensionBodyR2C2 -> extensionBodyR3C2 [weight=100000000]
    rank = same {extensionBodyR2C1 -> extensionBodyR2C2}
    extensionBodyR1C1 -> extensionBodyR2C1 [weight=100000000]
    extensionBodyR0C1 -> extensionBodyR1C1 [weight=100000000]
    rank = same {extensionBodyR0C0 -> extensionBodyR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {extensionBodyR0C1 -> extensionBodyR0C2}
    extensionBodyR0C0 -> extensionBodyR1C0 [weight=100000000]
    rank = same {extensionBodyR1C0 -> extensionBodyR1C1}
    extensionBodyR0C2 -> extensionBodyR1C2 [weight=100000000]
    rank = same {extensionBodyR1C1 -> extensionBodyR1C2}
    extensionBodyR1C0 -> extensionBodyR2C0 [weight=100000000]
    rank = same {extensionBodyR2C0 -> extensionBodyR2C1}
    extensionBodyR1C2 -> extensionBodyR2C2 [weight=100000000]
    extensionBodyR2C0 -> extensionBodyR3C0 [weight=100000000]
    rank = same {extensionBodyR3C0 -> extensionBodyR3C1}
    extensionBodyR3C0 -> extensionBodyR4C0 [weight=100000000]
    rank = same {extensionBodyR4C0 -> extensionBodyR4C1}
  }
  subgraph clusterbalancedToken {
    node [shape = box]
    label = <balancedToken = "(" [ balancedTokens ] | [ "innerBalancedToken" ] ")" | "[" [ balancedTokens ] | [ "innerBalancedToken" ] "]" | "{" [ balancedTokens ] | [ "innerBalancedToken" ] "}" .>
    labeljust = l
    balancedTokenR0C0 [label = <EHS<br/>N balancedToken<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR0C1 [label = <EHE<br/>ALT <br/>fi ["("]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR1C1 [label = <EHF<br/>T "("<br/>fi ["("]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C1 [label = <EHJ<br/>OPT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C1 [label = <EHK<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C1 -> balancedTokenR3C1 [weight=100000000]
    balancedTokenR2C2 [label = <EHH<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C2 [label = <EHG<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR4C2 [label = <EHI<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C2 -> balancedTokenR4C2 [weight=100000000]
    balancedTokenR2C2 -> balancedTokenR3C2 [weight=100000000]
    rank = same {balancedTokenR2C1 -> balancedTokenR2C2}
    balancedTokenR1C1 -> balancedTokenR2C1 [weight=100000000]
    balancedTokenR0C1 -> balancedTokenR1C1 [weight=100000000]
    balancedTokenR0C3 [label = <EHL<br/>ALT <br/>fi ["", "innerBalancedToken"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["innerBalancedToken"]<br/>>]
    balancedTokenR1C3 [label = <EHP<br/>OPT <br/>fi ["", "innerBalancedToken"]<br/>fo [")"]<br/>am []<br/>>]
    balancedTokenR2C3 [label = <EHQ<br/>T ")"<br/>fi [")"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C3 [label = <EHR<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C3 -> balancedTokenR3C3 [weight=100000000]
    balancedTokenR1C3 -> balancedTokenR2C3 [weight=100000000]
    balancedTokenR1C4 [label = <EHN<br/>ALT <br/>fi ["innerBalancedToken"]<br/>fo [")"]<br/>am []<br/>>]
    balancedTokenR2C4 [label = <EHM<br/>T "innerBalancedToken"<br/>fi ["innerBalancedToken"]<br/>fo [")"]<br/>am []<br/>>]
    balancedTokenR3C4 [label = <EHO<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    balancedTokenR2C4 -> balancedTokenR3C4 [weight=100000000]
    balancedTokenR1C4 -> balancedTokenR2C4 [weight=100000000]
    rank = same {balancedTokenR1C3 -> balancedTokenR1C4}
    balancedTokenR0C3 -> balancedTokenR1C3 [weight=100000000]
    balancedTokenR0C5 [label = <EHT<br/>ALT <br/>fi ["["]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR1C5 [label = <EHU<br/>T "["<br/>fi ["["]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C5 [label = <EHY<br/>OPT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C5 [label = <EHZ<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C5 -> balancedTokenR3C5 [weight=100000000]
    balancedTokenR2C6 [label = <EHW<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C6 [label = <EHV<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR4C6 [label = <EHX<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C6 -> balancedTokenR4C6 [weight=100000000]
    balancedTokenR2C6 -> balancedTokenR3C6 [weight=100000000]
    rank = same {balancedTokenR2C5 -> balancedTokenR2C6}
    balancedTokenR1C5 -> balancedTokenR2C5 [weight=100000000]
    balancedTokenR0C5 -> balancedTokenR1C5 [weight=100000000]
    balancedTokenR0C7 [label = <EIA<br/>ALT <br/>fi ["", "innerBalancedToken"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["innerBalancedToken"]<br/>>]
    balancedTokenR1C7 [label = <EIE<br/>OPT <br/>fi ["", "innerBalancedToken"]<br/>fo ["]"]<br/>am []<br/>>]
    balancedTokenR2C7 [label = <EIF<br/>T "]"<br/>fi ["]"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C7 [label = <EIG<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C7 -> balancedTokenR3C7 [weight=100000000]
    balancedTokenR1C7 -> balancedTokenR2C7 [weight=100000000]
    balancedTokenR1C8 [label = <EIC<br/>ALT <br/>fi ["innerBalancedToken"]<br/>fo ["]"]<br/>am []<br/>>]
    balancedTokenR2C8 [label = <EIB<br/>T "innerBalancedToken"<br/>fi ["innerBalancedToken"]<br/>fo ["]"]<br/>am []<br/>>]
    balancedTokenR3C8 [label = <EID<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    balancedTokenR2C8 -> balancedTokenR3C8 [weight=100000000]
    balancedTokenR1C8 -> balancedTokenR2C8 [weight=100000000]
    rank = same {balancedTokenR1C7 -> balancedTokenR1C8}
    balancedTokenR0C7 -> balancedTokenR1C7 [weight=100000000]
    balancedTokenR0C9 [label = <EIH<br/>ALT <br/>fi ["{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR1C9 [label = <EII<br/>T "{"<br/>fi ["{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C9 [label = <EIM<br/>OPT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C9 [label = <EIN<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C9 -> balancedTokenR3C9 [weight=100000000]
    balancedTokenR2C10 [label = <EIK<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR3C10 [label = <EIJ<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["(", "[", "innerBalancedToken", "{"]<br/>>]
    balancedTokenR4C10 [label = <EIL<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C10 -> balancedTokenR4C10 [weight=100000000]
    balancedTokenR2C10 -> balancedTokenR3C10 [weight=100000000]
    rank = same {balancedTokenR2C9 -> balancedTokenR2C10}
    balancedTokenR1C9 -> balancedTokenR2C9 [weight=100000000]
    balancedTokenR0C9 -> balancedTokenR1C9 [weight=100000000]
    balancedTokenR0C11 [label = <EIO<br/>ALT <br/>fi ["", "innerBalancedToken"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am ["innerBalancedToken"]<br/>>]
    balancedTokenR1C11 [label = <EIS<br/>OPT <br/>fi ["", "innerBalancedToken"]<br/>fo ["}"]<br/>am []<br/>>]
    balancedTokenR2C11 [label = <EIT<br/>T "}"<br/>fi ["}"]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR3C11 [label = <EIU<br/>END <br/>fi [""]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    balancedTokenR2C11 -> balancedTokenR3C11 [weight=100000000]
    balancedTokenR1C11 -> balancedTokenR2C11 [weight=100000000]
    balancedTokenR1C12 [label = <EIQ<br/>ALT <br/>fi ["innerBalancedToken"]<br/>fo ["}"]<br/>am []<br/>>]
    balancedTokenR2C12 [label = <EIP<br/>T "innerBalancedToken"<br/>fi ["innerBalancedToken"]<br/>fo ["}"]<br/>am []<br/>>]
    balancedTokenR3C12 [label = <EIR<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    balancedTokenR2C12 -> balancedTokenR3C12 [weight=100000000]
    balancedTokenR1C12 -> balancedTokenR2C12 [weight=100000000]
    rank = same {balancedTokenR1C11 -> balancedTokenR1C12}
    balancedTokenR0C11 -> balancedTokenR1C11 [weight=100000000]
    rank = same {balancedTokenR0C9 -> balancedTokenR0C11}
    rank = same {balancedTokenR0C7 -> balancedTokenR0C9}
    rank = same {balancedTokenR0C5 -> balancedTokenR0C7}
    rank = same {balancedTokenR0C3 -> balancedTokenR0C5}
    rank = same {balancedTokenR0C1 -> balancedTokenR0C3}
    rank = same {balancedTokenR0C0 -> balancedTokenR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {balancedTokenR0C11 -> balancedTokenR0C12}
    balancedTokenR0C0 -> balancedTokenR1C0 [weight=100000000]
    rank = same {balancedTokenR1C0 -> balancedTokenR1C1}
    rank = same {balancedTokenR1C1 -> balancedTokenR1C2}
    rank = same {balancedTokenR1C2 -> balancedTokenR1C3}
    rank = same {balancedTokenR1C5 -> balancedTokenR1C6}
    rank = same {balancedTokenR1C6 -> balancedTokenR1C7}
    rank = same {balancedTokenR1C9 -> balancedTokenR1C10}
    rank = same {balancedTokenR1C10 -> balancedTokenR1C11}
    balancedTokenR0C12 -> balancedTokenR1C12 [weight=100000000]
    balancedTokenR1C0 -> balancedTokenR2C0 [weight=100000000]
    rank = same {balancedTokenR2C0 -> balancedTokenR2C1}
    balancedTokenR1C2 -> balancedTokenR2C2 [weight=100000000]
    balancedTokenR1C6 -> balancedTokenR2C6 [weight=100000000]
    balancedTokenR1C10 -> balancedTokenR2C10 [weight=100000000]
    balancedTokenR2C0 -> balancedTokenR3C0 [weight=100000000]
    rank = same {balancedTokenR3C0 -> balancedTokenR3C1}
    balancedTokenR3C0 -> balancedTokenR4C0 [weight=100000000]
    balancedTokenR3C1 -> balancedTokenR4C1 [weight=100000000]
    rank = same {balancedTokenR4C0 -> balancedTokenR4C1}
    rank = same {balancedTokenR4C1 -> balancedTokenR4C2}
    balancedTokenR3C3 -> balancedTokenR4C3 [weight=100000000]
    rank = same {balancedTokenR4C2 -> balancedTokenR4C3}
    balancedTokenR3C4 -> balancedTokenR4C4 [weight=100000000]
    rank = same {balancedTokenR4C3 -> balancedTokenR4C4}
    balancedTokenR3C5 -> balancedTokenR4C5 [weight=100000000]
    rank = same {balancedTokenR4C4 -> balancedTokenR4C5}
    rank = same {balancedTokenR4C5 -> balancedTokenR4C6}
    balancedTokenR3C7 -> balancedTokenR4C7 [weight=100000000]
    rank = same {balancedTokenR4C6 -> balancedTokenR4C7}
    balancedTokenR3C8 -> balancedTokenR4C8 [weight=100000000]
    rank = same {balancedTokenR4C7 -> balancedTokenR4C8}
    balancedTokenR3C9 -> balancedTokenR4C9 [weight=100000000]
    rank = same {balancedTokenR4C8 -> balancedTokenR4C9}
    rank = same {balancedTokenR4C9 -> balancedTokenR4C10}
    balancedTokenR3C11 -> balancedTokenR4C11 [weight=100000000]
    rank = same {balancedTokenR4C10 -> balancedTokenR4C11}
    balancedTokenR3C12 -> balancedTokenR4C12 [weight=100000000]
    rank = same {balancedTokenR4C11 -> balancedTokenR4C12}
  }
  subgraph clustermacroDefinition {
    node [shape = box]
    label = <macroDefinition = "=" expression .>
    labeljust = l
    macroDefinitionR0C0 [label = <DVS<br/>N macroDefinition<br/>fi ["="]<br/>fo ["where"]<br/>am []<br/>>]
    macroDefinitionR0C1 [label = <DVO<br/>ALT <br/>fi ["="]<br/>fo ["where"]<br/>am []<br/>>]
    macroDefinitionR1C1 [label = <DVP<br/>T "="<br/>fi ["="]<br/>fo ["try", "where"]<br/>am []<br/>>]
    macroDefinitionR2C1 [label = <DVQ<br/>N expression<br/>fi ["", "try"]<br/>fo ["where"]<br/>am []<br/>>]
    macroDefinitionR3C1 [label = <DVR<br/>END <br/>fi [""]<br/>fo ["where"]<br/>am []<br/>>]
    macroDefinitionR2C1 -> macroDefinitionR3C1 [weight=100000000]
    macroDefinitionR1C1 -> macroDefinitionR2C1 [weight=100000000]
    macroDefinitionR0C1 -> macroDefinitionR1C1 [weight=100000000]
    rank = same {macroDefinitionR0C0 -> macroDefinitionR0C1}
    node [style = invis]
    edge [style = invis]
    macroDefinitionR0C0 -> macroDefinitionR1C0 [weight=100000000]
    rank = same {macroDefinitionR1C0 -> macroDefinitionR1C1}
    macroDefinitionR1C0 -> macroDefinitionR2C0 [weight=100000000]
    rank = same {macroDefinitionR2C0 -> macroDefinitionR2C1}
    macroDefinitionR2C0 -> macroDefinitionR3C0 [weight=100000000]
    rank = same {macroDefinitionR3C0 -> macroDefinitionR3C1}
  }
  subgraph clusterasPattern {
    node [shape = box]
    label = <asPattern = pattern "as" type .>
    labeljust = l
    asPatternR0C0 [label = <ENH<br/>N asPattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    asPatternR0C1 [label = <ENC<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    asPatternR1C1 [label = <END<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["as"]<br/>am []<br/>>]
    asPatternR2C1 [label = <ENE<br/>T "as"<br/>fi ["as"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    asPatternR3C1 [label = <ENF<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    asPatternR4C1 [label = <ENG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    asPatternR3C1 -> asPatternR4C1 [weight=100000000]
    asPatternR2C1 -> asPatternR3C1 [weight=100000000]
    asPatternR1C1 -> asPatternR2C1 [weight=100000000]
    asPatternR0C1 -> asPatternR1C1 [weight=100000000]
    rank = same {asPatternR0C0 -> asPatternR0C1}
    node [style = invis]
    edge [style = invis]
    asPatternR0C0 -> asPatternR1C0 [weight=100000000]
    rank = same {asPatternR1C0 -> asPatternR1C1}
    asPatternR1C0 -> asPatternR2C0 [weight=100000000]
    rank = same {asPatternR2C0 -> asPatternR2C1}
    asPatternR2C0 -> asPatternR3C0 [weight=100000000]
    rank = same {asPatternR3C0 -> asPatternR3C1}
    asPatternR3C0 -> asPatternR4C0 [weight=100000000]
    rank = same {asPatternR4C0 -> asPatternR4C1}
  }
  subgraph clusterarrayType {
    node [shape = box]
    label = <arrayType = "[" type "]" .>
    labeljust = l
    arrayTypeR0C0 [label = <LB<br/>N arrayType<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayTypeR0C1 [label = <KW<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayTypeR1C1 [label = <KX<br/>T "["<br/>fi ["["]<br/>fo ["(", "@", "Any", "Self", "[", "]", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    arrayTypeR2C1 [label = <KY<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["]"]<br/>am []<br/>>]
    arrayTypeR3C1 [label = <KZ<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayTypeR4C1 [label = <LA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    arrayTypeR3C1 -> arrayTypeR4C1 [weight=100000000]
    arrayTypeR2C1 -> arrayTypeR3C1 [weight=100000000]
    arrayTypeR1C1 -> arrayTypeR2C1 [weight=100000000]
    arrayTypeR0C1 -> arrayTypeR1C1 [weight=100000000]
    rank = same {arrayTypeR0C0 -> arrayTypeR0C1}
    node [style = invis]
    edge [style = invis]
    arrayTypeR0C0 -> arrayTypeR1C0 [weight=100000000]
    rank = same {arrayTypeR1C0 -> arrayTypeR1C1}
    arrayTypeR1C0 -> arrayTypeR2C0 [weight=100000000]
    rank = same {arrayTypeR2C0 -> arrayTypeR2C1}
    arrayTypeR2C0 -> arrayTypeR3C0 [weight=100000000]
    rank = same {arrayTypeR3C0 -> arrayTypeR3C1}
    arrayTypeR3C0 -> arrayTypeR4C0 [weight=100000000]
    rank = same {arrayTypeR4C0 -> arrayTypeR4C1}
  }
  subgraph clusterswitchCase {
    node [shape = box]
    label = <switchCase = caseLabel statements | defaultLabel statements | conditionalSwitchCase .>
    labeljust = l
    switchCaseR0C0 [label = <BCT<br/>N switchCase<br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    switchCaseR0C1 [label = <BCP<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["@"]<br/>>]
    switchCaseR1C1 [label = <BCQ<br/>N caseLabel<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    switchCaseR2C1 [label = <BCR<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    switchCaseR3C1 [label = <BCS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    switchCaseR2C1 -> switchCaseR3C1 [weight=100000000]
    switchCaseR1C1 -> switchCaseR2C1 [weight=100000000]
    switchCaseR0C1 -> switchCaseR1C1 [weight=100000000]
    switchCaseR0C2 [label = <BCU<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["@"]<br/>>]
    switchCaseR1C2 [label = <BCV<br/>N defaultLabel<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    switchCaseR2C2 [label = <BCW<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    switchCaseR3C2 [label = <BCX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    switchCaseR2C2 -> switchCaseR3C2 [weight=100000000]
    switchCaseR1C2 -> switchCaseR2C2 [weight=100000000]
    switchCaseR0C2 -> switchCaseR1C2 [weight=100000000]
    switchCaseR0C3 [label = <BCY<br/>ALT <br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    switchCaseR1C3 [label = <BCZ<br/>N conditionalSwitchCase<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    switchCaseR2C3 [label = <BDA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    switchCaseR1C3 -> switchCaseR2C3 [weight=100000000]
    switchCaseR0C3 -> switchCaseR1C3 [weight=100000000]
    rank = same {switchCaseR0C2 -> switchCaseR0C3}
    rank = same {switchCaseR0C1 -> switchCaseR0C2}
    rank = same {switchCaseR0C0 -> switchCaseR0C1}
    node [style = invis]
    edge [style = invis]
    switchCaseR0C0 -> switchCaseR1C0 [weight=100000000]
    rank = same {switchCaseR1C0 -> switchCaseR1C1}
    switchCaseR1C0 -> switchCaseR2C0 [weight=100000000]
    rank = same {switchCaseR2C0 -> switchCaseR2C1}
    switchCaseR2C0 -> switchCaseR3C0 [weight=100000000]
    rank = same {switchCaseR3C0 -> switchCaseR3C1}
    switchCaseR2C3 -> switchCaseR3C3 [weight=100000000]
    rank = same {switchCaseR3C2 -> switchCaseR3C3}
  }
  subgraph clusterparameterTypeAnnotation {
    node [shape = box]
    label = <parameterTypeAnnotation = ":" [ attributes ] [ parameterModifier ] type .>
    labeljust = l
    parameterTypeAnnotationR0C0 [label = <CRU<br/>N parameterTypeAnnotation<br/>fi [":"]<br/>fo [")", ",", "...", "="]<br/>am []<br/>>]
    parameterTypeAnnotationR0C1 [label = <CRI<br/>ALT <br/>fi [":"]<br/>fo [")", ",", "...", "="]<br/>am []<br/>>]
    parameterTypeAnnotationR1C1 [label = <CRJ<br/>T ":"<br/>fi [":"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "borrowing", "consuming", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR2C1 [label = <CRN<br/>OPT <br/>fi ["", "@"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "borrowing", "consuming", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am ["@"]<br/>>]
    parameterTypeAnnotationR3C1 [label = <CRR<br/>OPT <br/>fi ["", "borrowing", "consuming", "inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR4C1 [label = <CRS<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")", ",", "...", "="]<br/>am []<br/>>]
    parameterTypeAnnotationR5C1 [label = <CRT<br/>END <br/>fi [""]<br/>fo [")", ",", "...", "="]<br/>am []<br/>>]
    parameterTypeAnnotationR4C1 -> parameterTypeAnnotationR5C1 [weight=100000000]
    parameterTypeAnnotationR3C1 -> parameterTypeAnnotationR4C1 [weight=100000000]
    parameterTypeAnnotationR3C2 [label = <CRP<br/>ALT <br/>fi ["borrowing", "consuming", "inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR4C2 [label = <CRO<br/>N parameterModifier<br/>fi ["borrowing", "consuming", "inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR5C2 [label = <CRQ<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR4C2 -> parameterTypeAnnotationR5C2 [weight=100000000]
    parameterTypeAnnotationR3C2 -> parameterTypeAnnotationR4C2 [weight=100000000]
    rank = same {parameterTypeAnnotationR3C1 -> parameterTypeAnnotationR3C2}
    parameterTypeAnnotationR2C1 -> parameterTypeAnnotationR3C1 [weight=100000000]
    parameterTypeAnnotationR2C3 [label = <CRL<br/>ALT <br/>fi ["@"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "borrowing", "consuming", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR3C3 [label = <CRK<br/>N attributes<br/>fi ["@"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "borrowing", "consuming", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR4C3 [label = <CRM<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "borrowing", "consuming", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterTypeAnnotationR3C3 -> parameterTypeAnnotationR4C3 [weight=100000000]
    parameterTypeAnnotationR2C3 -> parameterTypeAnnotationR3C3 [weight=100000000]
    rank = same {parameterTypeAnnotationR2C1 -> parameterTypeAnnotationR2C3}
    parameterTypeAnnotationR1C1 -> parameterTypeAnnotationR2C1 [weight=100000000]
    parameterTypeAnnotationR0C1 -> parameterTypeAnnotationR1C1 [weight=100000000]
    rank = same {parameterTypeAnnotationR0C0 -> parameterTypeAnnotationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {parameterTypeAnnotationR0C1 -> parameterTypeAnnotationR0C2}
    rank = same {parameterTypeAnnotationR0C2 -> parameterTypeAnnotationR0C3}
    parameterTypeAnnotationR0C0 -> parameterTypeAnnotationR1C0 [weight=100000000]
    rank = same {parameterTypeAnnotationR1C0 -> parameterTypeAnnotationR1C1}
    parameterTypeAnnotationR0C2 -> parameterTypeAnnotationR1C2 [weight=100000000]
    rank = same {parameterTypeAnnotationR1C1 -> parameterTypeAnnotationR1C2}
    parameterTypeAnnotationR0C3 -> parameterTypeAnnotationR1C3 [weight=100000000]
    rank = same {parameterTypeAnnotationR1C2 -> parameterTypeAnnotationR1C3}
    parameterTypeAnnotationR1C0 -> parameterTypeAnnotationR2C0 [weight=100000000]
    rank = same {parameterTypeAnnotationR2C0 -> parameterTypeAnnotationR2C1}
    parameterTypeAnnotationR1C3 -> parameterTypeAnnotationR2C3 [weight=100000000]
    parameterTypeAnnotationR2C0 -> parameterTypeAnnotationR3C0 [weight=100000000]
    rank = same {parameterTypeAnnotationR3C0 -> parameterTypeAnnotationR3C1}
    parameterTypeAnnotationR3C0 -> parameterTypeAnnotationR4C0 [weight=100000000]
    rank = same {parameterTypeAnnotationR4C0 -> parameterTypeAnnotationR4C1}
    parameterTypeAnnotationR4C0 -> parameterTypeAnnotationR5C0 [weight=100000000]
    rank = same {parameterTypeAnnotationR5C0 -> parameterTypeAnnotationR5C1}
    parameterTypeAnnotationR4C3 -> parameterTypeAnnotationR5C3 [weight=100000000]
    rank = same {parameterTypeAnnotationR5C2 -> parameterTypeAnnotationR5C3}
  }
  subgraph clusterkeyPathPostfix {
    node [shape = box]
    label = <keyPathPostfix = "?" | "!" | "self" | "[" functionCallArgumentList "]" .>
    labeljust = l
    keyPathPostfixR0C0 [label = <AMS<br/>N keyPathPostfix<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR0C1 [label = <AME<br/>ALT <br/>fi ["?"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C1 [label = <AMF<br/>T "?"<br/>fi ["?"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR2C1 [label = <AMG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C1 -> keyPathPostfixR2C1 [weight=100000000]
    keyPathPostfixR0C1 -> keyPathPostfixR1C1 [weight=100000000]
    keyPathPostfixR0C2 [label = <AMH<br/>ALT <br/>fi ["!"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C2 [label = <AMI<br/>T "!"<br/>fi ["!"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR2C2 [label = <AMJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C2 -> keyPathPostfixR2C2 [weight=100000000]
    keyPathPostfixR0C2 -> keyPathPostfixR1C2 [weight=100000000]
    keyPathPostfixR0C3 [label = <AMK<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C3 [label = <AML<br/>T "self"<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR2C3 [label = <AMM<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C3 -> keyPathPostfixR2C3 [weight=100000000]
    keyPathPostfixR0C3 -> keyPathPostfixR1C3 [weight=100000000]
    keyPathPostfixR0C4 [label = <AMN<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR1C4 [label = <AMO<br/>T "["<br/>fi ["["]<br/>fo ["]", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    keyPathPostfixR2C4 [label = <AMP<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    keyPathPostfixR3C4 [label = <AMQ<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR4C4 [label = <AMR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathPostfixR3C4 -> keyPathPostfixR4C4 [weight=100000000]
    keyPathPostfixR2C4 -> keyPathPostfixR3C4 [weight=100000000]
    keyPathPostfixR1C4 -> keyPathPostfixR2C4 [weight=100000000]
    keyPathPostfixR0C4 -> keyPathPostfixR1C4 [weight=100000000]
    rank = same {keyPathPostfixR0C3 -> keyPathPostfixR0C4}
    rank = same {keyPathPostfixR0C2 -> keyPathPostfixR0C3}
    rank = same {keyPathPostfixR0C1 -> keyPathPostfixR0C2}
    rank = same {keyPathPostfixR0C0 -> keyPathPostfixR0C1}
    node [style = invis]
    edge [style = invis]
    keyPathPostfixR0C0 -> keyPathPostfixR1C0 [weight=100000000]
    rank = same {keyPathPostfixR1C0 -> keyPathPostfixR1C1}
    keyPathPostfixR1C0 -> keyPathPostfixR2C0 [weight=100000000]
    rank = same {keyPathPostfixR2C0 -> keyPathPostfixR2C1}
    keyPathPostfixR2C0 -> keyPathPostfixR3C0 [weight=100000000]
    keyPathPostfixR2C1 -> keyPathPostfixR3C1 [weight=100000000]
    rank = same {keyPathPostfixR3C0 -> keyPathPostfixR3C1}
    keyPathPostfixR2C2 -> keyPathPostfixR3C2 [weight=100000000]
    rank = same {keyPathPostfixR3C1 -> keyPathPostfixR3C2}
    keyPathPostfixR2C3 -> keyPathPostfixR3C3 [weight=100000000]
    rank = same {keyPathPostfixR3C2 -> keyPathPostfixR3C3}
    rank = same {keyPathPostfixR3C3 -> keyPathPostfixR3C4}
    keyPathPostfixR3C0 -> keyPathPostfixR4C0 [weight=100000000]
    keyPathPostfixR3C1 -> keyPathPostfixR4C1 [weight=100000000]
    rank = same {keyPathPostfixR4C0 -> keyPathPostfixR4C1}
    keyPathPostfixR3C2 -> keyPathPostfixR4C2 [weight=100000000]
    rank = same {keyPathPostfixR4C1 -> keyPathPostfixR4C2}
    keyPathPostfixR3C3 -> keyPathPostfixR4C3 [weight=100000000]
    rank = same {keyPathPostfixR4C2 -> keyPathPostfixR4C3}
    rank = same {keyPathPostfixR4C3 -> keyPathPostfixR4C4}
  }
  subgraph clustervariableName {
    node [shape = box]
    label = <variableName = identifier .>
    labeljust = l
    variableNameR0C0 [label = <CFR<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "="]<br/>am []<br/>>]
    variableNameR0C1 [label = <CFO<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "="]<br/>am []<br/>>]
    variableNameR1C1 [label = <CFP<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "="]<br/>am []<br/>>]
    variableNameR2C1 [label = <CFQ<br/>END <br/>fi [""]<br/>fo [":", "="]<br/>am []<br/>>]
    variableNameR1C1 -> variableNameR2C1 [weight=100000000]
    variableNameR0C1 -> variableNameR1C1 [weight=100000000]
    rank = same {variableNameR0C0 -> variableNameR0C1}
    node [style = invis]
    edge [style = invis]
    variableNameR0C0 -> variableNameR1C0 [weight=100000000]
    rank = same {variableNameR1C0 -> variableNameR1C1}
    variableNameR1C0 -> variableNameR2C0 [weight=100000000]
    rank = same {variableNameR2C0 -> variableNameR2C1}
  }
  subgraph clusterprefixExpression {
    node [shape = box]
    label = <prefixExpression = [ prefixOperator ] postfixExpression | inOutExpression .>
    labeljust = l
    prefixExpressionR0C0 [label = <PD<br/>N prefixExpression<br/>fi ["", "&amp;", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    prefixExpressionR0C1 [label = <OW<br/>ALT <br/>fi ["", "dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["dotOperator", "plainOperator"]<br/>>]
    prefixExpressionR1C1 [label = <PA<br/>OPT <br/>fi ["", "dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixExpressionR2C1 [label = <PB<br/>N postfixExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    prefixExpressionR3C1 [label = <PC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    prefixExpressionR2C1 -> prefixExpressionR3C1 [weight=100000000]
    prefixExpressionR1C1 -> prefixExpressionR2C1 [weight=100000000]
    prefixExpressionR1C2 [label = <OY<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixExpressionR2C2 [label = <OX<br/>N prefixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixExpressionR3C2 [label = <OZ<br/>END <br/>fi [""]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixExpressionR2C2 -> prefixExpressionR3C2 [weight=100000000]
    prefixExpressionR1C2 -> prefixExpressionR2C2 [weight=100000000]
    rank = same {prefixExpressionR1C1 -> prefixExpressionR1C2}
    prefixExpressionR0C1 -> prefixExpressionR1C1 [weight=100000000]
    prefixExpressionR0C3 [label = <PE<br/>ALT <br/>fi ["&amp;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    prefixExpressionR1C3 [label = <PF<br/>N inOutExpression<br/>fi ["&amp;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    prefixExpressionR2C3 [label = <PG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    prefixExpressionR1C3 -> prefixExpressionR2C3 [weight=100000000]
    prefixExpressionR0C3 -> prefixExpressionR1C3 [weight=100000000]
    rank = same {prefixExpressionR0C1 -> prefixExpressionR0C3}
    rank = same {prefixExpressionR0C0 -> prefixExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    prefixExpressionR0C0 -> prefixExpressionR1C0 [weight=100000000]
    rank = same {prefixExpressionR1C0 -> prefixExpressionR1C1}
    prefixExpressionR1C0 -> prefixExpressionR2C0 [weight=100000000]
    rank = same {prefixExpressionR2C0 -> prefixExpressionR2C1}
    prefixExpressionR2C0 -> prefixExpressionR3C0 [weight=100000000]
    rank = same {prefixExpressionR3C0 -> prefixExpressionR3C1}
    prefixExpressionR2C3 -> prefixExpressionR3C3 [weight=100000000]
    rank = same {prefixExpressionR3C2 -> prefixExpressionR3C3}
  }
  subgraph clusterinOutExpression {
    node [shape = box]
    label = <inOutExpression = "&amp;" primaryExpression .>
    labeljust = l
    inOutExpressionR0C0 [label = <PL<br/>N inOutExpression<br/>fi ["&amp;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    inOutExpressionR0C1 [label = <PH<br/>ALT <br/>fi ["&amp;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    inOutExpressionR1C1 [label = <PI<br/>T "&amp;"<br/>fi ["&amp;"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    inOutExpressionR2C1 [label = <PJ<br/>N primaryExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    inOutExpressionR3C1 [label = <PK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    inOutExpressionR2C1 -> inOutExpressionR3C1 [weight=100000000]
    inOutExpressionR1C1 -> inOutExpressionR2C1 [weight=100000000]
    inOutExpressionR0C1 -> inOutExpressionR1C1 [weight=100000000]
    rank = same {inOutExpressionR0C0 -> inOutExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    inOutExpressionR0C0 -> inOutExpressionR1C0 [weight=100000000]
    rank = same {inOutExpressionR1C0 -> inOutExpressionR1C1}
    inOutExpressionR1C0 -> inOutExpressionR2C0 [weight=100000000]
    rank = same {inOutExpressionR2C0 -> inOutExpressionR2C1}
    inOutExpressionR2C0 -> inOutExpressionR3C0 [weight=100000000]
    rank = same {inOutExpressionR3C0 -> inOutExpressionR3C1}
  }
  subgraph clusterconditionalSwitchCase {
    node [shape = box]
    label = <conditionalSwitchCase = switchIfDirectiveClause [ switchElseifDirectiveClauses ] [ switchElseDirectiveClause ] endifDirective .>
    labeljust = l
    conditionalSwitchCaseR0C0 [label = <BFG<br/>N conditionalSwitchCase<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    conditionalSwitchCaseR0C1 [label = <BEU<br/>ALT <br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    conditionalSwitchCaseR1C1 [label = <BEV<br/>N switchIfDirectiveClause<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR2C1 [label = <BEZ<br/>OPT <br/>fi ["", "#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR3C1 [label = <BFD<br/>OPT <br/>fi ["", "#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR4C1 [label = <BFE<br/>N endifDirective<br/>fi ["#endif"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    conditionalSwitchCaseR5C1 [label = <BFF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am []<br/>>]
    conditionalSwitchCaseR4C1 -> conditionalSwitchCaseR5C1 [weight=100000000]
    conditionalSwitchCaseR3C1 -> conditionalSwitchCaseR4C1 [weight=100000000]
    conditionalSwitchCaseR3C2 [label = <BFB<br/>ALT <br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR4C2 [label = <BFA<br/>N switchElseDirectiveClause<br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR5C2 [label = <BFC<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR4C2 -> conditionalSwitchCaseR5C2 [weight=100000000]
    conditionalSwitchCaseR3C2 -> conditionalSwitchCaseR4C2 [weight=100000000]
    rank = same {conditionalSwitchCaseR3C1 -> conditionalSwitchCaseR3C2}
    conditionalSwitchCaseR2C1 -> conditionalSwitchCaseR3C1 [weight=100000000]
    conditionalSwitchCaseR2C3 [label = <BEX<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR3C3 [label = <BEW<br/>N switchElseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR4C3 [label = <BEY<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalSwitchCaseR3C3 -> conditionalSwitchCaseR4C3 [weight=100000000]
    conditionalSwitchCaseR2C3 -> conditionalSwitchCaseR3C3 [weight=100000000]
    rank = same {conditionalSwitchCaseR2C1 -> conditionalSwitchCaseR2C3}
    conditionalSwitchCaseR1C1 -> conditionalSwitchCaseR2C1 [weight=100000000]
    conditionalSwitchCaseR0C1 -> conditionalSwitchCaseR1C1 [weight=100000000]
    rank = same {conditionalSwitchCaseR0C0 -> conditionalSwitchCaseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {conditionalSwitchCaseR0C1 -> conditionalSwitchCaseR0C2}
    rank = same {conditionalSwitchCaseR0C2 -> conditionalSwitchCaseR0C3}
    conditionalSwitchCaseR0C0 -> conditionalSwitchCaseR1C0 [weight=100000000]
    rank = same {conditionalSwitchCaseR1C0 -> conditionalSwitchCaseR1C1}
    conditionalSwitchCaseR0C2 -> conditionalSwitchCaseR1C2 [weight=100000000]
    rank = same {conditionalSwitchCaseR1C1 -> conditionalSwitchCaseR1C2}
    conditionalSwitchCaseR0C3 -> conditionalSwitchCaseR1C3 [weight=100000000]
    rank = same {conditionalSwitchCaseR1C2 -> conditionalSwitchCaseR1C3}
    conditionalSwitchCaseR1C0 -> conditionalSwitchCaseR2C0 [weight=100000000]
    rank = same {conditionalSwitchCaseR2C0 -> conditionalSwitchCaseR2C1}
    conditionalSwitchCaseR1C3 -> conditionalSwitchCaseR2C3 [weight=100000000]
    conditionalSwitchCaseR2C0 -> conditionalSwitchCaseR3C0 [weight=100000000]
    rank = same {conditionalSwitchCaseR3C0 -> conditionalSwitchCaseR3C1}
    conditionalSwitchCaseR3C0 -> conditionalSwitchCaseR4C0 [weight=100000000]
    rank = same {conditionalSwitchCaseR4C0 -> conditionalSwitchCaseR4C1}
    conditionalSwitchCaseR4C0 -> conditionalSwitchCaseR5C0 [weight=100000000]
    rank = same {conditionalSwitchCaseR5C0 -> conditionalSwitchCaseR5C1}
    conditionalSwitchCaseR4C3 -> conditionalSwitchCaseR5C3 [weight=100000000]
    rank = same {conditionalSwitchCaseR5C2 -> conditionalSwitchCaseR5C3}
  }
  subgraph clustertuplePatternElementList {
    node [shape = box]
    label = <tuplePatternElementList = tuplePatternElement | tuplePatternElement "," tuplePatternElementList .>
    labeljust = l
    tuplePatternElementListR0C0 [label = <ELO<br/>N tuplePatternElementList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>>]
    tuplePatternElementListR0C1 [label = <ELG<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR1C1 [label = <ELH<br/>N tuplePatternElement<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR2C1 [label = <ELI<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR1C1 -> tuplePatternElementListR2C1 [weight=100000000]
    tuplePatternElementListR0C1 -> tuplePatternElementListR1C1 [weight=100000000]
    tuplePatternElementListR0C2 [label = <ELJ<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR1C2 [label = <ELK<br/>N tuplePatternElement<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [","]<br/>am []<br/>>]
    tuplePatternElementListR2C2 [label = <ELL<br/>T ","<br/>fi [","]<br/>fo ["(", ")", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    tuplePatternElementListR3C2 [label = <ELM<br/>N tuplePatternElementList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR4C2 [label = <ELN<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tuplePatternElementListR3C2 -> tuplePatternElementListR4C2 [weight=100000000]
    tuplePatternElementListR2C2 -> tuplePatternElementListR3C2 [weight=100000000]
    tuplePatternElementListR1C2 -> tuplePatternElementListR2C2 [weight=100000000]
    tuplePatternElementListR0C2 -> tuplePatternElementListR1C2 [weight=100000000]
    rank = same {tuplePatternElementListR0C1 -> tuplePatternElementListR0C2}
    rank = same {tuplePatternElementListR0C0 -> tuplePatternElementListR0C1}
    node [style = invis]
    edge [style = invis]
    tuplePatternElementListR0C0 -> tuplePatternElementListR1C0 [weight=100000000]
    rank = same {tuplePatternElementListR1C0 -> tuplePatternElementListR1C1}
    tuplePatternElementListR1C0 -> tuplePatternElementListR2C0 [weight=100000000]
    rank = same {tuplePatternElementListR2C0 -> tuplePatternElementListR2C1}
    tuplePatternElementListR2C0 -> tuplePatternElementListR3C0 [weight=100000000]
    tuplePatternElementListR2C1 -> tuplePatternElementListR3C1 [weight=100000000]
    rank = same {tuplePatternElementListR3C0 -> tuplePatternElementListR3C1}
    rank = same {tuplePatternElementListR3C1 -> tuplePatternElementListR3C2}
    tuplePatternElementListR3C0 -> tuplePatternElementListR4C0 [weight=100000000]
    tuplePatternElementListR3C1 -> tuplePatternElementListR4C1 [weight=100000000]
    rank = same {tuplePatternElementListR4C0 -> tuplePatternElementListR4C1}
    rank = same {tuplePatternElementListR4C1 -> tuplePatternElementListR4C2}
  }
  subgraph clusteroptionalType {
    node [shape = box]
    label = <optionalType = type "?" .>
    labeljust = l
    optionalTypeR0C0 [label = <LO<br/>N optionalType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    optionalTypeR0C1 [label = <LK<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    optionalTypeR1C1 [label = <LL<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["?"]<br/>am []<br/>>]
    optionalTypeR2C1 [label = <LM<br/>T "?"<br/>fi ["?"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalTypeR3C1 [label = <LN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    optionalTypeR2C1 -> optionalTypeR3C1 [weight=100000000]
    optionalTypeR1C1 -> optionalTypeR2C1 [weight=100000000]
    optionalTypeR0C1 -> optionalTypeR1C1 [weight=100000000]
    rank = same {optionalTypeR0C0 -> optionalTypeR0C1}
    node [style = invis]
    edge [style = invis]
    optionalTypeR0C0 -> optionalTypeR1C0 [weight=100000000]
    rank = same {optionalTypeR1C0 -> optionalTypeR1C1}
    optionalTypeR1C0 -> optionalTypeR2C0 [weight=100000000]
    rank = same {optionalTypeR2C0 -> optionalTypeR2C1}
    optionalTypeR2C0 -> optionalTypeR3C0 [weight=100000000]
    rank = same {optionalTypeR3C0 -> optionalTypeR3C1}
  }
  subgraph clustersetterName {
    node [shape = box]
    label = <setterName = "(" identifier ")" .>
    labeljust = l
    setterNameR0C0 [label = <CHU<br/>N setterName<br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    setterNameR0C1 [label = <CHP<br/>ALT <br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    setterNameR1C1 [label = <CHQ<br/>T "("<br/>fi ["("]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    setterNameR2C1 [label = <CHR<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    setterNameR3C1 [label = <CHS<br/>T ")"<br/>fi [")"]<br/>fo ["{"]<br/>am []<br/>>]
    setterNameR4C1 [label = <CHT<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    setterNameR3C1 -> setterNameR4C1 [weight=100000000]
    setterNameR2C1 -> setterNameR3C1 [weight=100000000]
    setterNameR1C1 -> setterNameR2C1 [weight=100000000]
    setterNameR0C1 -> setterNameR1C1 [weight=100000000]
    rank = same {setterNameR0C0 -> setterNameR0C1}
    node [style = invis]
    edge [style = invis]
    setterNameR0C0 -> setterNameR1C0 [weight=100000000]
    rank = same {setterNameR1C0 -> setterNameR1C1}
    setterNameR1C0 -> setterNameR2C0 [weight=100000000]
    rank = same {setterNameR2C0 -> setterNameR2C1}
    setterNameR2C0 -> setterNameR3C0 [weight=100000000]
    rank = same {setterNameR3C0 -> setterNameR3C1}
    setterNameR3C0 -> setterNameR4C0 [weight=100000000]
    rank = same {setterNameR4C0 -> setterNameR4C1}
  }
  subgraph clusteroptionalBindingCondition {
    node [shape = box]
    label = <optionalBindingCondition = "let" pattern [ initializer ] | "var" pattern [ initializer ] .>
    labeljust = l
    optionalBindingConditionR0C0 [label = <BAE<br/>N optionalBindingCondition<br/>fi ["let", "var"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR0C1 [label = <AZO<br/>ALT <br/>fi ["let"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR1C1 [label = <AZP<br/>T "let"<br/>fi ["let"]<br/>fo ["(", ",", "=", "_", "else", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var", "{"]<br/>am []<br/>>]
    optionalBindingConditionR2C1 [label = <AZQ<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "=", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR3C1 [label = <AZU<br/>OPT <br/>fi ["", "="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C1 [label = <AZV<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR3C1 -> optionalBindingConditionR4C1 [weight=100000000]
    optionalBindingConditionR3C2 [label = <AZS<br/>ALT <br/>fi ["="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C2 [label = <AZR<br/>N initializer<br/>fi ["="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR5C2 [label = <AZT<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C2 -> optionalBindingConditionR5C2 [weight=100000000]
    optionalBindingConditionR3C2 -> optionalBindingConditionR4C2 [weight=100000000]
    rank = same {optionalBindingConditionR3C1 -> optionalBindingConditionR3C2}
    optionalBindingConditionR2C1 -> optionalBindingConditionR3C1 [weight=100000000]
    optionalBindingConditionR1C1 -> optionalBindingConditionR2C1 [weight=100000000]
    optionalBindingConditionR0C1 -> optionalBindingConditionR1C1 [weight=100000000]
    optionalBindingConditionR0C3 [label = <AZW<br/>ALT <br/>fi ["var"]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR1C3 [label = <AZX<br/>T "var"<br/>fi ["var"]<br/>fo ["(", ",", "=", "_", "else", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var", "{"]<br/>am []<br/>>]
    optionalBindingConditionR2C3 [label = <AZY<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "=", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR3C3 [label = <BAC<br/>OPT <br/>fi ["", "="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C3 [label = <BAD<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR3C3 -> optionalBindingConditionR4C3 [weight=100000000]
    optionalBindingConditionR3C4 [label = <BAA<br/>ALT <br/>fi ["="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C4 [label = <AZZ<br/>N initializer<br/>fi ["="]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR5C4 [label = <BAB<br/>END <br/>fi [""]<br/>fo [",", "else", "{"]<br/>am []<br/>>]
    optionalBindingConditionR4C4 -> optionalBindingConditionR5C4 [weight=100000000]
    optionalBindingConditionR3C4 -> optionalBindingConditionR4C4 [weight=100000000]
    rank = same {optionalBindingConditionR3C3 -> optionalBindingConditionR3C4}
    optionalBindingConditionR2C3 -> optionalBindingConditionR3C3 [weight=100000000]
    optionalBindingConditionR1C3 -> optionalBindingConditionR2C3 [weight=100000000]
    optionalBindingConditionR0C3 -> optionalBindingConditionR1C3 [weight=100000000]
    rank = same {optionalBindingConditionR0C1 -> optionalBindingConditionR0C3}
    rank = same {optionalBindingConditionR0C0 -> optionalBindingConditionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {optionalBindingConditionR0C3 -> optionalBindingConditionR0C4}
    optionalBindingConditionR0C0 -> optionalBindingConditionR1C0 [weight=100000000]
    rank = same {optionalBindingConditionR1C0 -> optionalBindingConditionR1C1}
    rank = same {optionalBindingConditionR1C1 -> optionalBindingConditionR1C2}
    rank = same {optionalBindingConditionR1C2 -> optionalBindingConditionR1C3}
    optionalBindingConditionR0C4 -> optionalBindingConditionR1C4 [weight=100000000]
    rank = same {optionalBindingConditionR1C3 -> optionalBindingConditionR1C4}
    optionalBindingConditionR1C0 -> optionalBindingConditionR2C0 [weight=100000000]
    rank = same {optionalBindingConditionR2C0 -> optionalBindingConditionR2C1}
    optionalBindingConditionR1C2 -> optionalBindingConditionR2C2 [weight=100000000]
    rank = same {optionalBindingConditionR2C1 -> optionalBindingConditionR2C2}
    rank = same {optionalBindingConditionR2C2 -> optionalBindingConditionR2C3}
    optionalBindingConditionR1C4 -> optionalBindingConditionR2C4 [weight=100000000]
    rank = same {optionalBindingConditionR2C3 -> optionalBindingConditionR2C4}
    optionalBindingConditionR2C0 -> optionalBindingConditionR3C0 [weight=100000000]
    rank = same {optionalBindingConditionR3C0 -> optionalBindingConditionR3C1}
    optionalBindingConditionR2C2 -> optionalBindingConditionR3C2 [weight=100000000]
    optionalBindingConditionR2C4 -> optionalBindingConditionR3C4 [weight=100000000]
    optionalBindingConditionR3C0 -> optionalBindingConditionR4C0 [weight=100000000]
    rank = same {optionalBindingConditionR4C0 -> optionalBindingConditionR4C1}
    optionalBindingConditionR4C0 -> optionalBindingConditionR5C0 [weight=100000000]
    optionalBindingConditionR4C1 -> optionalBindingConditionR5C1 [weight=100000000]
    rank = same {optionalBindingConditionR5C0 -> optionalBindingConditionR5C1}
    rank = same {optionalBindingConditionR5C1 -> optionalBindingConditionR5C2}
    optionalBindingConditionR4C3 -> optionalBindingConditionR5C3 [weight=100000000]
    rank = same {optionalBindingConditionR5C2 -> optionalBindingConditionR5C3}
    rank = same {optionalBindingConditionR5C3 -> optionalBindingConditionR5C4}
  }
  subgraph clusterunionStyleEnumMembers {
    node [shape = box]
    label = <unionStyleEnumMembers = unionStyleEnumMember [ unionStyleEnumMembers ] .>
    labeljust = l
    unionStyleEnumMembersR0C0 [label = <CUP<br/>N unionStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR0C1 [label = <CUI<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR1C1 [label = <CUJ<br/>N unionStyleEnumMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    unionStyleEnumMembersR2C1 [label = <CUN<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR3C1 [label = <CUO<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR2C1 -> unionStyleEnumMembersR3C1 [weight=100000000]
    unionStyleEnumMembersR2C2 [label = <CUL<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR3C2 [label = <CUK<br/>N unionStyleEnumMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR4C2 [label = <CUM<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    unionStyleEnumMembersR3C2 -> unionStyleEnumMembersR4C2 [weight=100000000]
    unionStyleEnumMembersR2C2 -> unionStyleEnumMembersR3C2 [weight=100000000]
    rank = same {unionStyleEnumMembersR2C1 -> unionStyleEnumMembersR2C2}
    unionStyleEnumMembersR1C1 -> unionStyleEnumMembersR2C1 [weight=100000000]
    unionStyleEnumMembersR0C1 -> unionStyleEnumMembersR1C1 [weight=100000000]
    rank = same {unionStyleEnumMembersR0C0 -> unionStyleEnumMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {unionStyleEnumMembersR0C1 -> unionStyleEnumMembersR0C2}
    unionStyleEnumMembersR0C0 -> unionStyleEnumMembersR1C0 [weight=100000000]
    rank = same {unionStyleEnumMembersR1C0 -> unionStyleEnumMembersR1C1}
    unionStyleEnumMembersR0C2 -> unionStyleEnumMembersR1C2 [weight=100000000]
    rank = same {unionStyleEnumMembersR1C1 -> unionStyleEnumMembersR1C2}
    unionStyleEnumMembersR1C0 -> unionStyleEnumMembersR2C0 [weight=100000000]
    rank = same {unionStyleEnumMembersR2C0 -> unionStyleEnumMembersR2C1}
    unionStyleEnumMembersR1C2 -> unionStyleEnumMembersR2C2 [weight=100000000]
    unionStyleEnumMembersR2C0 -> unionStyleEnumMembersR3C0 [weight=100000000]
    rank = same {unionStyleEnumMembersR3C0 -> unionStyleEnumMembersR3C1}
    unionStyleEnumMembersR3C0 -> unionStyleEnumMembersR4C0 [weight=100000000]
    unionStyleEnumMembersR3C1 -> unionStyleEnumMembersR4C1 [weight=100000000]
    rank = same {unionStyleEnumMembersR4C0 -> unionStyleEnumMembersR4C1}
    rank = same {unionStyleEnumMembersR4C1 -> unionStyleEnumMembersR4C2}
  }
  subgraph clustermacroExpansionExpression {
    node [shape = box]
    label = <macroExpansionExpression = "#" identifier [ genericArgumentClause ] [ functionCallArgumentClause ] [ trailingClosures ] .>
    labeljust = l
    macroExpansionExpressionR0C0 [label = <AKR<br/>N macroExpansionExpression<br/>fi ["#"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR0C1 [label = <AKB<br/>ALT <br/>fi ["#"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR1C1 [label = <AKC<br/>T "#"<br/>fi ["#"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroExpansionExpressionR2C1 [label = <AKD<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR3C1 [label = <AKH<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR4C1 [label = <AKL<br/>OPT <br/>fi ["", "("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    macroExpansionExpressionR5C1 [label = <AKP<br/>OPT <br/>fi ["", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["{"]<br/>>]
    macroExpansionExpressionR6C1 [label = <AKQ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR5C1 -> macroExpansionExpressionR6C1 [weight=100000000]
    macroExpansionExpressionR5C2 [label = <AKN<br/>ALT <br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR6C2 [label = <AKM<br/>N trailingClosures<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR7C2 [label = <AKO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR6C2 -> macroExpansionExpressionR7C2 [weight=100000000]
    macroExpansionExpressionR5C2 -> macroExpansionExpressionR6C2 [weight=100000000]
    rank = same {macroExpansionExpressionR5C1 -> macroExpansionExpressionR5C2}
    macroExpansionExpressionR4C1 -> macroExpansionExpressionR5C1 [weight=100000000]
    macroExpansionExpressionR4C3 [label = <AKJ<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR5C3 [label = <AKI<br/>N functionCallArgumentClause<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR6C3 [label = <AKK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR5C3 -> macroExpansionExpressionR6C3 [weight=100000000]
    macroExpansionExpressionR4C3 -> macroExpansionExpressionR5C3 [weight=100000000]
    rank = same {macroExpansionExpressionR4C1 -> macroExpansionExpressionR4C3}
    macroExpansionExpressionR3C1 -> macroExpansionExpressionR4C1 [weight=100000000]
    macroExpansionExpressionR3C4 [label = <AKF<br/>ALT <br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR4C4 [label = <AKE<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR5C4 [label = <AKG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    macroExpansionExpressionR4C4 -> macroExpansionExpressionR5C4 [weight=100000000]
    macroExpansionExpressionR3C4 -> macroExpansionExpressionR4C4 [weight=100000000]
    rank = same {macroExpansionExpressionR3C1 -> macroExpansionExpressionR3C4}
    macroExpansionExpressionR2C1 -> macroExpansionExpressionR3C1 [weight=100000000]
    macroExpansionExpressionR1C1 -> macroExpansionExpressionR2C1 [weight=100000000]
    macroExpansionExpressionR0C1 -> macroExpansionExpressionR1C1 [weight=100000000]
    rank = same {macroExpansionExpressionR0C0 -> macroExpansionExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {macroExpansionExpressionR0C1 -> macroExpansionExpressionR0C2}
    rank = same {macroExpansionExpressionR0C2 -> macroExpansionExpressionR0C3}
    rank = same {macroExpansionExpressionR0C3 -> macroExpansionExpressionR0C4}
    macroExpansionExpressionR0C0 -> macroExpansionExpressionR1C0 [weight=100000000]
    rank = same {macroExpansionExpressionR1C0 -> macroExpansionExpressionR1C1}
    macroExpansionExpressionR0C2 -> macroExpansionExpressionR1C2 [weight=100000000]
    rank = same {macroExpansionExpressionR1C1 -> macroExpansionExpressionR1C2}
    macroExpansionExpressionR0C3 -> macroExpansionExpressionR1C3 [weight=100000000]
    rank = same {macroExpansionExpressionR1C2 -> macroExpansionExpressionR1C3}
    macroExpansionExpressionR0C4 -> macroExpansionExpressionR1C4 [weight=100000000]
    rank = same {macroExpansionExpressionR1C3 -> macroExpansionExpressionR1C4}
    macroExpansionExpressionR1C0 -> macroExpansionExpressionR2C0 [weight=100000000]
    rank = same {macroExpansionExpressionR2C0 -> macroExpansionExpressionR2C1}
    macroExpansionExpressionR1C2 -> macroExpansionExpressionR2C2 [weight=100000000]
    rank = same {macroExpansionExpressionR2C1 -> macroExpansionExpressionR2C2}
    macroExpansionExpressionR1C3 -> macroExpansionExpressionR2C3 [weight=100000000]
    rank = same {macroExpansionExpressionR2C2 -> macroExpansionExpressionR2C3}
    macroExpansionExpressionR1C4 -> macroExpansionExpressionR2C4 [weight=100000000]
    rank = same {macroExpansionExpressionR2C3 -> macroExpansionExpressionR2C4}
    macroExpansionExpressionR2C0 -> macroExpansionExpressionR3C0 [weight=100000000]
    rank = same {macroExpansionExpressionR3C0 -> macroExpansionExpressionR3C1}
    macroExpansionExpressionR2C4 -> macroExpansionExpressionR3C4 [weight=100000000]
    macroExpansionExpressionR3C0 -> macroExpansionExpressionR4C0 [weight=100000000]
    rank = same {macroExpansionExpressionR4C0 -> macroExpansionExpressionR4C1}
    macroExpansionExpressionR4C0 -> macroExpansionExpressionR5C0 [weight=100000000]
    rank = same {macroExpansionExpressionR5C0 -> macroExpansionExpressionR5C1}
    macroExpansionExpressionR5C0 -> macroExpansionExpressionR6C0 [weight=100000000]
    rank = same {macroExpansionExpressionR6C0 -> macroExpansionExpressionR6C1}
    macroExpansionExpressionR5C4 -> macroExpansionExpressionR6C4 [weight=100000000]
    rank = same {macroExpansionExpressionR6C3 -> macroExpansionExpressionR6C4}
    macroExpansionExpressionR6C0 -> macroExpansionExpressionR7C0 [weight=100000000]
    macroExpansionExpressionR6C1 -> macroExpansionExpressionR7C1 [weight=100000000]
    rank = same {macroExpansionExpressionR7C0 -> macroExpansionExpressionR7C1}
    rank = same {macroExpansionExpressionR7C1 -> macroExpansionExpressionR7C2}
    macroExpansionExpressionR6C3 -> macroExpansionExpressionR7C3 [weight=100000000]
    rank = same {macroExpansionExpressionR7C2 -> macroExpansionExpressionR7C3}
    macroExpansionExpressionR6C4 -> macroExpansionExpressionR7C4 [weight=100000000]
    rank = same {macroExpansionExpressionR7C3 -> macroExpansionExpressionR7C4}
  }
  subgraph clusterselectorExpression {
    node [shape = box]
    label = <selectorExpression = "#selector" "(" expression ")" | "#selector" "(" "getter:" expression ")" | "#selector" "(" "setter:" expression ")" .>
    labeljust = l
    selectorExpressionR0C0 [label = <AMZ<br/>N selectorExpression<br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["#selector"]<br/>>]
    selectorExpressionR0C1 [label = <AMT<br/>ALT <br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR1C1 [label = <AMU<br/>T "#selector"<br/>fi ["#selector"]<br/>fo ["("]<br/>am []<br/>>]
    selectorExpressionR2C1 [label = <AMV<br/>T "("<br/>fi ["("]<br/>fo [")", "try"]<br/>am []<br/>>]
    selectorExpressionR3C1 [label = <AMW<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    selectorExpressionR4C1 [label = <AMX<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR5C1 [label = <AMY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR4C1 -> selectorExpressionR5C1 [weight=100000000]
    selectorExpressionR3C1 -> selectorExpressionR4C1 [weight=100000000]
    selectorExpressionR2C1 -> selectorExpressionR3C1 [weight=100000000]
    selectorExpressionR1C1 -> selectorExpressionR2C1 [weight=100000000]
    selectorExpressionR0C1 -> selectorExpressionR1C1 [weight=100000000]
    selectorExpressionR0C2 [label = <ANA<br/>ALT <br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR1C2 [label = <ANB<br/>T "#selector"<br/>fi ["#selector"]<br/>fo ["("]<br/>am []<br/>>]
    selectorExpressionR2C2 [label = <ANC<br/>T "("<br/>fi ["("]<br/>fo ["getter:"]<br/>am []<br/>>]
    selectorExpressionR3C2 [label = <AND<br/>T "getter:"<br/>fi ["getter:"]<br/>fo [")", "try"]<br/>am []<br/>>]
    selectorExpressionR4C2 [label = <ANE<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    selectorExpressionR5C2 [label = <ANF<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR6C2 [label = <ANG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR5C2 -> selectorExpressionR6C2 [weight=100000000]
    selectorExpressionR4C2 -> selectorExpressionR5C2 [weight=100000000]
    selectorExpressionR3C2 -> selectorExpressionR4C2 [weight=100000000]
    selectorExpressionR2C2 -> selectorExpressionR3C2 [weight=100000000]
    selectorExpressionR1C2 -> selectorExpressionR2C2 [weight=100000000]
    selectorExpressionR0C2 -> selectorExpressionR1C2 [weight=100000000]
    selectorExpressionR0C3 [label = <ANH<br/>ALT <br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR1C3 [label = <ANI<br/>T "#selector"<br/>fi ["#selector"]<br/>fo ["("]<br/>am []<br/>>]
    selectorExpressionR2C3 [label = <ANJ<br/>T "("<br/>fi ["("]<br/>fo ["setter:"]<br/>am []<br/>>]
    selectorExpressionR3C3 [label = <ANK<br/>T "setter:"<br/>fi ["setter:"]<br/>fo [")", "try"]<br/>am []<br/>>]
    selectorExpressionR4C3 [label = <ANL<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    selectorExpressionR5C3 [label = <ANM<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR6C3 [label = <ANN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selectorExpressionR5C3 -> selectorExpressionR6C3 [weight=100000000]
    selectorExpressionR4C3 -> selectorExpressionR5C3 [weight=100000000]
    selectorExpressionR3C3 -> selectorExpressionR4C3 [weight=100000000]
    selectorExpressionR2C3 -> selectorExpressionR3C3 [weight=100000000]
    selectorExpressionR1C3 -> selectorExpressionR2C3 [weight=100000000]
    selectorExpressionR0C3 -> selectorExpressionR1C3 [weight=100000000]
    rank = same {selectorExpressionR0C2 -> selectorExpressionR0C3}
    rank = same {selectorExpressionR0C1 -> selectorExpressionR0C2}
    rank = same {selectorExpressionR0C0 -> selectorExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    selectorExpressionR0C0 -> selectorExpressionR1C0 [weight=100000000]
    rank = same {selectorExpressionR1C0 -> selectorExpressionR1C1}
    selectorExpressionR1C0 -> selectorExpressionR2C0 [weight=100000000]
    rank = same {selectorExpressionR2C0 -> selectorExpressionR2C1}
    selectorExpressionR2C0 -> selectorExpressionR3C0 [weight=100000000]
    rank = same {selectorExpressionR3C0 -> selectorExpressionR3C1}
    selectorExpressionR3C0 -> selectorExpressionR4C0 [weight=100000000]
    rank = same {selectorExpressionR4C0 -> selectorExpressionR4C1}
    selectorExpressionR4C0 -> selectorExpressionR5C0 [weight=100000000]
    rank = same {selectorExpressionR5C0 -> selectorExpressionR5C1}
    selectorExpressionR5C0 -> selectorExpressionR6C0 [weight=100000000]
    selectorExpressionR5C1 -> selectorExpressionR6C1 [weight=100000000]
    rank = same {selectorExpressionR6C0 -> selectorExpressionR6C1}
    rank = same {selectorExpressionR6C1 -> selectorExpressionR6C2}
  }
  subgraph clustersameTypeRequirement {
    node [shape = box]
    label = <sameTypeRequirement = typeIdentifier "==" type .>
    labeljust = l
    sameTypeRequirementR0C0 [label = <EQA<br/>N sameTypeRequirement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    sameTypeRequirementR0C1 [label = <EPV<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    sameTypeRequirementR1C1 [label = <EPW<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["=="]<br/>am []<br/>>]
    sameTypeRequirementR2C1 [label = <EPX<br/>T "=="<br/>fi ["=="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ",", ";", "@", "Any", "Self", "[", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    sameTypeRequirementR3C1 [label = <EPY<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    sameTypeRequirementR4C1 [label = <EPZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    sameTypeRequirementR3C1 -> sameTypeRequirementR4C1 [weight=100000000]
    sameTypeRequirementR2C1 -> sameTypeRequirementR3C1 [weight=100000000]
    sameTypeRequirementR1C1 -> sameTypeRequirementR2C1 [weight=100000000]
    sameTypeRequirementR0C1 -> sameTypeRequirementR1C1 [weight=100000000]
    rank = same {sameTypeRequirementR0C0 -> sameTypeRequirementR0C1}
    node [style = invis]
    edge [style = invis]
    sameTypeRequirementR0C0 -> sameTypeRequirementR1C0 [weight=100000000]
    rank = same {sameTypeRequirementR1C0 -> sameTypeRequirementR1C1}
    sameTypeRequirementR1C0 -> sameTypeRequirementR2C0 [weight=100000000]
    rank = same {sameTypeRequirementR2C0 -> sameTypeRequirementR2C1}
    sameTypeRequirementR2C0 -> sameTypeRequirementR3C0 [weight=100000000]
    rank = same {sameTypeRequirementR3C0 -> sameTypeRequirementR3C1}
    sameTypeRequirementR3C0 -> sameTypeRequirementR4C0 [weight=100000000]
    rank = same {sameTypeRequirementR4C0 -> sameTypeRequirementR4C1}
  }
  subgraph clusterextensionDeclaration {
    node [shape = box]
    label = <extensionDeclaration = [ attributes ] [ accessLevelModifier ] "extension" typeIdentifier [ typeInheritanceClause ] [ genericWhereClause ] extensionBody .>
    labeljust = l
    extensionDeclarationR0C0 [label = <DQZ<br/>N extensionDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    extensionDeclarationR0C1 [label = <DQE<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    extensionDeclarationR1C1 [label = <DQI<br/>OPT <br/>fi ["", "@"]<br/>fo ["extension", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    extensionDeclarationR2C1 [label = <DQM<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["extension"]<br/>am []<br/>>]
    extensionDeclarationR3C1 [label = <DQN<br/>T "extension"<br/>fi ["extension"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    extensionDeclarationR4C1 [label = <DQO<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    extensionDeclarationR5C1 [label = <DQS<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    extensionDeclarationR6C1 [label = <DQW<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    extensionDeclarationR7C1 [label = <DQX<br/>N extensionBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionDeclarationR8C1 [label = <DQY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    extensionDeclarationR7C1 -> extensionDeclarationR8C1 [weight=100000000]
    extensionDeclarationR6C1 -> extensionDeclarationR7C1 [weight=100000000]
    extensionDeclarationR6C2 [label = <DQU<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    extensionDeclarationR7C2 [label = <DQT<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    extensionDeclarationR8C2 [label = <DQV<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    extensionDeclarationR7C2 -> extensionDeclarationR8C2 [weight=100000000]
    extensionDeclarationR6C2 -> extensionDeclarationR7C2 [weight=100000000]
    rank = same {extensionDeclarationR6C1 -> extensionDeclarationR6C2}
    extensionDeclarationR5C1 -> extensionDeclarationR6C1 [weight=100000000]
    extensionDeclarationR5C3 [label = <DQQ<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    extensionDeclarationR6C3 [label = <DQP<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    extensionDeclarationR7C3 [label = <DQR<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    extensionDeclarationR6C3 -> extensionDeclarationR7C3 [weight=100000000]
    extensionDeclarationR5C3 -> extensionDeclarationR6C3 [weight=100000000]
    rank = same {extensionDeclarationR5C1 -> extensionDeclarationR5C3}
    extensionDeclarationR4C1 -> extensionDeclarationR5C1 [weight=100000000]
    extensionDeclarationR3C1 -> extensionDeclarationR4C1 [weight=100000000]
    extensionDeclarationR2C1 -> extensionDeclarationR3C1 [weight=100000000]
    extensionDeclarationR2C4 [label = <DQK<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["extension"]<br/>am []<br/>>]
    extensionDeclarationR3C4 [label = <DQJ<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["extension"]<br/>am []<br/>>]
    extensionDeclarationR4C4 [label = <DQL<br/>END <br/>fi [""]<br/>fo ["extension"]<br/>am []<br/>>]
    extensionDeclarationR3C4 -> extensionDeclarationR4C4 [weight=100000000]
    extensionDeclarationR2C4 -> extensionDeclarationR3C4 [weight=100000000]
    rank = same {extensionDeclarationR2C1 -> extensionDeclarationR2C4}
    extensionDeclarationR1C1 -> extensionDeclarationR2C1 [weight=100000000]
    extensionDeclarationR1C5 [label = <DQG<br/>ALT <br/>fi ["@"]<br/>fo ["extension", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    extensionDeclarationR2C5 [label = <DQF<br/>N attributes<br/>fi ["@"]<br/>fo ["extension", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    extensionDeclarationR3C5 [label = <DQH<br/>END <br/>fi [""]<br/>fo ["extension", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    extensionDeclarationR2C5 -> extensionDeclarationR3C5 [weight=100000000]
    extensionDeclarationR1C5 -> extensionDeclarationR2C5 [weight=100000000]
    rank = same {extensionDeclarationR1C1 -> extensionDeclarationR1C5}
    extensionDeclarationR0C1 -> extensionDeclarationR1C1 [weight=100000000]
    rank = same {extensionDeclarationR0C0 -> extensionDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {extensionDeclarationR0C1 -> extensionDeclarationR0C2}
    rank = same {extensionDeclarationR0C2 -> extensionDeclarationR0C3}
    rank = same {extensionDeclarationR0C3 -> extensionDeclarationR0C4}
    rank = same {extensionDeclarationR0C4 -> extensionDeclarationR0C5}
    extensionDeclarationR0C0 -> extensionDeclarationR1C0 [weight=100000000]
    rank = same {extensionDeclarationR1C0 -> extensionDeclarationR1C1}
    extensionDeclarationR0C5 -> extensionDeclarationR1C5 [weight=100000000]
    extensionDeclarationR1C0 -> extensionDeclarationR2C0 [weight=100000000]
    rank = same {extensionDeclarationR2C0 -> extensionDeclarationR2C1}
    extensionDeclarationR2C0 -> extensionDeclarationR3C0 [weight=100000000]
    rank = same {extensionDeclarationR3C0 -> extensionDeclarationR3C1}
    rank = same {extensionDeclarationR3C1 -> extensionDeclarationR3C2}
    rank = same {extensionDeclarationR3C2 -> extensionDeclarationR3C3}
    rank = same {extensionDeclarationR3C3 -> extensionDeclarationR3C4}
    extensionDeclarationR3C0 -> extensionDeclarationR4C0 [weight=100000000]
    rank = same {extensionDeclarationR4C0 -> extensionDeclarationR4C1}
    extensionDeclarationR3C2 -> extensionDeclarationR4C2 [weight=100000000]
    rank = same {extensionDeclarationR4C1 -> extensionDeclarationR4C2}
    extensionDeclarationR3C3 -> extensionDeclarationR4C3 [weight=100000000]
    rank = same {extensionDeclarationR4C2 -> extensionDeclarationR4C3}
    rank = same {extensionDeclarationR4C3 -> extensionDeclarationR4C4}
    extensionDeclarationR3C5 -> extensionDeclarationR4C5 [weight=100000000]
    rank = same {extensionDeclarationR4C4 -> extensionDeclarationR4C5}
    extensionDeclarationR4C0 -> extensionDeclarationR5C0 [weight=100000000]
    rank = same {extensionDeclarationR5C0 -> extensionDeclarationR5C1}
    extensionDeclarationR4C3 -> extensionDeclarationR5C3 [weight=100000000]
    extensionDeclarationR4C4 -> extensionDeclarationR5C4 [weight=100000000]
    rank = same {extensionDeclarationR5C3 -> extensionDeclarationR5C4}
    extensionDeclarationR4C5 -> extensionDeclarationR5C5 [weight=100000000]
    rank = same {extensionDeclarationR5C4 -> extensionDeclarationR5C5}
    extensionDeclarationR5C0 -> extensionDeclarationR6C0 [weight=100000000]
    rank = same {extensionDeclarationR6C0 -> extensionDeclarationR6C1}
    extensionDeclarationR5C4 -> extensionDeclarationR6C4 [weight=100000000]
    rank = same {extensionDeclarationR6C3 -> extensionDeclarationR6C4}
    extensionDeclarationR5C5 -> extensionDeclarationR6C5 [weight=100000000]
    rank = same {extensionDeclarationR6C4 -> extensionDeclarationR6C5}
    extensionDeclarationR6C0 -> extensionDeclarationR7C0 [weight=100000000]
    rank = same {extensionDeclarationR7C0 -> extensionDeclarationR7C1}
    extensionDeclarationR6C4 -> extensionDeclarationR7C4 [weight=100000000]
    rank = same {extensionDeclarationR7C3 -> extensionDeclarationR7C4}
    extensionDeclarationR6C5 -> extensionDeclarationR7C5 [weight=100000000]
    rank = same {extensionDeclarationR7C4 -> extensionDeclarationR7C5}
    extensionDeclarationR7C0 -> extensionDeclarationR8C0 [weight=100000000]
    rank = same {extensionDeclarationR8C0 -> extensionDeclarationR8C1}
    extensionDeclarationR7C3 -> extensionDeclarationR8C3 [weight=100000000]
    rank = same {extensionDeclarationR8C2 -> extensionDeclarationR8C3}
    extensionDeclarationR7C4 -> extensionDeclarationR8C4 [weight=100000000]
    rank = same {extensionDeclarationR8C3 -> extensionDeclarationR8C4}
    extensionDeclarationR7C5 -> extensionDeclarationR8C5 [weight=100000000]
    rank = same {extensionDeclarationR8C4 -> extensionDeclarationR8C5}
  }
  subgraph clusterwillSetDidSetBlock {
    node [shape = box]
    label = <willSetDidSetBlock = "{" willSetClause [ didSetClause ] "}" | "{" didSetClause [ willSetClause ] "}" .>
    labeljust = l
    willSetDidSetBlockR0C0 [label = <CJS<br/>N willSetDidSetBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["{"]<br/>>]
    willSetDidSetBlockR0C1 [label = <CJJ<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR1C1 [label = <CJK<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR2C1 [label = <CJL<br/>N willSetClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    willSetDidSetBlockR3C1 [label = <CJP<br/>OPT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C1 [label = <CJQ<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR5C1 [label = <CJR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C1 -> willSetDidSetBlockR5C1 [weight=100000000]
    willSetDidSetBlockR3C1 -> willSetDidSetBlockR4C1 [weight=100000000]
    willSetDidSetBlockR3C2 [label = <CJN<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C2 [label = <CJM<br/>N didSetClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR5C2 [label = <CJO<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C2 -> willSetDidSetBlockR5C2 [weight=100000000]
    willSetDidSetBlockR3C2 -> willSetDidSetBlockR4C2 [weight=100000000]
    rank = same {willSetDidSetBlockR3C1 -> willSetDidSetBlockR3C2}
    willSetDidSetBlockR2C1 -> willSetDidSetBlockR3C1 [weight=100000000]
    willSetDidSetBlockR1C1 -> willSetDidSetBlockR2C1 [weight=100000000]
    willSetDidSetBlockR0C1 -> willSetDidSetBlockR1C1 [weight=100000000]
    willSetDidSetBlockR0C3 [label = <CJT<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR1C3 [label = <CJU<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR2C3 [label = <CJV<br/>N didSetClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    willSetDidSetBlockR3C3 [label = <CJZ<br/>OPT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C3 [label = <CKA<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR5C3 [label = <CKB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C3 -> willSetDidSetBlockR5C3 [weight=100000000]
    willSetDidSetBlockR3C3 -> willSetDidSetBlockR4C3 [weight=100000000]
    willSetDidSetBlockR3C4 [label = <CJX<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C4 [label = <CJW<br/>N willSetClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR5C4 [label = <CJY<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    willSetDidSetBlockR4C4 -> willSetDidSetBlockR5C4 [weight=100000000]
    willSetDidSetBlockR3C4 -> willSetDidSetBlockR4C4 [weight=100000000]
    rank = same {willSetDidSetBlockR3C3 -> willSetDidSetBlockR3C4}
    willSetDidSetBlockR2C3 -> willSetDidSetBlockR3C3 [weight=100000000]
    willSetDidSetBlockR1C3 -> willSetDidSetBlockR2C3 [weight=100000000]
    willSetDidSetBlockR0C3 -> willSetDidSetBlockR1C3 [weight=100000000]
    rank = same {willSetDidSetBlockR0C1 -> willSetDidSetBlockR0C3}
    rank = same {willSetDidSetBlockR0C0 -> willSetDidSetBlockR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {willSetDidSetBlockR0C3 -> willSetDidSetBlockR0C4}
    willSetDidSetBlockR0C0 -> willSetDidSetBlockR1C0 [weight=100000000]
    rank = same {willSetDidSetBlockR1C0 -> willSetDidSetBlockR1C1}
    rank = same {willSetDidSetBlockR1C1 -> willSetDidSetBlockR1C2}
    rank = same {willSetDidSetBlockR1C2 -> willSetDidSetBlockR1C3}
    willSetDidSetBlockR0C4 -> willSetDidSetBlockR1C4 [weight=100000000]
    rank = same {willSetDidSetBlockR1C3 -> willSetDidSetBlockR1C4}
    willSetDidSetBlockR1C0 -> willSetDidSetBlockR2C0 [weight=100000000]
    rank = same {willSetDidSetBlockR2C0 -> willSetDidSetBlockR2C1}
    willSetDidSetBlockR1C2 -> willSetDidSetBlockR2C2 [weight=100000000]
    rank = same {willSetDidSetBlockR2C1 -> willSetDidSetBlockR2C2}
    rank = same {willSetDidSetBlockR2C2 -> willSetDidSetBlockR2C3}
    willSetDidSetBlockR1C4 -> willSetDidSetBlockR2C4 [weight=100000000]
    rank = same {willSetDidSetBlockR2C3 -> willSetDidSetBlockR2C4}
    willSetDidSetBlockR2C0 -> willSetDidSetBlockR3C0 [weight=100000000]
    rank = same {willSetDidSetBlockR3C0 -> willSetDidSetBlockR3C1}
    willSetDidSetBlockR2C2 -> willSetDidSetBlockR3C2 [weight=100000000]
    willSetDidSetBlockR2C4 -> willSetDidSetBlockR3C4 [weight=100000000]
    willSetDidSetBlockR3C0 -> willSetDidSetBlockR4C0 [weight=100000000]
    rank = same {willSetDidSetBlockR4C0 -> willSetDidSetBlockR4C1}
    willSetDidSetBlockR4C0 -> willSetDidSetBlockR5C0 [weight=100000000]
    rank = same {willSetDidSetBlockR5C0 -> willSetDidSetBlockR5C1}
  }
  subgraph clustergenericWhereClause {
    node [shape = box]
    label = <genericWhereClause = "where" requirementList .>
    labeljust = l
    genericWhereClauseR0C0 [label = <EOT<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    genericWhereClauseR0C1 [label = <EOP<br/>ALT <br/>fi ["where"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    genericWhereClauseR1C1 [label = <EOQ<br/>T "where"<br/>fi ["where"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    genericWhereClauseR2C1 [label = <EOR<br/>N requirementList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    genericWhereClauseR3C1 [label = <EOS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "{", "}"]<br/>am []<br/>>]
    genericWhereClauseR2C1 -> genericWhereClauseR3C1 [weight=100000000]
    genericWhereClauseR1C1 -> genericWhereClauseR2C1 [weight=100000000]
    genericWhereClauseR0C1 -> genericWhereClauseR1C1 [weight=100000000]
    rank = same {genericWhereClauseR0C0 -> genericWhereClauseR0C1}
    node [style = invis]
    edge [style = invis]
    genericWhereClauseR0C0 -> genericWhereClauseR1C0 [weight=100000000]
    rank = same {genericWhereClauseR1C0 -> genericWhereClauseR1C1}
    genericWhereClauseR1C0 -> genericWhereClauseR2C0 [weight=100000000]
    rank = same {genericWhereClauseR2C0 -> genericWhereClauseR2C1}
    genericWhereClauseR2C0 -> genericWhereClauseR3C0 [weight=100000000]
    rank = same {genericWhereClauseR3C0 -> genericWhereClauseR3C1}
  }
  subgraph clusterpostfixOperatorDeclaration {
    node [shape = box]
    label = <postfixOperatorDeclaration = "postfix" "operator" Operator .>
    labeljust = l
    postfixOperatorDeclarationR0C0 [label = <DWO<br/>N postfixOperatorDeclaration<br/>fi ["postfix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    postfixOperatorDeclarationR0C1 [label = <DWJ<br/>ALT <br/>fi ["postfix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    postfixOperatorDeclarationR1C1 [label = <DWK<br/>T "postfix"<br/>fi ["postfix"]<br/>fo ["operator"]<br/>am []<br/>>]
    postfixOperatorDeclarationR2C1 [label = <DWL<br/>T "operator"<br/>fi ["operator"]<br/>fo ["dotOperator", "plainOperator"]<br/>am []<br/>>]
    postfixOperatorDeclarationR3C1 [label = <DWM<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    postfixOperatorDeclarationR4C1 [label = <DWN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    postfixOperatorDeclarationR3C1 -> postfixOperatorDeclarationR4C1 [weight=100000000]
    postfixOperatorDeclarationR2C1 -> postfixOperatorDeclarationR3C1 [weight=100000000]
    postfixOperatorDeclarationR1C1 -> postfixOperatorDeclarationR2C1 [weight=100000000]
    postfixOperatorDeclarationR0C1 -> postfixOperatorDeclarationR1C1 [weight=100000000]
    rank = same {postfixOperatorDeclarationR0C0 -> postfixOperatorDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    postfixOperatorDeclarationR0C0 -> postfixOperatorDeclarationR1C0 [weight=100000000]
    rank = same {postfixOperatorDeclarationR1C0 -> postfixOperatorDeclarationR1C1}
    postfixOperatorDeclarationR1C0 -> postfixOperatorDeclarationR2C0 [weight=100000000]
    rank = same {postfixOperatorDeclarationR2C0 -> postfixOperatorDeclarationR2C1}
    postfixOperatorDeclarationR2C0 -> postfixOperatorDeclarationR3C0 [weight=100000000]
    rank = same {postfixOperatorDeclarationR3C0 -> postfixOperatorDeclarationR3C1}
    postfixOperatorDeclarationR3C0 -> postfixOperatorDeclarationR4C0 [weight=100000000]
    rank = same {postfixOperatorDeclarationR4C0 -> postfixOperatorDeclarationR4C1}
  }
  subgraph clusterimportKind {
    node [shape = box]
    label = <importKind = "typealias" | "struct" | "class" | "enum" | "protocol" | "let" | "var" | "func" .>
    labeljust = l
    importKindR0C0 [label = <CBW<br/>N importKind<br/>fi ["class", "enum", "func", "let", "protocol", "struct", "typealias", "var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR0C1 [label = <CAY<br/>ALT <br/>fi ["typealias"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C1 [label = <CAZ<br/>T "typealias"<br/>fi ["typealias"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C1 [label = <CBA<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C1 -> importKindR2C1 [weight=100000000]
    importKindR0C1 -> importKindR1C1 [weight=100000000]
    importKindR0C2 [label = <CBB<br/>ALT <br/>fi ["struct"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C2 [label = <CBC<br/>T "struct"<br/>fi ["struct"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C2 [label = <CBD<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C2 -> importKindR2C2 [weight=100000000]
    importKindR0C2 -> importKindR1C2 [weight=100000000]
    importKindR0C3 [label = <CBE<br/>ALT <br/>fi ["class"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C3 [label = <CBF<br/>T "class"<br/>fi ["class"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C3 [label = <CBG<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C3 -> importKindR2C3 [weight=100000000]
    importKindR0C3 -> importKindR1C3 [weight=100000000]
    importKindR0C4 [label = <CBH<br/>ALT <br/>fi ["enum"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C4 [label = <CBI<br/>T "enum"<br/>fi ["enum"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C4 [label = <CBJ<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C4 -> importKindR2C4 [weight=100000000]
    importKindR0C4 -> importKindR1C4 [weight=100000000]
    importKindR0C5 [label = <CBK<br/>ALT <br/>fi ["protocol"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C5 [label = <CBL<br/>T "protocol"<br/>fi ["protocol"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C5 [label = <CBM<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C5 -> importKindR2C5 [weight=100000000]
    importKindR0C5 -> importKindR1C5 [weight=100000000]
    importKindR0C6 [label = <CBN<br/>ALT <br/>fi ["let"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C6 [label = <CBO<br/>T "let"<br/>fi ["let"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C6 [label = <CBP<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C6 -> importKindR2C6 [weight=100000000]
    importKindR0C6 -> importKindR1C6 [weight=100000000]
    importKindR0C7 [label = <CBQ<br/>ALT <br/>fi ["var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C7 [label = <CBR<br/>T "var"<br/>fi ["var"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C7 [label = <CBS<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C7 -> importKindR2C7 [weight=100000000]
    importKindR0C7 -> importKindR1C7 [weight=100000000]
    importKindR0C8 [label = <CBT<br/>ALT <br/>fi ["func"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C8 [label = <CBU<br/>T "func"<br/>fi ["func"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR2C8 [label = <CBV<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importKindR1C8 -> importKindR2C8 [weight=100000000]
    importKindR0C8 -> importKindR1C8 [weight=100000000]
    rank = same {importKindR0C7 -> importKindR0C8}
    rank = same {importKindR0C6 -> importKindR0C7}
    rank = same {importKindR0C5 -> importKindR0C6}
    rank = same {importKindR0C4 -> importKindR0C5}
    rank = same {importKindR0C3 -> importKindR0C4}
    rank = same {importKindR0C2 -> importKindR0C3}
    rank = same {importKindR0C1 -> importKindR0C2}
    rank = same {importKindR0C0 -> importKindR0C1}
    node [style = invis]
    edge [style = invis]
    importKindR0C0 -> importKindR1C0 [weight=100000000]
    rank = same {importKindR1C0 -> importKindR1C1}
    importKindR1C0 -> importKindR2C0 [weight=100000000]
    rank = same {importKindR2C0 -> importKindR2C1}
  }
  subgraph clusterfilePath {
    node [shape = box]
    label = <filePath = "staticStringLiteral" .>
    labeljust = l
    filePathR0C0 [label = <BUM<br/>N filePath<br/>fi ["staticStringLiteral"]<br/>fo [","]<br/>am []<br/>>]
    filePathR0C1 [label = <BUJ<br/>ALT <br/>fi ["staticStringLiteral"]<br/>fo [","]<br/>am []<br/>>]
    filePathR1C1 [label = <BUK<br/>T "staticStringLiteral"<br/>fi ["staticStringLiteral"]<br/>fo [","]<br/>am []<br/>>]
    filePathR2C1 [label = <BUL<br/>END <br/>fi [""]<br/>fo [","]<br/>am []<br/>>]
    filePathR1C1 -> filePathR2C1 [weight=100000000]
    filePathR0C1 -> filePathR1C1 [weight=100000000]
    rank = same {filePathR0C0 -> filePathR0C1}
    node [style = invis]
    edge [style = invis]
    filePathR0C0 -> filePathR1C0 [weight=100000000]
    rank = same {filePathR1C0 -> filePathR1C1}
    filePathR1C0 -> filePathR2C0 [weight=100000000]
    rank = same {filePathR2C0 -> filePathR2C1}
  }
  subgraph clusterargumentName {
    node [shape = box]
    label = <argumentName = identifier ":" .>
    labeljust = l
    argumentNameR0C0 [label = <ATS<br/>N argumentName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    argumentNameR0C1 [label = <ATO<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    argumentNameR1C1 [label = <ATP<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    argumentNameR2C1 [label = <ATQ<br/>T ":"<br/>fi [":"]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    argumentNameR3C1 [label = <ATR<br/>END <br/>fi [""]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    argumentNameR2C1 -> argumentNameR3C1 [weight=100000000]
    argumentNameR1C1 -> argumentNameR2C1 [weight=100000000]
    argumentNameR0C1 -> argumentNameR1C1 [weight=100000000]
    rank = same {argumentNameR0C0 -> argumentNameR0C1}
    node [style = invis]
    edge [style = invis]
    argumentNameR0C0 -> argumentNameR1C0 [weight=100000000]
    rank = same {argumentNameR1C0 -> argumentNameR1C1}
    argumentNameR1C0 -> argumentNameR2C0 [weight=100000000]
    rank = same {argumentNameR2C0 -> argumentNameR2C1}
    argumentNameR2C0 -> argumentNameR3C0 [weight=100000000]
    rank = same {argumentNameR3C0 -> argumentNameR3C1}
  }
  subgraph clustercaseItemList {
    node [shape = box]
    label = <caseItemList = pattern [ whereClause ] | pattern [ whereClause ] "," caseItemList .>
    labeljust = l
    caseItemListR0C0 [label = <BEB<br/>N caseItemList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":"]<br/>am ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>>]
    caseItemListR0C1 [label = <BDL<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR1C1 [label = <BDM<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":", "where"]<br/>am []<br/>>]
    caseItemListR2C1 [label = <BDQ<br/>OPT <br/>fi ["", "where"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR3C1 [label = <BDR<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR2C1 -> caseItemListR3C1 [weight=100000000]
    caseItemListR2C2 [label = <BDO<br/>ALT <br/>fi ["where"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR3C2 [label = <BDN<br/>N whereClause<br/>fi ["where"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR4C2 [label = <BDP<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR3C2 -> caseItemListR4C2 [weight=100000000]
    caseItemListR2C2 -> caseItemListR3C2 [weight=100000000]
    rank = same {caseItemListR2C1 -> caseItemListR2C2}
    caseItemListR1C1 -> caseItemListR2C1 [weight=100000000]
    caseItemListR0C1 -> caseItemListR1C1 [weight=100000000]
    caseItemListR0C3 [label = <BDS<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR1C3 [label = <BDT<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [",", "where"]<br/>am []<br/>>]
    caseItemListR2C3 [label = <BDX<br/>OPT <br/>fi ["", "where"]<br/>fo [","]<br/>am []<br/>>]
    caseItemListR3C3 [label = <BDY<br/>T ","<br/>fi [","]<br/>fo ["(", ":", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>am []<br/>>]
    caseItemListR4C3 [label = <BDZ<br/>N caseItemList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR5C3 [label = <BEA<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    caseItemListR4C3 -> caseItemListR5C3 [weight=100000000]
    caseItemListR3C3 -> caseItemListR4C3 [weight=100000000]
    caseItemListR2C3 -> caseItemListR3C3 [weight=100000000]
    caseItemListR2C4 [label = <BDV<br/>ALT <br/>fi ["where"]<br/>fo [","]<br/>am []<br/>>]
    caseItemListR3C4 [label = <BDU<br/>N whereClause<br/>fi ["where"]<br/>fo [","]<br/>am []<br/>>]
    caseItemListR4C4 [label = <BDW<br/>END <br/>fi [""]<br/>fo [","]<br/>am []<br/>>]
    caseItemListR3C4 -> caseItemListR4C4 [weight=100000000]
    caseItemListR2C4 -> caseItemListR3C4 [weight=100000000]
    rank = same {caseItemListR2C3 -> caseItemListR2C4}
    caseItemListR1C3 -> caseItemListR2C3 [weight=100000000]
    caseItemListR0C3 -> caseItemListR1C3 [weight=100000000]
    rank = same {caseItemListR0C1 -> caseItemListR0C3}
    rank = same {caseItemListR0C0 -> caseItemListR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {caseItemListR0C3 -> caseItemListR0C4}
    caseItemListR0C0 -> caseItemListR1C0 [weight=100000000]
    rank = same {caseItemListR1C0 -> caseItemListR1C1}
    rank = same {caseItemListR1C1 -> caseItemListR1C2}
    rank = same {caseItemListR1C2 -> caseItemListR1C3}
    caseItemListR0C4 -> caseItemListR1C4 [weight=100000000]
    rank = same {caseItemListR1C3 -> caseItemListR1C4}
    caseItemListR1C0 -> caseItemListR2C0 [weight=100000000]
    rank = same {caseItemListR2C0 -> caseItemListR2C1}
    caseItemListR1C2 -> caseItemListR2C2 [weight=100000000]
    caseItemListR1C4 -> caseItemListR2C4 [weight=100000000]
    caseItemListR2C0 -> caseItemListR3C0 [weight=100000000]
    rank = same {caseItemListR3C0 -> caseItemListR3C1}
    caseItemListR3C0 -> caseItemListR4C0 [weight=100000000]
    caseItemListR3C1 -> caseItemListR4C1 [weight=100000000]
    rank = same {caseItemListR4C0 -> caseItemListR4C1}
    rank = same {caseItemListR4C1 -> caseItemListR4C2}
    caseItemListR4C0 -> caseItemListR5C0 [weight=100000000]
    caseItemListR4C1 -> caseItemListR5C1 [weight=100000000]
    rank = same {caseItemListR5C0 -> caseItemListR5C1}
    caseItemListR4C2 -> caseItemListR5C2 [weight=100000000]
    rank = same {caseItemListR5C1 -> caseItemListR5C2}
    rank = same {caseItemListR5C2 -> caseItemListR5C3}
    caseItemListR4C4 -> caseItemListR5C4 [weight=100000000]
    rank = same {caseItemListR5C3 -> caseItemListR5C4}
  }
  subgraph clustertupleElementList {
    node [shape = box]
    label = <tupleElementList = tupleElement | tupleElement "," tupleElementList .>
    labeljust = l
    tupleElementListR0C0 [label = <AJN<br/>N tupleElementList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    tupleElementListR0C1 [label = <AJF<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR1C1 [label = <AJG<br/>N tupleElement<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR2C1 [label = <AJH<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR1C1 -> tupleElementListR2C1 [weight=100000000]
    tupleElementListR0C1 -> tupleElementListR1C1 [weight=100000000]
    tupleElementListR0C2 [label = <AJI<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR1C2 [label = <AJJ<br/>N tupleElement<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [","]<br/>am []<br/>>]
    tupleElementListR2C2 [label = <AJK<br/>T ","<br/>fi [","]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    tupleElementListR3C2 [label = <AJL<br/>N tupleElementList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR4C2 [label = <AJM<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    tupleElementListR3C2 -> tupleElementListR4C2 [weight=100000000]
    tupleElementListR2C2 -> tupleElementListR3C2 [weight=100000000]
    tupleElementListR1C2 -> tupleElementListR2C2 [weight=100000000]
    tupleElementListR0C2 -> tupleElementListR1C2 [weight=100000000]
    rank = same {tupleElementListR0C1 -> tupleElementListR0C2}
    rank = same {tupleElementListR0C0 -> tupleElementListR0C1}
    node [style = invis]
    edge [style = invis]
    tupleElementListR0C0 -> tupleElementListR1C0 [weight=100000000]
    rank = same {tupleElementListR1C0 -> tupleElementListR1C1}
    tupleElementListR1C0 -> tupleElementListR2C0 [weight=100000000]
    rank = same {tupleElementListR2C0 -> tupleElementListR2C1}
    tupleElementListR2C0 -> tupleElementListR3C0 [weight=100000000]
    tupleElementListR2C1 -> tupleElementListR3C1 [weight=100000000]
    rank = same {tupleElementListR3C0 -> tupleElementListR3C1}
    rank = same {tupleElementListR3C1 -> tupleElementListR3C2}
    tupleElementListR3C0 -> tupleElementListR4C0 [weight=100000000]
    tupleElementListR3C1 -> tupleElementListR4C1 [weight=100000000]
    rank = same {tupleElementListR4C0 -> tupleElementListR4C1}
    rank = same {tupleElementListR4C1 -> tupleElementListR4C2}
  }
  subgraph clusterconstantDeclaration {
    node [shape = box]
    label = <constantDeclaration = [ attributes ] [ declarationModifiers ] "let" patternInitializerList .>
    labeljust = l
    constantDeclarationR0C0 [label = <CCS<br/>N constantDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    constantDeclarationR0C1 [label = <CCG<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    constantDeclarationR1C1 [label = <CCK<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "let", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    constantDeclarationR2C1 [label = <CCO<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["let"]<br/>am []<br/>>]
    constantDeclarationR3C1 [label = <CCP<br/>T "let"<br/>fi ["let"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am []<br/>>]
    constantDeclarationR4C1 [label = <CCQ<br/>N patternInitializerList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    constantDeclarationR5C1 [label = <CCR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    constantDeclarationR4C1 -> constantDeclarationR5C1 [weight=100000000]
    constantDeclarationR3C1 -> constantDeclarationR4C1 [weight=100000000]
    constantDeclarationR2C1 -> constantDeclarationR3C1 [weight=100000000]
    constantDeclarationR2C2 [label = <CCM<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["let"]<br/>am []<br/>>]
    constantDeclarationR3C2 [label = <CCL<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["let"]<br/>am []<br/>>]
    constantDeclarationR4C2 [label = <CCN<br/>END <br/>fi [""]<br/>fo ["let"]<br/>am []<br/>>]
    constantDeclarationR3C2 -> constantDeclarationR4C2 [weight=100000000]
    constantDeclarationR2C2 -> constantDeclarationR3C2 [weight=100000000]
    rank = same {constantDeclarationR2C1 -> constantDeclarationR2C2}
    constantDeclarationR1C1 -> constantDeclarationR2C1 [weight=100000000]
    constantDeclarationR1C3 [label = <CCI<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "let", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    constantDeclarationR2C3 [label = <CCH<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "let", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    constantDeclarationR3C3 [label = <CCJ<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "let", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    constantDeclarationR2C3 -> constantDeclarationR3C3 [weight=100000000]
    constantDeclarationR1C3 -> constantDeclarationR2C3 [weight=100000000]
    rank = same {constantDeclarationR1C1 -> constantDeclarationR1C3}
    constantDeclarationR0C1 -> constantDeclarationR1C1 [weight=100000000]
    rank = same {constantDeclarationR0C0 -> constantDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {constantDeclarationR0C1 -> constantDeclarationR0C2}
    rank = same {constantDeclarationR0C2 -> constantDeclarationR0C3}
    constantDeclarationR0C0 -> constantDeclarationR1C0 [weight=100000000]
    rank = same {constantDeclarationR1C0 -> constantDeclarationR1C1}
    constantDeclarationR0C3 -> constantDeclarationR1C3 [weight=100000000]
    constantDeclarationR1C0 -> constantDeclarationR2C0 [weight=100000000]
    rank = same {constantDeclarationR2C0 -> constantDeclarationR2C1}
    constantDeclarationR2C0 -> constantDeclarationR3C0 [weight=100000000]
    rank = same {constantDeclarationR3C0 -> constantDeclarationR3C1}
    constantDeclarationR3C0 -> constantDeclarationR4C0 [weight=100000000]
    rank = same {constantDeclarationR4C0 -> constantDeclarationR4C1}
    constantDeclarationR3C3 -> constantDeclarationR4C3 [weight=100000000]
    rank = same {constantDeclarationR4C2 -> constantDeclarationR4C3}
    constantDeclarationR4C0 -> constantDeclarationR5C0 [weight=100000000]
    rank = same {constantDeclarationR5C0 -> constantDeclarationR5C1}
    constantDeclarationR4C2 -> constantDeclarationR5C2 [weight=100000000]
    rank = same {constantDeclarationR5C1 -> constantDeclarationR5C2}
    constantDeclarationR4C3 -> constantDeclarationR5C3 [weight=100000000]
    rank = same {constantDeclarationR5C2 -> constantDeclarationR5C3}
  }
  subgraph clusterprimaryExpression {
    node [shape = box]
    label = <primaryExpression = identifier [ genericArgumentClause ] | literalExpression | selfExpression | superclassExpression | conditionalExpression | closureExpression | parenthesizedExpression | tupleExpression | implicitMemberExpression | wildcardExpression | macroExpansionExpression | keyPathExpression | selectorExpression | keyPathStringExpression .>
    labeljust = l
    primaryExpressionR0C0 [label = <TA<br/>N primaryExpression<br/>fi ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    primaryExpressionR0C1 [label = <ST<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C1 [label = <SU<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "&lt;", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C1 [label = <SY<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR3C1 [label = <SZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C1 -> primaryExpressionR3C1 [weight=100000000]
    primaryExpressionR2C2 [label = <SW<br/>ALT <br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR3C2 [label = <SV<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR4C2 [label = <SX<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR3C2 -> primaryExpressionR4C2 [weight=100000000]
    primaryExpressionR2C2 -> primaryExpressionR3C2 [weight=100000000]
    rank = same {primaryExpressionR2C1 -> primaryExpressionR2C2}
    primaryExpressionR1C1 -> primaryExpressionR2C1 [weight=100000000]
    primaryExpressionR0C1 -> primaryExpressionR1C1 [weight=100000000]
    primaryExpressionR0C3 [label = <TB<br/>ALT <br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral", "[", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C3 [label = <TC<br/>N literalExpression<br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral", "[", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C3 [label = <TD<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C3 -> primaryExpressionR2C3 [weight=100000000]
    primaryExpressionR0C3 -> primaryExpressionR1C3 [weight=100000000]
    primaryExpressionR0C4 [label = <TE<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C4 [label = <TF<br/>N selfExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C4 [label = <TG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C4 -> primaryExpressionR2C4 [weight=100000000]
    primaryExpressionR0C4 -> primaryExpressionR1C4 [weight=100000000]
    primaryExpressionR0C5 [label = <TH<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C5 [label = <TI<br/>N superclassExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C5 [label = <TJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C5 -> primaryExpressionR2C5 [weight=100000000]
    primaryExpressionR0C5 -> primaryExpressionR1C5 [weight=100000000]
    primaryExpressionR0C6 [label = <TK<br/>ALT <br/>fi ["if", "switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C6 [label = <TL<br/>N conditionalExpression<br/>fi ["if", "switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C6 [label = <TM<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C6 -> primaryExpressionR2C6 [weight=100000000]
    primaryExpressionR0C6 -> primaryExpressionR1C6 [weight=100000000]
    primaryExpressionR0C7 [label = <TN<br/>ALT <br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C7 [label = <TO<br/>N closureExpression<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C7 [label = <TP<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C7 -> primaryExpressionR2C7 [weight=100000000]
    primaryExpressionR0C7 -> primaryExpressionR1C7 [weight=100000000]
    primaryExpressionR0C8 [label = <TQ<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C8 [label = <TR<br/>N parenthesizedExpression<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C8 [label = <TS<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C8 -> primaryExpressionR2C8 [weight=100000000]
    primaryExpressionR0C8 -> primaryExpressionR1C8 [weight=100000000]
    primaryExpressionR0C9 [label = <TT<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C9 [label = <TU<br/>N tupleExpression<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C9 [label = <TV<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C9 -> primaryExpressionR2C9 [weight=100000000]
    primaryExpressionR0C9 -> primaryExpressionR1C9 [weight=100000000]
    primaryExpressionR0C10 [label = <TW<br/>ALT <br/>fi ["."]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C10 [label = <TX<br/>N implicitMemberExpression<br/>fi ["."]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C10 [label = <TY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C10 -> primaryExpressionR2C10 [weight=100000000]
    primaryExpressionR0C10 -> primaryExpressionR1C10 [weight=100000000]
    primaryExpressionR0C11 [label = <TZ<br/>ALT <br/>fi ["_"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C11 [label = <UA<br/>N wildcardExpression<br/>fi ["_"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C11 [label = <UB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C11 -> primaryExpressionR2C11 [weight=100000000]
    primaryExpressionR0C11 -> primaryExpressionR1C11 [weight=100000000]
    primaryExpressionR0C12 [label = <UC<br/>ALT <br/>fi ["#"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C12 [label = <UD<br/>N macroExpansionExpression<br/>fi ["#"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C12 [label = <UE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C12 -> primaryExpressionR2C12 [weight=100000000]
    primaryExpressionR0C12 -> primaryExpressionR1C12 [weight=100000000]
    primaryExpressionR0C13 [label = <UF<br/>ALT <br/>fi ["\\"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C13 [label = <UG<br/>N keyPathExpression<br/>fi ["\\"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C13 [label = <UH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C13 -> primaryExpressionR2C13 [weight=100000000]
    primaryExpressionR0C13 -> primaryExpressionR1C13 [weight=100000000]
    primaryExpressionR0C14 [label = <UI<br/>ALT <br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C14 [label = <UJ<br/>N selectorExpression<br/>fi ["#selector"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C14 [label = <UK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C14 -> primaryExpressionR2C14 [weight=100000000]
    primaryExpressionR0C14 -> primaryExpressionR1C14 [weight=100000000]
    primaryExpressionR0C15 [label = <UL<br/>ALT <br/>fi ["#keyPath"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C15 [label = <UM<br/>N keyPathStringExpression<br/>fi ["#keyPath"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR2C15 [label = <UN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    primaryExpressionR1C15 -> primaryExpressionR2C15 [weight=100000000]
    primaryExpressionR0C15 -> primaryExpressionR1C15 [weight=100000000]
    rank = same {primaryExpressionR0C14 -> primaryExpressionR0C15}
    rank = same {primaryExpressionR0C13 -> primaryExpressionR0C14}
    rank = same {primaryExpressionR0C12 -> primaryExpressionR0C13}
    rank = same {primaryExpressionR0C11 -> primaryExpressionR0C12}
    rank = same {primaryExpressionR0C10 -> primaryExpressionR0C11}
    rank = same {primaryExpressionR0C9 -> primaryExpressionR0C10}
    rank = same {primaryExpressionR0C8 -> primaryExpressionR0C9}
    rank = same {primaryExpressionR0C7 -> primaryExpressionR0C8}
    rank = same {primaryExpressionR0C6 -> primaryExpressionR0C7}
    rank = same {primaryExpressionR0C5 -> primaryExpressionR0C6}
    rank = same {primaryExpressionR0C4 -> primaryExpressionR0C5}
    rank = same {primaryExpressionR0C3 -> primaryExpressionR0C4}
    rank = same {primaryExpressionR0C1 -> primaryExpressionR0C3}
    rank = same {primaryExpressionR0C0 -> primaryExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    primaryExpressionR0C0 -> primaryExpressionR1C0 [weight=100000000]
    rank = same {primaryExpressionR1C0 -> primaryExpressionR1C1}
    rank = same {primaryExpressionR1C1 -> primaryExpressionR1C2}
    rank = same {primaryExpressionR1C2 -> primaryExpressionR1C3}
    primaryExpressionR1C0 -> primaryExpressionR2C0 [weight=100000000]
    rank = same {primaryExpressionR2C0 -> primaryExpressionR2C1}
    primaryExpressionR1C2 -> primaryExpressionR2C2 [weight=100000000]
    primaryExpressionR2C0 -> primaryExpressionR3C0 [weight=100000000]
    rank = same {primaryExpressionR3C0 -> primaryExpressionR3C1}
    primaryExpressionR2C3 -> primaryExpressionR3C3 [weight=100000000]
    rank = same {primaryExpressionR3C2 -> primaryExpressionR3C3}
    primaryExpressionR2C4 -> primaryExpressionR3C4 [weight=100000000]
    rank = same {primaryExpressionR3C3 -> primaryExpressionR3C4}
    primaryExpressionR2C5 -> primaryExpressionR3C5 [weight=100000000]
    rank = same {primaryExpressionR3C4 -> primaryExpressionR3C5}
    primaryExpressionR2C6 -> primaryExpressionR3C6 [weight=100000000]
    rank = same {primaryExpressionR3C5 -> primaryExpressionR3C6}
    primaryExpressionR2C7 -> primaryExpressionR3C7 [weight=100000000]
    rank = same {primaryExpressionR3C6 -> primaryExpressionR3C7}
    primaryExpressionR2C8 -> primaryExpressionR3C8 [weight=100000000]
    rank = same {primaryExpressionR3C7 -> primaryExpressionR3C8}
    primaryExpressionR2C9 -> primaryExpressionR3C9 [weight=100000000]
    rank = same {primaryExpressionR3C8 -> primaryExpressionR3C9}
    primaryExpressionR2C10 -> primaryExpressionR3C10 [weight=100000000]
    rank = same {primaryExpressionR3C9 -> primaryExpressionR3C10}
    primaryExpressionR2C11 -> primaryExpressionR3C11 [weight=100000000]
    rank = same {primaryExpressionR3C10 -> primaryExpressionR3C11}
    primaryExpressionR2C12 -> primaryExpressionR3C12 [weight=100000000]
    rank = same {primaryExpressionR3C11 -> primaryExpressionR3C12}
    primaryExpressionR2C13 -> primaryExpressionR3C13 [weight=100000000]
    rank = same {primaryExpressionR3C12 -> primaryExpressionR3C13}
    primaryExpressionR2C14 -> primaryExpressionR3C14 [weight=100000000]
    rank = same {primaryExpressionR3C13 -> primaryExpressionR3C14}
    primaryExpressionR2C15 -> primaryExpressionR3C15 [weight=100000000]
    rank = same {primaryExpressionR3C14 -> primaryExpressionR3C15}
    primaryExpressionR3C0 -> primaryExpressionR4C0 [weight=100000000]
    primaryExpressionR3C1 -> primaryExpressionR4C1 [weight=100000000]
    rank = same {primaryExpressionR4C0 -> primaryExpressionR4C1}
    rank = same {primaryExpressionR4C1 -> primaryExpressionR4C2}
    primaryExpressionR3C3 -> primaryExpressionR4C3 [weight=100000000]
    rank = same {primaryExpressionR4C2 -> primaryExpressionR4C3}
    primaryExpressionR3C4 -> primaryExpressionR4C4 [weight=100000000]
    rank = same {primaryExpressionR4C3 -> primaryExpressionR4C4}
    primaryExpressionR3C5 -> primaryExpressionR4C5 [weight=100000000]
    rank = same {primaryExpressionR4C4 -> primaryExpressionR4C5}
    primaryExpressionR3C6 -> primaryExpressionR4C6 [weight=100000000]
    rank = same {primaryExpressionR4C5 -> primaryExpressionR4C6}
    primaryExpressionR3C7 -> primaryExpressionR4C7 [weight=100000000]
    rank = same {primaryExpressionR4C6 -> primaryExpressionR4C7}
    primaryExpressionR3C8 -> primaryExpressionR4C8 [weight=100000000]
    rank = same {primaryExpressionR4C7 -> primaryExpressionR4C8}
    primaryExpressionR3C9 -> primaryExpressionR4C9 [weight=100000000]
    rank = same {primaryExpressionR4C8 -> primaryExpressionR4C9}
    primaryExpressionR3C10 -> primaryExpressionR4C10 [weight=100000000]
    rank = same {primaryExpressionR4C9 -> primaryExpressionR4C10}
    primaryExpressionR3C11 -> primaryExpressionR4C11 [weight=100000000]
    rank = same {primaryExpressionR4C10 -> primaryExpressionR4C11}
    primaryExpressionR3C12 -> primaryExpressionR4C12 [weight=100000000]
    rank = same {primaryExpressionR4C11 -> primaryExpressionR4C12}
    primaryExpressionR3C13 -> primaryExpressionR4C13 [weight=100000000]
    rank = same {primaryExpressionR4C12 -> primaryExpressionR4C13}
    primaryExpressionR3C14 -> primaryExpressionR4C14 [weight=100000000]
    rank = same {primaryExpressionR4C13 -> primaryExpressionR4C14}
    primaryExpressionR3C15 -> primaryExpressionR4C15 [weight=100000000]
    rank = same {primaryExpressionR4C14 -> primaryExpressionR4C15}
  }
  subgraph clusterarchitecture {
    node [shape = box]
    label = <architecture = "i386" | "x86_64" | "arm" | "arm64" .>
    labeljust = l
    architectureR0C0 [label = <BST<br/>N architecture<br/>fi ["arm", "arm64", "i386", "x86_64"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR0C1 [label = <BSH<br/>ALT <br/>fi ["i386"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C1 [label = <BSI<br/>T "i386"<br/>fi ["i386"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR2C1 [label = <BSJ<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C1 -> architectureR2C1 [weight=100000000]
    architectureR0C1 -> architectureR1C1 [weight=100000000]
    architectureR0C2 [label = <BSK<br/>ALT <br/>fi ["x86_64"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C2 [label = <BSL<br/>T "x86_64"<br/>fi ["x86_64"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR2C2 [label = <BSM<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C2 -> architectureR2C2 [weight=100000000]
    architectureR0C2 -> architectureR1C2 [weight=100000000]
    architectureR0C3 [label = <BSN<br/>ALT <br/>fi ["arm"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C3 [label = <BSO<br/>T "arm"<br/>fi ["arm"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR2C3 [label = <BSP<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C3 -> architectureR2C3 [weight=100000000]
    architectureR0C3 -> architectureR1C3 [weight=100000000]
    architectureR0C4 [label = <BSQ<br/>ALT <br/>fi ["arm64"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C4 [label = <BSR<br/>T "arm64"<br/>fi ["arm64"]<br/>fo [")"]<br/>am []<br/>>]
    architectureR2C4 [label = <BSS<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    architectureR1C4 -> architectureR2C4 [weight=100000000]
    architectureR0C4 -> architectureR1C4 [weight=100000000]
    rank = same {architectureR0C3 -> architectureR0C4}
    rank = same {architectureR0C2 -> architectureR0C3}
    rank = same {architectureR0C1 -> architectureR0C2}
    rank = same {architectureR0C0 -> architectureR0C1}
    node [style = invis]
    edge [style = invis]
    architectureR0C0 -> architectureR1C0 [weight=100000000]
    rank = same {architectureR1C0 -> architectureR1C1}
    architectureR1C0 -> architectureR2C0 [weight=100000000]
    rank = same {architectureR2C0 -> architectureR2C1}
  }
  subgraph clusterprotocolPropertyDeclaration {
    node [shape = box]
    label = <protocolPropertyDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .>
    labeljust = l
    protocolPropertyDeclarationR0C0 [label = <DJR<br/>N protocolPropertyDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolPropertyDeclarationR0C1 [label = <DJL<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolPropertyDeclarationR1C1 [label = <DJM<br/>N variableDeclarationHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    protocolPropertyDeclarationR2C1 [label = <DJN<br/>N variableName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    protocolPropertyDeclarationR3C1 [label = <DJO<br/>N typeAnnotation<br/>fi [":"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolPropertyDeclarationR4C1 [label = <DJP<br/>N getterSetterKeywordBlock<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolPropertyDeclarationR5C1 [label = <DJQ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolPropertyDeclarationR4C1 -> protocolPropertyDeclarationR5C1 [weight=100000000]
    protocolPropertyDeclarationR3C1 -> protocolPropertyDeclarationR4C1 [weight=100000000]
    protocolPropertyDeclarationR2C1 -> protocolPropertyDeclarationR3C1 [weight=100000000]
    protocolPropertyDeclarationR1C1 -> protocolPropertyDeclarationR2C1 [weight=100000000]
    protocolPropertyDeclarationR0C1 -> protocolPropertyDeclarationR1C1 [weight=100000000]
    rank = same {protocolPropertyDeclarationR0C0 -> protocolPropertyDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    protocolPropertyDeclarationR0C0 -> protocolPropertyDeclarationR1C0 [weight=100000000]
    rank = same {protocolPropertyDeclarationR1C0 -> protocolPropertyDeclarationR1C1}
    protocolPropertyDeclarationR1C0 -> protocolPropertyDeclarationR2C0 [weight=100000000]
    rank = same {protocolPropertyDeclarationR2C0 -> protocolPropertyDeclarationR2C1}
    protocolPropertyDeclarationR2C0 -> protocolPropertyDeclarationR3C0 [weight=100000000]
    rank = same {protocolPropertyDeclarationR3C0 -> protocolPropertyDeclarationR3C1}
    protocolPropertyDeclarationR3C0 -> protocolPropertyDeclarationR4C0 [weight=100000000]
    rank = same {protocolPropertyDeclarationR4C0 -> protocolPropertyDeclarationR4C1}
    protocolPropertyDeclarationR4C0 -> protocolPropertyDeclarationR5C0 [weight=100000000]
    rank = same {protocolPropertyDeclarationR5C0 -> protocolPropertyDeclarationR5C1}
  }
  subgraph clusterassignmentOperator {
    node [shape = box]
    label = <assignmentOperator = "=" .>
    labeljust = l
    assignmentOperatorR0C0 [label = <RT<br/>N assignmentOperator<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    assignmentOperatorR0C1 [label = <RQ<br/>ALT <br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    assignmentOperatorR1C1 [label = <RR<br/>T "="<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    assignmentOperatorR2C1 [label = <RS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    assignmentOperatorR1C1 -> assignmentOperatorR2C1 [weight=100000000]
    assignmentOperatorR0C1 -> assignmentOperatorR1C1 [weight=100000000]
    rank = same {assignmentOperatorR0C0 -> assignmentOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    assignmentOperatorR0C0 -> assignmentOperatorR1C0 [weight=100000000]
    rank = same {assignmentOperatorR1C0 -> assignmentOperatorR1C1}
    assignmentOperatorR1C0 -> assignmentOperatorR2C0 [weight=100000000]
    rank = same {assignmentOperatorR2C0 -> assignmentOperatorR2C1}
  }
  subgraph clusterwillSetClause {
    node [shape = box]
    label = <willSetClause = [ attributes ] "willSet" [ setterName ] codeBlock .>
    labeljust = l
    willSetClauseR0C0 [label = <CKO<br/>N willSetClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    willSetClauseR0C1 [label = <CKC<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    willSetClauseR1C1 [label = <CKG<br/>OPT <br/>fi ["", "@"]<br/>fo ["willSet"]<br/>am []<br/>>]
    willSetClauseR2C1 [label = <CKH<br/>T "willSet"<br/>fi ["willSet"]<br/>fo ["(", "{"]<br/>am []<br/>>]
    willSetClauseR3C1 [label = <CKL<br/>OPT <br/>fi ["", "("]<br/>fo ["{"]<br/>am []<br/>>]
    willSetClauseR4C1 [label = <CKM<br/>N codeBlock<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    willSetClauseR5C1 [label = <CKN<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    willSetClauseR4C1 -> willSetClauseR5C1 [weight=100000000]
    willSetClauseR3C1 -> willSetClauseR4C1 [weight=100000000]
    willSetClauseR3C2 [label = <CKJ<br/>ALT <br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    willSetClauseR4C2 [label = <CKI<br/>N setterName<br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    willSetClauseR5C2 [label = <CKK<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    willSetClauseR4C2 -> willSetClauseR5C2 [weight=100000000]
    willSetClauseR3C2 -> willSetClauseR4C2 [weight=100000000]
    rank = same {willSetClauseR3C1 -> willSetClauseR3C2}
    willSetClauseR2C1 -> willSetClauseR3C1 [weight=100000000]
    willSetClauseR1C1 -> willSetClauseR2C1 [weight=100000000]
    willSetClauseR1C3 [label = <CKE<br/>ALT <br/>fi ["@"]<br/>fo ["willSet"]<br/>am []<br/>>]
    willSetClauseR2C3 [label = <CKD<br/>N attributes<br/>fi ["@"]<br/>fo ["willSet"]<br/>am []<br/>>]
    willSetClauseR3C3 [label = <CKF<br/>END <br/>fi [""]<br/>fo ["willSet"]<br/>am []<br/>>]
    willSetClauseR2C3 -> willSetClauseR3C3 [weight=100000000]
    willSetClauseR1C3 -> willSetClauseR2C3 [weight=100000000]
    rank = same {willSetClauseR1C1 -> willSetClauseR1C3}
    willSetClauseR0C1 -> willSetClauseR1C1 [weight=100000000]
    rank = same {willSetClauseR0C0 -> willSetClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {willSetClauseR0C1 -> willSetClauseR0C2}
    rank = same {willSetClauseR0C2 -> willSetClauseR0C3}
    willSetClauseR0C0 -> willSetClauseR1C0 [weight=100000000]
    rank = same {willSetClauseR1C0 -> willSetClauseR1C1}
    willSetClauseR0C3 -> willSetClauseR1C3 [weight=100000000]
    willSetClauseR1C0 -> willSetClauseR2C0 [weight=100000000]
    rank = same {willSetClauseR2C0 -> willSetClauseR2C1}
    rank = same {willSetClauseR2C1 -> willSetClauseR2C2}
    rank = same {willSetClauseR2C2 -> willSetClauseR2C3}
    willSetClauseR2C0 -> willSetClauseR3C0 [weight=100000000]
    rank = same {willSetClauseR3C0 -> willSetClauseR3C1}
    willSetClauseR2C2 -> willSetClauseR3C2 [weight=100000000]
    willSetClauseR3C0 -> willSetClauseR4C0 [weight=100000000]
    rank = same {willSetClauseR4C0 -> willSetClauseR4C1}
    willSetClauseR3C3 -> willSetClauseR4C3 [weight=100000000]
    rank = same {willSetClauseR4C2 -> willSetClauseR4C3}
    willSetClauseR4C0 -> willSetClauseR5C0 [weight=100000000]
    rank = same {willSetClauseR5C0 -> willSetClauseR5C1}
    willSetClauseR4C3 -> willSetClauseR5C3 [weight=100000000]
    rank = same {willSetClauseR5C2 -> willSetClauseR5C3}
  }
  subgraph clustersuperclassExpression {
    node [shape = box]
    label = <superclassExpression = superclassMethodExpression | superclassSubscriptExpression | superclassInitializerExpression .>
    labeljust = l
    superclassExpressionR0C0 [label = <AAF<br/>N superclassExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["super"]<br/>>]
    superclassExpressionR0C1 [label = <ZW<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C1 [label = <ZX<br/>N superclassMethodExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR2C1 [label = <ZY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C1 -> superclassExpressionR2C1 [weight=100000000]
    superclassExpressionR0C1 -> superclassExpressionR1C1 [weight=100000000]
    superclassExpressionR0C2 [label = <ZZ<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C2 [label = <AAA<br/>N superclassSubscriptExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR2C2 [label = <AAB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C2 -> superclassExpressionR2C2 [weight=100000000]
    superclassExpressionR0C2 -> superclassExpressionR1C2 [weight=100000000]
    superclassExpressionR0C3 [label = <AAC<br/>ALT <br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C3 [label = <AAD<br/>N superclassInitializerExpression<br/>fi ["super"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR2C3 [label = <AAE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    superclassExpressionR1C3 -> superclassExpressionR2C3 [weight=100000000]
    superclassExpressionR0C3 -> superclassExpressionR1C3 [weight=100000000]
    rank = same {superclassExpressionR0C2 -> superclassExpressionR0C3}
    rank = same {superclassExpressionR0C1 -> superclassExpressionR0C2}
    rank = same {superclassExpressionR0C0 -> superclassExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    superclassExpressionR0C0 -> superclassExpressionR1C0 [weight=100000000]
    rank = same {superclassExpressionR1C0 -> superclassExpressionR1C1}
    superclassExpressionR1C0 -> superclassExpressionR2C0 [weight=100000000]
    rank = same {superclassExpressionR2C0 -> superclassExpressionR2C1}
  }
  subgraph clustertypeIdentifier {
    node [shape = box]
    label = <typeIdentifier = typeName [ genericArgumentClause ] | typeName [ genericArgumentClause ] "." typeIdentifier .>
    labeljust = l
    typeIdentifierR0C0 [label = <GR<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeIdentifierR0C1 [label = <GB<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR1C1 [label = <GC<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "&lt;", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR2C1 [label = <GG<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR3C1 [label = <GH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR2C1 -> typeIdentifierR3C1 [weight=100000000]
    typeIdentifierR2C2 [label = <GE<br/>ALT <br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR3C2 [label = <GD<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR4C2 [label = <GF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR3C2 -> typeIdentifierR4C2 [weight=100000000]
    typeIdentifierR2C2 -> typeIdentifierR3C2 [weight=100000000]
    rank = same {typeIdentifierR2C1 -> typeIdentifierR2C2}
    typeIdentifierR1C1 -> typeIdentifierR2C1 [weight=100000000]
    typeIdentifierR0C1 -> typeIdentifierR1C1 [weight=100000000]
    typeIdentifierR0C3 [label = <GI<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR1C3 [label = <GJ<br/>N typeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [".", "&lt;"]<br/>am []<br/>>]
    typeIdentifierR2C3 [label = <GN<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["."]<br/>am []<br/>>]
    typeIdentifierR3C3 [label = <GO<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    typeIdentifierR4C3 [label = <GP<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR5C3 [label = <GQ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeIdentifierR4C3 -> typeIdentifierR5C3 [weight=100000000]
    typeIdentifierR3C3 -> typeIdentifierR4C3 [weight=100000000]
    typeIdentifierR2C3 -> typeIdentifierR3C3 [weight=100000000]
    typeIdentifierR2C4 [label = <GL<br/>ALT <br/>fi ["&lt;"]<br/>fo ["."]<br/>am []<br/>>]
    typeIdentifierR3C4 [label = <GK<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["."]<br/>am []<br/>>]
    typeIdentifierR4C4 [label = <GM<br/>END <br/>fi [""]<br/>fo ["."]<br/>am []<br/>>]
    typeIdentifierR3C4 -> typeIdentifierR4C4 [weight=100000000]
    typeIdentifierR2C4 -> typeIdentifierR3C4 [weight=100000000]
    rank = same {typeIdentifierR2C3 -> typeIdentifierR2C4}
    typeIdentifierR1C3 -> typeIdentifierR2C3 [weight=100000000]
    typeIdentifierR0C3 -> typeIdentifierR1C3 [weight=100000000]
    rank = same {typeIdentifierR0C1 -> typeIdentifierR0C3}
    rank = same {typeIdentifierR0C0 -> typeIdentifierR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {typeIdentifierR0C3 -> typeIdentifierR0C4}
    typeIdentifierR0C0 -> typeIdentifierR1C0 [weight=100000000]
    rank = same {typeIdentifierR1C0 -> typeIdentifierR1C1}
    rank = same {typeIdentifierR1C1 -> typeIdentifierR1C2}
    rank = same {typeIdentifierR1C2 -> typeIdentifierR1C3}
    typeIdentifierR0C4 -> typeIdentifierR1C4 [weight=100000000]
    rank = same {typeIdentifierR1C3 -> typeIdentifierR1C4}
    typeIdentifierR1C0 -> typeIdentifierR2C0 [weight=100000000]
    rank = same {typeIdentifierR2C0 -> typeIdentifierR2C1}
    typeIdentifierR1C2 -> typeIdentifierR2C2 [weight=100000000]
    typeIdentifierR1C4 -> typeIdentifierR2C4 [weight=100000000]
    typeIdentifierR2C0 -> typeIdentifierR3C0 [weight=100000000]
    rank = same {typeIdentifierR3C0 -> typeIdentifierR3C1}
    typeIdentifierR3C0 -> typeIdentifierR4C0 [weight=100000000]
    typeIdentifierR3C1 -> typeIdentifierR4C1 [weight=100000000]
    rank = same {typeIdentifierR4C0 -> typeIdentifierR4C1}
    rank = same {typeIdentifierR4C1 -> typeIdentifierR4C2}
    typeIdentifierR4C0 -> typeIdentifierR5C0 [weight=100000000]
    typeIdentifierR4C1 -> typeIdentifierR5C1 [weight=100000000]
    rank = same {typeIdentifierR5C0 -> typeIdentifierR5C1}
    typeIdentifierR4C2 -> typeIdentifierR5C2 [weight=100000000]
    rank = same {typeIdentifierR5C1 -> typeIdentifierR5C2}
    rank = same {typeIdentifierR5C2 -> typeIdentifierR5C3}
    typeIdentifierR4C4 -> typeIdentifierR5C4 [weight=100000000]
    rank = same {typeIdentifierR5C3 -> typeIdentifierR5C4}
  }
  subgraph clusterstructMembers {
    node [shape = box]
    label = <structMembers = structMember [ structMembers ] .>
    labeljust = l
    structMembersR0C0 [label = <DBE<br/>N structMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR0C1 [label = <DAX<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR1C1 [label = <DAY<br/>N structMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    structMembersR2C1 [label = <DBC<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR3C1 [label = <DBD<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR2C1 -> structMembersR3C1 [weight=100000000]
    structMembersR2C2 [label = <DBA<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR3C2 [label = <DAZ<br/>N structMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR4C2 [label = <DBB<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    structMembersR3C2 -> structMembersR4C2 [weight=100000000]
    structMembersR2C2 -> structMembersR3C2 [weight=100000000]
    rank = same {structMembersR2C1 -> structMembersR2C2}
    structMembersR1C1 -> structMembersR2C1 [weight=100000000]
    structMembersR0C1 -> structMembersR1C1 [weight=100000000]
    rank = same {structMembersR0C0 -> structMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {structMembersR0C1 -> structMembersR0C2}
    structMembersR0C0 -> structMembersR1C0 [weight=100000000]
    rank = same {structMembersR1C0 -> structMembersR1C1}
    structMembersR0C2 -> structMembersR1C2 [weight=100000000]
    rank = same {structMembersR1C1 -> structMembersR1C2}
    structMembersR1C0 -> structMembersR2C0 [weight=100000000]
    rank = same {structMembersR2C0 -> structMembersR2C1}
    structMembersR1C2 -> structMembersR2C2 [weight=100000000]
    structMembersR2C0 -> structMembersR3C0 [weight=100000000]
    rank = same {structMembersR3C0 -> structMembersR3C1}
    structMembersR3C0 -> structMembersR4C0 [weight=100000000]
    structMembersR3C1 -> structMembersR4C1 [weight=100000000]
    rank = same {structMembersR4C0 -> structMembersR4C1}
    rank = same {structMembersR4C1 -> structMembersR4C2}
  }
  subgraph clusterdictionaryType {
    node [shape = box]
    label = <dictionaryType = "[" type ":" type "]" .>
    labeljust = l
    dictionaryTypeR0C0 [label = <LJ<br/>N dictionaryType<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryTypeR0C1 [label = <LC<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryTypeR1C1 [label = <LD<br/>T "["<br/>fi ["["]<br/>fo ["(", ":", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    dictionaryTypeR2C1 [label = <LE<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [":"]<br/>am []<br/>>]
    dictionaryTypeR3C1 [label = <LF<br/>T ":"<br/>fi [":"]<br/>fo ["(", "@", "Any", "Self", "[", "]", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    dictionaryTypeR4C1 [label = <LG<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryTypeR5C1 [label = <LH<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryTypeR6C1 [label = <LI<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryTypeR5C1 -> dictionaryTypeR6C1 [weight=100000000]
    dictionaryTypeR4C1 -> dictionaryTypeR5C1 [weight=100000000]
    dictionaryTypeR3C1 -> dictionaryTypeR4C1 [weight=100000000]
    dictionaryTypeR2C1 -> dictionaryTypeR3C1 [weight=100000000]
    dictionaryTypeR1C1 -> dictionaryTypeR2C1 [weight=100000000]
    dictionaryTypeR0C1 -> dictionaryTypeR1C1 [weight=100000000]
    rank = same {dictionaryTypeR0C0 -> dictionaryTypeR0C1}
    node [style = invis]
    edge [style = invis]
    dictionaryTypeR0C0 -> dictionaryTypeR1C0 [weight=100000000]
    rank = same {dictionaryTypeR1C0 -> dictionaryTypeR1C1}
    dictionaryTypeR1C0 -> dictionaryTypeR2C0 [weight=100000000]
    rank = same {dictionaryTypeR2C0 -> dictionaryTypeR2C1}
    dictionaryTypeR2C0 -> dictionaryTypeR3C0 [weight=100000000]
    rank = same {dictionaryTypeR3C0 -> dictionaryTypeR3C1}
    dictionaryTypeR3C0 -> dictionaryTypeR4C0 [weight=100000000]
    rank = same {dictionaryTypeR4C0 -> dictionaryTypeR4C1}
    dictionaryTypeR4C0 -> dictionaryTypeR5C0 [weight=100000000]
    rank = same {dictionaryTypeR5C0 -> dictionaryTypeR5C1}
    dictionaryTypeR5C0 -> dictionaryTypeR6C0 [weight=100000000]
    rank = same {dictionaryTypeR6C0 -> dictionaryTypeR6C1}
  }
  subgraph clusterconditionalOperator {
    node [shape = box]
    label = <conditionalOperator = "?" expression ":" .>
    labeljust = l
    conditionalOperatorR0C0 [label = <RZ<br/>N conditionalOperator<br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalOperatorR0C1 [label = <RU<br/>ALT <br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalOperatorR1C1 [label = <RV<br/>T "?"<br/>fi ["?"]<br/>fo [":", "try"]<br/>am []<br/>>]
    conditionalOperatorR2C1 [label = <RW<br/>N expression<br/>fi ["", "try"]<br/>fo [":"]<br/>am []<br/>>]
    conditionalOperatorR3C1 [label = <RX<br/>T ":"<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalOperatorR4C1 [label = <RY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalOperatorR3C1 -> conditionalOperatorR4C1 [weight=100000000]
    conditionalOperatorR2C1 -> conditionalOperatorR3C1 [weight=100000000]
    conditionalOperatorR1C1 -> conditionalOperatorR2C1 [weight=100000000]
    conditionalOperatorR0C1 -> conditionalOperatorR1C1 [weight=100000000]
    rank = same {conditionalOperatorR0C0 -> conditionalOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    conditionalOperatorR0C0 -> conditionalOperatorR1C0 [weight=100000000]
    rank = same {conditionalOperatorR1C0 -> conditionalOperatorR1C1}
    conditionalOperatorR1C0 -> conditionalOperatorR2C0 [weight=100000000]
    rank = same {conditionalOperatorR2C0 -> conditionalOperatorR2C1}
    conditionalOperatorR2C0 -> conditionalOperatorR3C0 [weight=100000000]
    rank = same {conditionalOperatorR3C0 -> conditionalOperatorR3C1}
    conditionalOperatorR3C0 -> conditionalOperatorR4C0 [weight=100000000]
    rank = same {conditionalOperatorR4C0 -> conditionalOperatorR4C1}
  }
  subgraph clustercontinueStatement {
    node [shape = box]
    label = <continueStatement = "continue" [ labelName ] .>
    labeljust = l
    continueStatementR0C0 [label = <BIU<br/>N continueStatement<br/>fi ["continue"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR0C1 [label = <BIN<br/>ALT <br/>fi ["continue"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR1C1 [label = <BIO<br/>T "continue"<br/>fi ["continue"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR2C1 [label = <BIS<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    continueStatementR3C1 [label = <BIT<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR2C1 -> continueStatementR3C1 [weight=100000000]
    continueStatementR2C2 [label = <BIQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR3C2 [label = <BIP<br/>N labelName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR4C2 [label = <BIR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    continueStatementR3C2 -> continueStatementR4C2 [weight=100000000]
    continueStatementR2C2 -> continueStatementR3C2 [weight=100000000]
    rank = same {continueStatementR2C1 -> continueStatementR2C2}
    continueStatementR1C1 -> continueStatementR2C1 [weight=100000000]
    continueStatementR0C1 -> continueStatementR1C1 [weight=100000000]
    rank = same {continueStatementR0C0 -> continueStatementR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {continueStatementR0C1 -> continueStatementR0C2}
    continueStatementR0C0 -> continueStatementR1C0 [weight=100000000]
    rank = same {continueStatementR1C0 -> continueStatementR1C1}
    continueStatementR0C2 -> continueStatementR1C2 [weight=100000000]
    rank = same {continueStatementR1C1 -> continueStatementR1C2}
    continueStatementR1C0 -> continueStatementR2C0 [weight=100000000]
    rank = same {continueStatementR2C0 -> continueStatementR2C1}
    continueStatementR1C2 -> continueStatementR2C2 [weight=100000000]
    continueStatementR2C0 -> continueStatementR3C0 [weight=100000000]
    rank = same {continueStatementR3C0 -> continueStatementR3C1}
    continueStatementR3C0 -> continueStatementR4C0 [weight=100000000]
    continueStatementR3C1 -> continueStatementR4C1 [weight=100000000]
    rank = same {continueStatementR4C0 -> continueStatementR4C1}
    rank = same {continueStatementR4C1 -> continueStatementR4C2}
  }
  subgraph clusterprotocolCompositionType {
    node [shape = box]
    label = <protocolCompositionType = typeIdentifier "&amp;" protocolCompositionContinuation .>
    labeljust = l
    protocolCompositionTypeR0C0 [label = <LZ<br/>N protocolCompositionType<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionTypeR0C1 [label = <LU<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionTypeR1C1 [label = <LV<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&amp;"]<br/>am []<br/>>]
    protocolCompositionTypeR2C1 [label = <LW<br/>T "&amp;"<br/>fi ["&amp;"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    protocolCompositionTypeR3C1 [label = <LX<br/>N protocolCompositionContinuation<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionTypeR4C1 [label = <LY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    protocolCompositionTypeR3C1 -> protocolCompositionTypeR4C1 [weight=100000000]
    protocolCompositionTypeR2C1 -> protocolCompositionTypeR3C1 [weight=100000000]
    protocolCompositionTypeR1C1 -> protocolCompositionTypeR2C1 [weight=100000000]
    protocolCompositionTypeR0C1 -> protocolCompositionTypeR1C1 [weight=100000000]
    rank = same {protocolCompositionTypeR0C0 -> protocolCompositionTypeR0C1}
    node [style = invis]
    edge [style = invis]
    protocolCompositionTypeR0C0 -> protocolCompositionTypeR1C0 [weight=100000000]
    rank = same {protocolCompositionTypeR1C0 -> protocolCompositionTypeR1C1}
    protocolCompositionTypeR1C0 -> protocolCompositionTypeR2C0 [weight=100000000]
    rank = same {protocolCompositionTypeR2C0 -> protocolCompositionTypeR2C1}
    protocolCompositionTypeR2C0 -> protocolCompositionTypeR3C0 [weight=100000000]
    rank = same {protocolCompositionTypeR3C0 -> protocolCompositionTypeR3C1}
    protocolCompositionTypeR3C0 -> protocolCompositionTypeR4C0 [weight=100000000]
    rank = same {protocolCompositionTypeR4C0 -> protocolCompositionTypeR4C1}
  }
  subgraph clusterfunctionCallArgumentList {
    node [shape = box]
    label = <functionCallArgumentList = functionCallArgument | functionCallArgument "," functionCallArgumentList .>
    labeljust = l
    functionCallArgumentListR0C0 [label = <AQD<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", "]"]<br/>am ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>>]
    functionCallArgumentListR0C1 [label = <APV<br/>ALT <br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR1C1 [label = <APW<br/>N functionCallArgument<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR2C1 [label = <APX<br/>END <br/>fi [""]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR1C1 -> functionCallArgumentListR2C1 [weight=100000000]
    functionCallArgumentListR0C1 -> functionCallArgumentListR1C1 [weight=100000000]
    functionCallArgumentListR0C2 [label = <APY<br/>ALT <br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR1C2 [label = <APZ<br/>N functionCallArgument<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [","]<br/>am []<br/>>]
    functionCallArgumentListR2C2 [label = <AQA<br/>T ","<br/>fi [","]<br/>fo [")", "]", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    functionCallArgumentListR3C2 [label = <AQB<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR4C2 [label = <AQC<br/>END <br/>fi [""]<br/>fo [")", "]"]<br/>am []<br/>>]
    functionCallArgumentListR3C2 -> functionCallArgumentListR4C2 [weight=100000000]
    functionCallArgumentListR2C2 -> functionCallArgumentListR3C2 [weight=100000000]
    functionCallArgumentListR1C2 -> functionCallArgumentListR2C2 [weight=100000000]
    functionCallArgumentListR0C2 -> functionCallArgumentListR1C2 [weight=100000000]
    rank = same {functionCallArgumentListR0C1 -> functionCallArgumentListR0C2}
    rank = same {functionCallArgumentListR0C0 -> functionCallArgumentListR0C1}
    node [style = invis]
    edge [style = invis]
    functionCallArgumentListR0C0 -> functionCallArgumentListR1C0 [weight=100000000]
    rank = same {functionCallArgumentListR1C0 -> functionCallArgumentListR1C1}
    functionCallArgumentListR1C0 -> functionCallArgumentListR2C0 [weight=100000000]
    rank = same {functionCallArgumentListR2C0 -> functionCallArgumentListR2C1}
    functionCallArgumentListR2C0 -> functionCallArgumentListR3C0 [weight=100000000]
    functionCallArgumentListR2C1 -> functionCallArgumentListR3C1 [weight=100000000]
    rank = same {functionCallArgumentListR3C0 -> functionCallArgumentListR3C1}
    rank = same {functionCallArgumentListR3C1 -> functionCallArgumentListR3C2}
    functionCallArgumentListR3C0 -> functionCallArgumentListR4C0 [weight=100000000]
    functionCallArgumentListR3C1 -> functionCallArgumentListR4C1 [weight=100000000]
    rank = same {functionCallArgumentListR4C0 -> functionCallArgumentListR4C1}
    rank = same {functionCallArgumentListR4C1 -> functionCallArgumentListR4C2}
  }
  subgraph clusterexternalParameterName {
    node [shape = box]
    label = <externalParameterName = identifier .>
    labeljust = l
    externalParameterNameR0C0 [label = <CRD<br/>N externalParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    externalParameterNameR0C1 [label = <CRA<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    externalParameterNameR1C1 [label = <CRB<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    externalParameterNameR2C1 [label = <CRC<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    externalParameterNameR1C1 -> externalParameterNameR2C1 [weight=100000000]
    externalParameterNameR0C1 -> externalParameterNameR1C1 [weight=100000000]
    rank = same {externalParameterNameR0C0 -> externalParameterNameR0C1}
    node [style = invis]
    edge [style = invis]
    externalParameterNameR0C0 -> externalParameterNameR1C0 [weight=100000000]
    rank = same {externalParameterNameR1C0 -> externalParameterNameR1C1}
    externalParameterNameR1C0 -> externalParameterNameR2C0 [weight=100000000]
    rank = same {externalParameterNameR2C0 -> externalParameterNameR2C1}
  }
  subgraph clusteractorName {
    node [shape = box]
    label = <actorName = identifier .>
    labeljust = l
    actorNameR0C0 [label = <DFV<br/>N actorName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    actorNameR0C1 [label = <DFS<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    actorNameR1C1 [label = <DFT<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    actorNameR2C1 [label = <DFU<br/>END <br/>fi [""]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    actorNameR1C1 -> actorNameR2C1 [weight=100000000]
    actorNameR0C1 -> actorNameR1C1 [weight=100000000]
    rank = same {actorNameR0C0 -> actorNameR0C1}
    node [style = invis]
    edge [style = invis]
    actorNameR0C0 -> actorNameR1C0 [weight=100000000]
    rank = same {actorNameR1C0 -> actorNameR1C1}
    actorNameR1C0 -> actorNameR2C0 [weight=100000000]
    rank = same {actorNameR2C0 -> actorNameR2C1}
  }
  subgraph clusterprefixOperator {
    node [shape = box]
    label = <prefixOperator = Operator .>
    labeljust = l
    prefixOperatorR0C0 [label = <DT<br/>N prefixOperator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixOperatorR0C1 [label = <DQ<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixOperatorR1C1 [label = <DR<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixOperatorR2C1 [label = <DS<br/>END <br/>fi [""]<br/>fo ["#", "#colorLiteral", "#fileLiteral", "#imageLiteral", "#keyPath", "#selector", "(", ".", "[", "\\", "_", "binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "escapedIdentifier", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "if", "implicitParameterName", "interpolatedStringLiteral", "nil", "octalLiteral", "plainIdentifier", "propertyWrapperProjection", "regularExpressionLiteral", "self", "staticStringLiteral", "super", "switch", "true", "{"]<br/>am []<br/>>]
    prefixOperatorR1C1 -> prefixOperatorR2C1 [weight=100000000]
    prefixOperatorR0C1 -> prefixOperatorR1C1 [weight=100000000]
    rank = same {prefixOperatorR0C0 -> prefixOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    prefixOperatorR0C0 -> prefixOperatorR1C0 [weight=100000000]
    rank = same {prefixOperatorR1C0 -> prefixOperatorR1C1}
    prefixOperatorR1C0 -> prefixOperatorR2C0 [weight=100000000]
    rank = same {prefixOperatorR2C0 -> prefixOperatorR2C1}
  }
  subgraph clusterparameterList {
    node [shape = box]
    label = <parameterList = parameter | parameter "," parameterList .>
    labeljust = l
    parameterListR0C0 [label = <CPV<br/>N parameterList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    parameterListR0C1 [label = <CPN<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR1C1 [label = <CPO<br/>N parameter<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR2C1 [label = <CPP<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR1C1 -> parameterListR2C1 [weight=100000000]
    parameterListR0C1 -> parameterListR1C1 [weight=100000000]
    parameterListR0C2 [label = <CPQ<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR1C2 [label = <CPR<br/>N parameter<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    parameterListR2C2 [label = <CPS<br/>T ","<br/>fi [","]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    parameterListR3C2 [label = <CPT<br/>N parameterList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR4C2 [label = <CPU<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    parameterListR3C2 -> parameterListR4C2 [weight=100000000]
    parameterListR2C2 -> parameterListR3C2 [weight=100000000]
    parameterListR1C2 -> parameterListR2C2 [weight=100000000]
    parameterListR0C2 -> parameterListR1C2 [weight=100000000]
    rank = same {parameterListR0C1 -> parameterListR0C2}
    rank = same {parameterListR0C0 -> parameterListR0C1}
    node [style = invis]
    edge [style = invis]
    parameterListR0C0 -> parameterListR1C0 [weight=100000000]
    rank = same {parameterListR1C0 -> parameterListR1C1}
    parameterListR1C0 -> parameterListR2C0 [weight=100000000]
    rank = same {parameterListR2C0 -> parameterListR2C1}
    parameterListR2C0 -> parameterListR3C0 [weight=100000000]
    parameterListR2C1 -> parameterListR3C1 [weight=100000000]
    rank = same {parameterListR3C0 -> parameterListR3C1}
    rank = same {parameterListR3C1 -> parameterListR3C2}
    parameterListR3C0 -> parameterListR4C0 [weight=100000000]
    parameterListR3C1 -> parameterListR4C1 [weight=100000000]
    rank = same {parameterListR4C0 -> parameterListR4C1}
    rank = same {parameterListR4C1 -> parameterListR4C2}
  }
  subgraph clusterliteral {
    node [shape = box]
    label = <literal = numericLiteral | stringLiteral | "regularExpressionLiteral" | booleanLiteral | nilLiteral .>
    labeljust = l
    literalR0C0 [label = <BO<br/>N literal<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "false", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "interpolatedStringLiteral", "nil", "octalLiteral", "regularExpressionLiteral", "staticStringLiteral", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR0C1 [label = <AZ<br/>ALT <br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C1 [label = <BA<br/>N numericLiteral<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR2C1 [label = <BB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C1 -> literalR2C1 [weight=100000000]
    literalR0C1 -> literalR1C1 [weight=100000000]
    literalR0C2 [label = <BC<br/>ALT <br/>fi ["interpolatedStringLiteral", "staticStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C2 [label = <BD<br/>N stringLiteral<br/>fi ["interpolatedStringLiteral", "staticStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR2C2 [label = <BE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C2 -> literalR2C2 [weight=100000000]
    literalR0C2 -> literalR1C2 [weight=100000000]
    literalR0C3 [label = <BF<br/>ALT <br/>fi ["regularExpressionLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C3 [label = <BG<br/>T "regularExpressionLiteral"<br/>fi ["regularExpressionLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR2C3 [label = <BH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C3 -> literalR2C3 [weight=100000000]
    literalR0C3 -> literalR1C3 [weight=100000000]
    literalR0C4 [label = <BI<br/>ALT <br/>fi ["false", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C4 [label = <BJ<br/>N booleanLiteral<br/>fi ["false", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR2C4 [label = <BK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C4 -> literalR2C4 [weight=100000000]
    literalR0C4 -> literalR1C4 [weight=100000000]
    literalR0C5 [label = <BL<br/>ALT <br/>fi ["nil"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C5 [label = <BM<br/>N nilLiteral<br/>fi ["nil"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR2C5 [label = <BN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    literalR1C5 -> literalR2C5 [weight=100000000]
    literalR0C5 -> literalR1C5 [weight=100000000]
    rank = same {literalR0C4 -> literalR0C5}
    rank = same {literalR0C3 -> literalR0C4}
    rank = same {literalR0C2 -> literalR0C3}
    rank = same {literalR0C1 -> literalR0C2}
    rank = same {literalR0C0 -> literalR0C1}
    node [style = invis]
    edge [style = invis]
    literalR0C0 -> literalR1C0 [weight=100000000]
    rank = same {literalR1C0 -> literalR1C1}
    literalR1C0 -> literalR2C0 [weight=100000000]
    rank = same {literalR2C0 -> literalR2C1}
  }
  subgraph clusteractorMembers {
    node [shape = box]
    label = <actorMembers = actorMember [ actorMembers ] .>
    labeljust = l
    actorMembersR0C0 [label = <DGM<br/>N actorMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR0C1 [label = <DGF<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR1C1 [label = <DGG<br/>N actorMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    actorMembersR2C1 [label = <DGK<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR3C1 [label = <DGL<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR2C1 -> actorMembersR3C1 [weight=100000000]
    actorMembersR2C2 [label = <DGI<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR3C2 [label = <DGH<br/>N actorMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR4C2 [label = <DGJ<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    actorMembersR3C2 -> actorMembersR4C2 [weight=100000000]
    actorMembersR2C2 -> actorMembersR3C2 [weight=100000000]
    rank = same {actorMembersR2C1 -> actorMembersR2C2}
    actorMembersR1C1 -> actorMembersR2C1 [weight=100000000]
    actorMembersR0C1 -> actorMembersR1C1 [weight=100000000]
    rank = same {actorMembersR0C0 -> actorMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {actorMembersR0C1 -> actorMembersR0C2}
    actorMembersR0C0 -> actorMembersR1C0 [weight=100000000]
    rank = same {actorMembersR1C0 -> actorMembersR1C1}
    actorMembersR0C2 -> actorMembersR1C2 [weight=100000000]
    rank = same {actorMembersR1C1 -> actorMembersR1C2}
    actorMembersR1C0 -> actorMembersR2C0 [weight=100000000]
    rank = same {actorMembersR2C0 -> actorMembersR2C1}
    actorMembersR1C2 -> actorMembersR2C2 [weight=100000000]
    actorMembersR2C0 -> actorMembersR3C0 [weight=100000000]
    rank = same {actorMembersR3C0 -> actorMembersR3C1}
    actorMembersR3C0 -> actorMembersR4C0 [weight=100000000]
    actorMembersR3C1 -> actorMembersR4C1 [weight=100000000]
    rank = same {actorMembersR4C0 -> actorMembersR4C1}
    rank = same {actorMembersR4C1 -> actorMembersR4C2}
  }
  subgraph clusterisPattern {
    node [shape = box]
    label = <isPattern = "is" type .>
    labeljust = l
    isPatternR0C0 [label = <ENB<br/>N isPattern<br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    isPatternR0C1 [label = <EMX<br/>ALT <br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    isPatternR1C1 [label = <EMY<br/>T "is"<br/>fi ["is"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "Any", "Self", "[", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    isPatternR2C1 [label = <EMZ<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    isPatternR3C1 [label = <ENA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    isPatternR2C1 -> isPatternR3C1 [weight=100000000]
    isPatternR1C1 -> isPatternR2C1 [weight=100000000]
    isPatternR0C1 -> isPatternR1C1 [weight=100000000]
    rank = same {isPatternR0C0 -> isPatternR0C1}
    node [style = invis]
    edge [style = invis]
    isPatternR0C0 -> isPatternR1C0 [weight=100000000]
    rank = same {isPatternR1C0 -> isPatternR1C1}
    isPatternR1C0 -> isPatternR2C0 [weight=100000000]
    rank = same {isPatternR2C0 -> isPatternR2C1}
    isPatternR2C0 -> isPatternR3C0 [weight=100000000]
    rank = same {isPatternR3C0 -> isPatternR3C1}
  }
  subgraph clustergenericArgument {
    node [shape = box]
    label = <genericArgument = type .>
    labeljust = l
    genericArgumentR0C0 [label = <EQT<br/>N genericArgument<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericArgumentR0C1 [label = <EQQ<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericArgumentR1C1 [label = <EQR<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericArgumentR2C1 [label = <EQS<br/>END <br/>fi [""]<br/>fo [",", "&gt;"]<br/>am []<br/>>]
    genericArgumentR1C1 -> genericArgumentR2C1 [weight=100000000]
    genericArgumentR0C1 -> genericArgumentR1C1 [weight=100000000]
    rank = same {genericArgumentR0C0 -> genericArgumentR0C1}
    node [style = invis]
    edge [style = invis]
    genericArgumentR0C0 -> genericArgumentR1C0 [weight=100000000]
    rank = same {genericArgumentR1C0 -> genericArgumentR1C1}
    genericArgumentR1C0 -> genericArgumentR2C0 [weight=100000000]
    rank = same {genericArgumentR2C0 -> genericArgumentR2C1}
  }
  subgraph clusterprecedenceGroupAssignment {
    node [shape = box]
    label = <precedenceGroupAssignment = "assignment" ":" booleanLiteral .>
    labeljust = l
    precedenceGroupAssignmentR0C0 [label = <DYX<br/>N precedenceGroupAssignment<br/>fi ["assignment"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssignmentR0C1 [label = <DYS<br/>ALT <br/>fi ["assignment"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssignmentR1C1 [label = <DYT<br/>T "assignment"<br/>fi ["assignment"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupAssignmentR2C1 [label = <DYU<br/>T ":"<br/>fi [":"]<br/>fo ["false", "true"]<br/>am []<br/>>]
    precedenceGroupAssignmentR3C1 [label = <DYV<br/>N booleanLiteral<br/>fi ["false", "true"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssignmentR4C1 [label = <DYW<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssignmentR3C1 -> precedenceGroupAssignmentR4C1 [weight=100000000]
    precedenceGroupAssignmentR2C1 -> precedenceGroupAssignmentR3C1 [weight=100000000]
    precedenceGroupAssignmentR1C1 -> precedenceGroupAssignmentR2C1 [weight=100000000]
    precedenceGroupAssignmentR0C1 -> precedenceGroupAssignmentR1C1 [weight=100000000]
    rank = same {precedenceGroupAssignmentR0C0 -> precedenceGroupAssignmentR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupAssignmentR0C0 -> precedenceGroupAssignmentR1C0 [weight=100000000]
    rank = same {precedenceGroupAssignmentR1C0 -> precedenceGroupAssignmentR1C1}
    precedenceGroupAssignmentR1C0 -> precedenceGroupAssignmentR2C0 [weight=100000000]
    rank = same {precedenceGroupAssignmentR2C0 -> precedenceGroupAssignmentR2C1}
    precedenceGroupAssignmentR2C0 -> precedenceGroupAssignmentR3C0 [weight=100000000]
    rank = same {precedenceGroupAssignmentR3C0 -> precedenceGroupAssignmentR3C1}
    precedenceGroupAssignmentR3C0 -> precedenceGroupAssignmentR4C0 [weight=100000000]
    rank = same {precedenceGroupAssignmentR4C0 -> precedenceGroupAssignmentR4C1}
  }
  subgraph clusterinfixOperatorDeclaration {
    node [shape = box]
    label = <infixOperatorDeclaration = "infix" "operator" Operator [ infixOperatorGroup ] .>
    labeljust = l
    infixOperatorDeclarationR0C0 [label = <DWY<br/>N infixOperatorDeclaration<br/>fi ["infix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR0C1 [label = <DWP<br/>ALT <br/>fi ["infix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR1C1 [label = <DWQ<br/>T "infix"<br/>fi ["infix"]<br/>fo ["operator"]<br/>am []<br/>>]
    infixOperatorDeclarationR2C1 [label = <DWR<br/>T "operator"<br/>fi ["operator"]<br/>fo ["dotOperator", "plainOperator"]<br/>am []<br/>>]
    infixOperatorDeclarationR3C1 [label = <DWS<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ":", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR4C1 [label = <DWW<br/>OPT <br/>fi ["", ":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR5C1 [label = <DWX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR4C1 -> infixOperatorDeclarationR5C1 [weight=100000000]
    infixOperatorDeclarationR4C2 [label = <DWU<br/>ALT <br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR5C2 [label = <DWT<br/>N infixOperatorGroup<br/>fi [":"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR6C2 [label = <DWV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    infixOperatorDeclarationR5C2 -> infixOperatorDeclarationR6C2 [weight=100000000]
    infixOperatorDeclarationR4C2 -> infixOperatorDeclarationR5C2 [weight=100000000]
    rank = same {infixOperatorDeclarationR4C1 -> infixOperatorDeclarationR4C2}
    infixOperatorDeclarationR3C1 -> infixOperatorDeclarationR4C1 [weight=100000000]
    infixOperatorDeclarationR2C1 -> infixOperatorDeclarationR3C1 [weight=100000000]
    infixOperatorDeclarationR1C1 -> infixOperatorDeclarationR2C1 [weight=100000000]
    infixOperatorDeclarationR0C1 -> infixOperatorDeclarationR1C1 [weight=100000000]
    rank = same {infixOperatorDeclarationR0C0 -> infixOperatorDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {infixOperatorDeclarationR0C1 -> infixOperatorDeclarationR0C2}
    infixOperatorDeclarationR0C0 -> infixOperatorDeclarationR1C0 [weight=100000000]
    rank = same {infixOperatorDeclarationR1C0 -> infixOperatorDeclarationR1C1}
    infixOperatorDeclarationR0C2 -> infixOperatorDeclarationR1C2 [weight=100000000]
    rank = same {infixOperatorDeclarationR1C1 -> infixOperatorDeclarationR1C2}
    infixOperatorDeclarationR1C0 -> infixOperatorDeclarationR2C0 [weight=100000000]
    rank = same {infixOperatorDeclarationR2C0 -> infixOperatorDeclarationR2C1}
    infixOperatorDeclarationR1C2 -> infixOperatorDeclarationR2C2 [weight=100000000]
    rank = same {infixOperatorDeclarationR2C1 -> infixOperatorDeclarationR2C2}
    infixOperatorDeclarationR2C0 -> infixOperatorDeclarationR3C0 [weight=100000000]
    rank = same {infixOperatorDeclarationR3C0 -> infixOperatorDeclarationR3C1}
    infixOperatorDeclarationR2C2 -> infixOperatorDeclarationR3C2 [weight=100000000]
    rank = same {infixOperatorDeclarationR3C1 -> infixOperatorDeclarationR3C2}
    infixOperatorDeclarationR3C0 -> infixOperatorDeclarationR4C0 [weight=100000000]
    rank = same {infixOperatorDeclarationR4C0 -> infixOperatorDeclarationR4C1}
    infixOperatorDeclarationR3C2 -> infixOperatorDeclarationR4C2 [weight=100000000]
    infixOperatorDeclarationR4C0 -> infixOperatorDeclarationR5C0 [weight=100000000]
    rank = same {infixOperatorDeclarationR5C0 -> infixOperatorDeclarationR5C1}
    infixOperatorDeclarationR5C0 -> infixOperatorDeclarationR6C0 [weight=100000000]
    infixOperatorDeclarationR5C1 -> infixOperatorDeclarationR6C1 [weight=100000000]
    rank = same {infixOperatorDeclarationR6C0 -> infixOperatorDeclarationR6C1}
    rank = same {infixOperatorDeclarationR6C1 -> infixOperatorDeclarationR6C2}
  }
  subgraph clusterprotocolDeclaration {
    node [shape = box]
    label = <protocolDeclaration = [ attributes ] [ accessLevelModifier ] "protocol" protocolName [ typeInheritanceClause ] [ genericWhereClause ] protocolBody .>
    labeljust = l
    protocolDeclarationR0C0 [label = <DHP<br/>N protocolDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    protocolDeclarationR0C1 [label = <DGU<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    protocolDeclarationR1C1 [label = <DGY<br/>OPT <br/>fi ["", "@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "protocol", "public"]<br/>am []<br/>>]
    protocolDeclarationR2C1 [label = <DHC<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["protocol"]<br/>am []<br/>>]
    protocolDeclarationR3C1 [label = <DHD<br/>T "protocol"<br/>fi ["protocol"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    protocolDeclarationR4C1 [label = <DHE<br/>N protocolName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    protocolDeclarationR5C1 [label = <DHI<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    protocolDeclarationR6C1 [label = <DHM<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolDeclarationR7C1 [label = <DHN<br/>N protocolBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolDeclarationR8C1 [label = <DHO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolDeclarationR7C1 -> protocolDeclarationR8C1 [weight=100000000]
    protocolDeclarationR6C1 -> protocolDeclarationR7C1 [weight=100000000]
    protocolDeclarationR6C2 [label = <DHK<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolDeclarationR7C2 [label = <DHJ<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    protocolDeclarationR8C2 [label = <DHL<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    protocolDeclarationR7C2 -> protocolDeclarationR8C2 [weight=100000000]
    protocolDeclarationR6C2 -> protocolDeclarationR7C2 [weight=100000000]
    rank = same {protocolDeclarationR6C1 -> protocolDeclarationR6C2}
    protocolDeclarationR5C1 -> protocolDeclarationR6C1 [weight=100000000]
    protocolDeclarationR5C3 [label = <DHG<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    protocolDeclarationR6C3 [label = <DHF<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    protocolDeclarationR7C3 [label = <DHH<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    protocolDeclarationR6C3 -> protocolDeclarationR7C3 [weight=100000000]
    protocolDeclarationR5C3 -> protocolDeclarationR6C3 [weight=100000000]
    rank = same {protocolDeclarationR5C1 -> protocolDeclarationR5C3}
    protocolDeclarationR4C1 -> protocolDeclarationR5C1 [weight=100000000]
    protocolDeclarationR3C1 -> protocolDeclarationR4C1 [weight=100000000]
    protocolDeclarationR2C1 -> protocolDeclarationR3C1 [weight=100000000]
    protocolDeclarationR2C4 [label = <DHA<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["protocol"]<br/>am []<br/>>]
    protocolDeclarationR3C4 [label = <DGZ<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["protocol"]<br/>am []<br/>>]
    protocolDeclarationR4C4 [label = <DHB<br/>END <br/>fi [""]<br/>fo ["protocol"]<br/>am []<br/>>]
    protocolDeclarationR3C4 -> protocolDeclarationR4C4 [weight=100000000]
    protocolDeclarationR2C4 -> protocolDeclarationR3C4 [weight=100000000]
    rank = same {protocolDeclarationR2C1 -> protocolDeclarationR2C4}
    protocolDeclarationR1C1 -> protocolDeclarationR2C1 [weight=100000000]
    protocolDeclarationR1C5 [label = <DGW<br/>ALT <br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "protocol", "public"]<br/>am []<br/>>]
    protocolDeclarationR2C5 [label = <DGV<br/>N attributes<br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "protocol", "public"]<br/>am []<br/>>]
    protocolDeclarationR3C5 [label = <DGX<br/>END <br/>fi [""]<br/>fo ["fileprivate", "internal", "open", "package", "private", "protocol", "public"]<br/>am []<br/>>]
    protocolDeclarationR2C5 -> protocolDeclarationR3C5 [weight=100000000]
    protocolDeclarationR1C5 -> protocolDeclarationR2C5 [weight=100000000]
    rank = same {protocolDeclarationR1C1 -> protocolDeclarationR1C5}
    protocolDeclarationR0C1 -> protocolDeclarationR1C1 [weight=100000000]
    rank = same {protocolDeclarationR0C0 -> protocolDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolDeclarationR0C1 -> protocolDeclarationR0C2}
    rank = same {protocolDeclarationR0C2 -> protocolDeclarationR0C3}
    rank = same {protocolDeclarationR0C3 -> protocolDeclarationR0C4}
    rank = same {protocolDeclarationR0C4 -> protocolDeclarationR0C5}
    protocolDeclarationR0C0 -> protocolDeclarationR1C0 [weight=100000000]
    rank = same {protocolDeclarationR1C0 -> protocolDeclarationR1C1}
    protocolDeclarationR0C5 -> protocolDeclarationR1C5 [weight=100000000]
    protocolDeclarationR1C0 -> protocolDeclarationR2C0 [weight=100000000]
    rank = same {protocolDeclarationR2C0 -> protocolDeclarationR2C1}
    protocolDeclarationR2C0 -> protocolDeclarationR3C0 [weight=100000000]
    rank = same {protocolDeclarationR3C0 -> protocolDeclarationR3C1}
    rank = same {protocolDeclarationR3C1 -> protocolDeclarationR3C2}
    rank = same {protocolDeclarationR3C2 -> protocolDeclarationR3C3}
    rank = same {protocolDeclarationR3C3 -> protocolDeclarationR3C4}
    protocolDeclarationR3C0 -> protocolDeclarationR4C0 [weight=100000000]
    rank = same {protocolDeclarationR4C0 -> protocolDeclarationR4C1}
    protocolDeclarationR3C2 -> protocolDeclarationR4C2 [weight=100000000]
    rank = same {protocolDeclarationR4C1 -> protocolDeclarationR4C2}
    protocolDeclarationR3C3 -> protocolDeclarationR4C3 [weight=100000000]
    rank = same {protocolDeclarationR4C2 -> protocolDeclarationR4C3}
    rank = same {protocolDeclarationR4C3 -> protocolDeclarationR4C4}
    protocolDeclarationR3C5 -> protocolDeclarationR4C5 [weight=100000000]
    rank = same {protocolDeclarationR4C4 -> protocolDeclarationR4C5}
    protocolDeclarationR4C0 -> protocolDeclarationR5C0 [weight=100000000]
    rank = same {protocolDeclarationR5C0 -> protocolDeclarationR5C1}
    protocolDeclarationR4C3 -> protocolDeclarationR5C3 [weight=100000000]
    protocolDeclarationR4C4 -> protocolDeclarationR5C4 [weight=100000000]
    rank = same {protocolDeclarationR5C3 -> protocolDeclarationR5C4}
    protocolDeclarationR4C5 -> protocolDeclarationR5C5 [weight=100000000]
    rank = same {protocolDeclarationR5C4 -> protocolDeclarationR5C5}
    protocolDeclarationR5C0 -> protocolDeclarationR6C0 [weight=100000000]
    rank = same {protocolDeclarationR6C0 -> protocolDeclarationR6C1}
    protocolDeclarationR5C4 -> protocolDeclarationR6C4 [weight=100000000]
    rank = same {protocolDeclarationR6C3 -> protocolDeclarationR6C4}
    protocolDeclarationR5C5 -> protocolDeclarationR6C5 [weight=100000000]
    rank = same {protocolDeclarationR6C4 -> protocolDeclarationR6C5}
    protocolDeclarationR6C0 -> protocolDeclarationR7C0 [weight=100000000]
    rank = same {protocolDeclarationR7C0 -> protocolDeclarationR7C1}
    protocolDeclarationR6C4 -> protocolDeclarationR7C4 [weight=100000000]
    rank = same {protocolDeclarationR7C3 -> protocolDeclarationR7C4}
    protocolDeclarationR6C5 -> protocolDeclarationR7C5 [weight=100000000]
    rank = same {protocolDeclarationR7C4 -> protocolDeclarationR7C5}
    protocolDeclarationR7C0 -> protocolDeclarationR8C0 [weight=100000000]
    rank = same {protocolDeclarationR8C0 -> protocolDeclarationR8C1}
    protocolDeclarationR7C3 -> protocolDeclarationR8C3 [weight=100000000]
    rank = same {protocolDeclarationR8C2 -> protocolDeclarationR8C3}
    protocolDeclarationR7C4 -> protocolDeclarationR8C4 [weight=100000000]
    rank = same {protocolDeclarationR8C3 -> protocolDeclarationR8C4}
    protocolDeclarationR7C5 -> protocolDeclarationR8C5 [weight=100000000]
    rank = same {protocolDeclarationR8C4 -> protocolDeclarationR8C5}
  }
  subgraph clusterattributes {
    node [shape = box]
    label = <attributes = attribute [ attributes ] .>
    labeljust = l
    attributesR0C0 [label = <EGM<br/>N attributes<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR0C1 [label = <EGF<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR1C1 [label = <EGG<br/>N attribute<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR2C1 [label = <EGK<br/>OPT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am ["@"]<br/>>]
    attributesR3C1 [label = <EGL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR2C1 -> attributesR3C1 [weight=100000000]
    attributesR2C2 [label = <EGI<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR3C2 [label = <EGH<br/>N attributes<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR4C2 [label = <EGJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributesR3C2 -> attributesR4C2 [weight=100000000]
    attributesR2C2 -> attributesR3C2 [weight=100000000]
    rank = same {attributesR2C1 -> attributesR2C2}
    attributesR1C1 -> attributesR2C1 [weight=100000000]
    attributesR0C1 -> attributesR1C1 [weight=100000000]
    rank = same {attributesR0C0 -> attributesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {attributesR0C1 -> attributesR0C2}
    attributesR0C0 -> attributesR1C0 [weight=100000000]
    rank = same {attributesR1C0 -> attributesR1C1}
    attributesR0C2 -> attributesR1C2 [weight=100000000]
    rank = same {attributesR1C1 -> attributesR1C2}
    attributesR1C0 -> attributesR2C0 [weight=100000000]
    rank = same {attributesR2C0 -> attributesR2C1}
    attributesR1C2 -> attributesR2C2 [weight=100000000]
    attributesR2C0 -> attributesR3C0 [weight=100000000]
    rank = same {attributesR3C0 -> attributesR3C1}
    attributesR3C0 -> attributesR4C0 [weight=100000000]
    attributesR3C1 -> attributesR4C1 [weight=100000000]
    rank = same {attributesR4C0 -> attributesR4C1}
    rank = same {attributesR4C1 -> attributesR4C2}
  }
  subgraph clusterinnerBalancedTokens {
    node [shape = box]
    label = <innerBalancedTokens = "innerBalancedToken" [ innerBalancedTokens ] .>
    labeljust = l
    innerBalancedTokensR0C0 [label = <EGV<br/>N innerBalancedTokens<br/>fi ["innerBalancedToken"]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR0C1 [label = <EGO<br/>ALT <br/>fi ["innerBalancedToken"]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR1C1 [label = <EGP<br/>T "innerBalancedToken"<br/>fi ["innerBalancedToken"]<br/>fo ["innerBalancedToken"]<br/>am []<br/>>]
    innerBalancedTokensR2C1 [label = <EGT<br/>OPT <br/>fi ["", "innerBalancedToken"]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR3C1 [label = <EGU<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR2C1 -> innerBalancedTokensR3C1 [weight=100000000]
    innerBalancedTokensR2C2 [label = <EGR<br/>ALT <br/>fi ["innerBalancedToken"]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR3C2 [label = <EGQ<br/>N innerBalancedTokens<br/>fi ["innerBalancedToken"]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR4C2 [label = <EGS<br/>END <br/>fi [""]<br/>fo []<br/>am []<br/>>]
    innerBalancedTokensR3C2 -> innerBalancedTokensR4C2 [weight=100000000]
    innerBalancedTokensR2C2 -> innerBalancedTokensR3C2 [weight=100000000]
    rank = same {innerBalancedTokensR2C1 -> innerBalancedTokensR2C2}
    innerBalancedTokensR1C1 -> innerBalancedTokensR2C1 [weight=100000000]
    innerBalancedTokensR0C1 -> innerBalancedTokensR1C1 [weight=100000000]
    rank = same {innerBalancedTokensR0C0 -> innerBalancedTokensR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {innerBalancedTokensR0C1 -> innerBalancedTokensR0C2}
    innerBalancedTokensR0C0 -> innerBalancedTokensR1C0 [weight=100000000]
    rank = same {innerBalancedTokensR1C0 -> innerBalancedTokensR1C1}
    innerBalancedTokensR0C2 -> innerBalancedTokensR1C2 [weight=100000000]
    rank = same {innerBalancedTokensR1C1 -> innerBalancedTokensR1C2}
    innerBalancedTokensR1C0 -> innerBalancedTokensR2C0 [weight=100000000]
    rank = same {innerBalancedTokensR2C0 -> innerBalancedTokensR2C1}
    innerBalancedTokensR1C2 -> innerBalancedTokensR2C2 [weight=100000000]
    innerBalancedTokensR2C0 -> innerBalancedTokensR3C0 [weight=100000000]
    rank = same {innerBalancedTokensR3C0 -> innerBalancedTokensR3C1}
    innerBalancedTokensR3C0 -> innerBalancedTokensR4C0 [weight=100000000]
    innerBalancedTokensR3C1 -> innerBalancedTokensR4C1 [weight=100000000]
    rank = same {innerBalancedTokensR4C0 -> innerBalancedTokensR4C1}
    rank = same {innerBalancedTokensR4C1 -> innerBalancedTokensR4C2}
  }
  subgraph clusterplatformName {
    node [shape = box]
    label = <platformName = "iOS" | "iOSApplicationExtension" | "macOS" | "macOSApplicationExtension" | "macCatalyst" | "macCatalystApplicationExtension" | "watchOS" | "watchOSApplicationExtension" | "tvOS" | "tvOSApplicationExtension" | "visionOS" | "visionOSApplicationExtension" .>
    labeljust = l
    platformNameR0C0 [label = <BWK<br/>N platformName<br/>fi ["iOS", "iOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "macOS", "macOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "visionOS", "visionOSApplicationExtension", "watchOS", "watchOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR0C1 [label = <BWE<br/>ALT <br/>fi ["iOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C1 [label = <BWF<br/>T "iOS"<br/>fi ["iOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C1 [label = <BWG<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C1 -> platformNameR2C1 [weight=100000000]
    platformNameR0C1 -> platformNameR1C1 [weight=100000000]
    platformNameR0C2 [label = <BWH<br/>ALT <br/>fi ["iOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C2 [label = <BWI<br/>T "iOSApplicationExtension"<br/>fi ["iOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C2 [label = <BWJ<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C2 -> platformNameR2C2 [weight=100000000]
    platformNameR0C2 -> platformNameR1C2 [weight=100000000]
    platformNameR0C3 [label = <BWL<br/>ALT <br/>fi ["macOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C3 [label = <BWM<br/>T "macOS"<br/>fi ["macOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C3 [label = <BWN<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C3 -> platformNameR2C3 [weight=100000000]
    platformNameR0C3 -> platformNameR1C3 [weight=100000000]
    platformNameR0C4 [label = <BWO<br/>ALT <br/>fi ["macOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C4 [label = <BWP<br/>T "macOSApplicationExtension"<br/>fi ["macOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C4 [label = <BWQ<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C4 -> platformNameR2C4 [weight=100000000]
    platformNameR0C4 -> platformNameR1C4 [weight=100000000]
    platformNameR0C5 [label = <BWR<br/>ALT <br/>fi ["macCatalyst"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C5 [label = <BWS<br/>T "macCatalyst"<br/>fi ["macCatalyst"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C5 [label = <BWT<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C5 -> platformNameR2C5 [weight=100000000]
    platformNameR0C5 -> platformNameR1C5 [weight=100000000]
    platformNameR0C6 [label = <BWU<br/>ALT <br/>fi ["macCatalystApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C6 [label = <BWV<br/>T "macCatalystApplicationExtension"<br/>fi ["macCatalystApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C6 [label = <BWW<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C6 -> platformNameR2C6 [weight=100000000]
    platformNameR0C6 -> platformNameR1C6 [weight=100000000]
    platformNameR0C7 [label = <BWX<br/>ALT <br/>fi ["watchOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C7 [label = <BWY<br/>T "watchOS"<br/>fi ["watchOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C7 [label = <BWZ<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C7 -> platformNameR2C7 [weight=100000000]
    platformNameR0C7 -> platformNameR1C7 [weight=100000000]
    platformNameR0C8 [label = <BXA<br/>ALT <br/>fi ["watchOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C8 [label = <BXB<br/>T "watchOSApplicationExtension"<br/>fi ["watchOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C8 [label = <BXC<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C8 -> platformNameR2C8 [weight=100000000]
    platformNameR0C8 -> platformNameR1C8 [weight=100000000]
    platformNameR0C9 [label = <BXD<br/>ALT <br/>fi ["tvOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C9 [label = <BXE<br/>T "tvOS"<br/>fi ["tvOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C9 [label = <BXF<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C9 -> platformNameR2C9 [weight=100000000]
    platformNameR0C9 -> platformNameR1C9 [weight=100000000]
    platformNameR0C10 [label = <BXG<br/>ALT <br/>fi ["tvOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C10 [label = <BXH<br/>T "tvOSApplicationExtension"<br/>fi ["tvOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C10 [label = <BXI<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C10 -> platformNameR2C10 [weight=100000000]
    platformNameR0C10 -> platformNameR1C10 [weight=100000000]
    platformNameR0C11 [label = <BXJ<br/>ALT <br/>fi ["visionOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C11 [label = <BXK<br/>T "visionOS"<br/>fi ["visionOS"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C11 [label = <BXL<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C11 -> platformNameR2C11 [weight=100000000]
    platformNameR0C11 -> platformNameR1C11 [weight=100000000]
    platformNameR0C12 [label = <BXM<br/>ALT <br/>fi ["visionOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C12 [label = <BXN<br/>T "visionOSApplicationExtension"<br/>fi ["visionOSApplicationExtension"]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR2C12 [label = <BXO<br/>END <br/>fi [""]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformNameR1C12 -> platformNameR2C12 [weight=100000000]
    platformNameR0C12 -> platformNameR1C12 [weight=100000000]
    rank = same {platformNameR0C11 -> platformNameR0C12}
    rank = same {platformNameR0C10 -> platformNameR0C11}
    rank = same {platformNameR0C9 -> platformNameR0C10}
    rank = same {platformNameR0C8 -> platformNameR0C9}
    rank = same {platformNameR0C7 -> platformNameR0C8}
    rank = same {platformNameR0C6 -> platformNameR0C7}
    rank = same {platformNameR0C5 -> platformNameR0C6}
    rank = same {platformNameR0C4 -> platformNameR0C5}
    rank = same {platformNameR0C3 -> platformNameR0C4}
    rank = same {platformNameR0C2 -> platformNameR0C3}
    rank = same {platformNameR0C1 -> platformNameR0C2}
    rank = same {platformNameR0C0 -> platformNameR0C1}
    node [style = invis]
    edge [style = invis]
    platformNameR0C0 -> platformNameR1C0 [weight=100000000]
    rank = same {platformNameR1C0 -> platformNameR1C1}
    platformNameR1C0 -> platformNameR2C0 [weight=100000000]
    rank = same {platformNameR2C0 -> platformNameR2C1}
  }
  subgraph clusterdictionaryLiteralItems {
    node [shape = box]
    label = <dictionaryLiteralItems = dictionaryLiteralItem [ "," ] | dictionaryLiteralItem "," dictionaryLiteralItems .>
    labeljust = l
    dictionaryLiteralItemsR0C0 [label = <WY<br/>N dictionaryLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am ["try"]<br/>>]
    dictionaryLiteralItemsR0C1 [label = <WM<br/>ALT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR1C1 [label = <WN<br/>N dictionaryLiteralItem<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR2C1 [label = <WR<br/>OPT <br/>fi ["", ","]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR3C1 [label = <WS<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR2C1 -> dictionaryLiteralItemsR3C1 [weight=100000000]
    dictionaryLiteralItemsR2C2 [label = <WP<br/>ALT <br/>fi [","]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR3C2 [label = <WO<br/>T ","<br/>fi [","]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR4C2 [label = <WQ<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR3C2 -> dictionaryLiteralItemsR4C2 [weight=100000000]
    dictionaryLiteralItemsR2C2 -> dictionaryLiteralItemsR3C2 [weight=100000000]
    rank = same {dictionaryLiteralItemsR2C1 -> dictionaryLiteralItemsR2C2}
    dictionaryLiteralItemsR1C1 -> dictionaryLiteralItemsR2C1 [weight=100000000]
    dictionaryLiteralItemsR0C1 -> dictionaryLiteralItemsR1C1 [weight=100000000]
    dictionaryLiteralItemsR0C3 [label = <WT<br/>ALT <br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR1C3 [label = <WU<br/>N dictionaryLiteralItem<br/>fi ["", "try"]<br/>fo [","]<br/>am []<br/>>]
    dictionaryLiteralItemsR2C3 [label = <WV<br/>T ","<br/>fi [","]<br/>fo ["]", "try"]<br/>am []<br/>>]
    dictionaryLiteralItemsR3C3 [label = <WW<br/>N dictionaryLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR4C3 [label = <WX<br/>END <br/>fi [""]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralItemsR3C3 -> dictionaryLiteralItemsR4C3 [weight=100000000]
    dictionaryLiteralItemsR2C3 -> dictionaryLiteralItemsR3C3 [weight=100000000]
    dictionaryLiteralItemsR1C3 -> dictionaryLiteralItemsR2C3 [weight=100000000]
    dictionaryLiteralItemsR0C3 -> dictionaryLiteralItemsR1C3 [weight=100000000]
    rank = same {dictionaryLiteralItemsR0C1 -> dictionaryLiteralItemsR0C3}
    rank = same {dictionaryLiteralItemsR0C0 -> dictionaryLiteralItemsR0C1}
    node [style = invis]
    edge [style = invis]
    dictionaryLiteralItemsR0C0 -> dictionaryLiteralItemsR1C0 [weight=100000000]
    rank = same {dictionaryLiteralItemsR1C0 -> dictionaryLiteralItemsR1C1}
    rank = same {dictionaryLiteralItemsR1C1 -> dictionaryLiteralItemsR1C2}
    rank = same {dictionaryLiteralItemsR1C2 -> dictionaryLiteralItemsR1C3}
    dictionaryLiteralItemsR1C0 -> dictionaryLiteralItemsR2C0 [weight=100000000]
    rank = same {dictionaryLiteralItemsR2C0 -> dictionaryLiteralItemsR2C1}
    dictionaryLiteralItemsR1C2 -> dictionaryLiteralItemsR2C2 [weight=100000000]
    dictionaryLiteralItemsR2C0 -> dictionaryLiteralItemsR3C0 [weight=100000000]
    rank = same {dictionaryLiteralItemsR3C0 -> dictionaryLiteralItemsR3C1}
    dictionaryLiteralItemsR3C0 -> dictionaryLiteralItemsR4C0 [weight=100000000]
    dictionaryLiteralItemsR3C1 -> dictionaryLiteralItemsR4C1 [weight=100000000]
    rank = same {dictionaryLiteralItemsR4C0 -> dictionaryLiteralItemsR4C1}
    rank = same {dictionaryLiteralItemsR4C1 -> dictionaryLiteralItemsR4C2}
  }
  subgraph clusterfunctionTypeArgument {
    node [shape = box]
    label = <functionTypeArgument = [ attributes ] [ "inout" ] type | argumentLabel typeAnnotation .>
    labeljust = l
    functionTypeArgumentR0C0 [label = <KH<br/>N functionTypeArgument<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR0C1 [label = <JS<br/>ALT <br/>fi ["", "@"]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR1C1 [label = <JW<br/>OPT <br/>fi ["", "@"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am ["@"]<br/>>]
    functionTypeArgumentR2C1 [label = <KA<br/>OPT <br/>fi ["", "inout"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR3C1 [label = <KB<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR4C1 [label = <KC<br/>END <br/>fi [""]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR3C1 -> functionTypeArgumentR4C1 [weight=100000000]
    functionTypeArgumentR2C1 -> functionTypeArgumentR3C1 [weight=100000000]
    functionTypeArgumentR2C2 [label = <JY<br/>ALT <br/>fi ["inout"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR3C2 [label = <JX<br/>T "inout"<br/>fi ["inout"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR4C2 [label = <JZ<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR3C2 -> functionTypeArgumentR4C2 [weight=100000000]
    functionTypeArgumentR2C2 -> functionTypeArgumentR3C2 [weight=100000000]
    rank = same {functionTypeArgumentR2C1 -> functionTypeArgumentR2C2}
    functionTypeArgumentR1C1 -> functionTypeArgumentR2C1 [weight=100000000]
    functionTypeArgumentR1C3 [label = <JU<br/>ALT <br/>fi ["@"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR2C3 [label = <JT<br/>N attributes<br/>fi ["@"]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR3C3 [label = <JV<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "inout", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    functionTypeArgumentR2C3 -> functionTypeArgumentR3C3 [weight=100000000]
    functionTypeArgumentR1C3 -> functionTypeArgumentR2C3 [weight=100000000]
    rank = same {functionTypeArgumentR1C1 -> functionTypeArgumentR1C3}
    functionTypeArgumentR0C1 -> functionTypeArgumentR1C1 [weight=100000000]
    functionTypeArgumentR0C4 [label = <KD<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR1C4 [label = <KE<br/>N argumentLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    functionTypeArgumentR2C4 [label = <KF<br/>N typeAnnotation<br/>fi [":"]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR3C4 [label = <KG<br/>END <br/>fi [""]<br/>fo [")", ",", "..."]<br/>am []<br/>>]
    functionTypeArgumentR2C4 -> functionTypeArgumentR3C4 [weight=100000000]
    functionTypeArgumentR1C4 -> functionTypeArgumentR2C4 [weight=100000000]
    functionTypeArgumentR0C4 -> functionTypeArgumentR1C4 [weight=100000000]
    rank = same {functionTypeArgumentR0C1 -> functionTypeArgumentR0C4}
    rank = same {functionTypeArgumentR0C0 -> functionTypeArgumentR0C1}
    node [style = invis]
    edge [style = invis]
    functionTypeArgumentR0C0 -> functionTypeArgumentR1C0 [weight=100000000]
    rank = same {functionTypeArgumentR1C0 -> functionTypeArgumentR1C1}
    functionTypeArgumentR1C0 -> functionTypeArgumentR2C0 [weight=100000000]
    rank = same {functionTypeArgumentR2C0 -> functionTypeArgumentR2C1}
    functionTypeArgumentR2C0 -> functionTypeArgumentR3C0 [weight=100000000]
    rank = same {functionTypeArgumentR3C0 -> functionTypeArgumentR3C1}
    functionTypeArgumentR3C0 -> functionTypeArgumentR4C0 [weight=100000000]
    rank = same {functionTypeArgumentR4C0 -> functionTypeArgumentR4C1}
    functionTypeArgumentR3C3 -> functionTypeArgumentR4C3 [weight=100000000]
    rank = same {functionTypeArgumentR4C2 -> functionTypeArgumentR4C3}
    functionTypeArgumentR3C4 -> functionTypeArgumentR4C4 [weight=100000000]
    rank = same {functionTypeArgumentR4C3 -> functionTypeArgumentR4C4}
  }
  subgraph clusterfunctionType {
    node [shape = box]
    label = <functionType = [ attributes ] functionTypeArgumentClause [ "async" ] [ throwsClause ] "&gt;" type .>
    labeljust = l
    functionTypeR0C0 [label = <IU<br/>N functionType<br/>fi ["", "@"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    functionTypeR0C1 [label = <ID<br/>ALT <br/>fi ["", "@"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    functionTypeR1C1 [label = <IH<br/>OPT <br/>fi ["", "@"]<br/>fo ["("]<br/>am []<br/>>]
    functionTypeR2C1 [label = <II<br/>N functionTypeArgumentClause<br/>fi ["("]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeR3C1 [label = <IM<br/>OPT <br/>fi ["", "async"]<br/>fo ["&gt;", "throws"]<br/>am []<br/>>]
    functionTypeR4C1 [label = <IQ<br/>OPT <br/>fi ["", "throws"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    functionTypeR5C1 [label = <IR<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionTypeR6C1 [label = <IS<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    functionTypeR7C1 [label = <IT<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionTypeR6C1 -> functionTypeR7C1 [weight=100000000]
    functionTypeR5C1 -> functionTypeR6C1 [weight=100000000]
    functionTypeR4C1 -> functionTypeR5C1 [weight=100000000]
    functionTypeR4C2 [label = <IO<br/>ALT <br/>fi ["throws"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    functionTypeR5C2 [label = <IN<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    functionTypeR6C2 [label = <IP<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    functionTypeR5C2 -> functionTypeR6C2 [weight=100000000]
    functionTypeR4C2 -> functionTypeR5C2 [weight=100000000]
    rank = same {functionTypeR4C1 -> functionTypeR4C2}
    functionTypeR3C1 -> functionTypeR4C1 [weight=100000000]
    functionTypeR3C3 [label = <IK<br/>ALT <br/>fi ["async"]<br/>fo ["&gt;", "throws"]<br/>am []<br/>>]
    functionTypeR4C3 [label = <IJ<br/>T "async"<br/>fi ["async"]<br/>fo ["&gt;", "throws"]<br/>am []<br/>>]
    functionTypeR5C3 [label = <IL<br/>END <br/>fi [""]<br/>fo ["&gt;", "throws"]<br/>am []<br/>>]
    functionTypeR4C3 -> functionTypeR5C3 [weight=100000000]
    functionTypeR3C3 -> functionTypeR4C3 [weight=100000000]
    rank = same {functionTypeR3C1 -> functionTypeR3C3}
    functionTypeR2C1 -> functionTypeR3C1 [weight=100000000]
    functionTypeR1C1 -> functionTypeR2C1 [weight=100000000]
    functionTypeR1C4 [label = <IF<br/>ALT <br/>fi ["@"]<br/>fo ["("]<br/>am []<br/>>]
    functionTypeR2C4 [label = <IE<br/>N attributes<br/>fi ["@"]<br/>fo ["("]<br/>am []<br/>>]
    functionTypeR3C4 [label = <IG<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    functionTypeR2C4 -> functionTypeR3C4 [weight=100000000]
    functionTypeR1C4 -> functionTypeR2C4 [weight=100000000]
    rank = same {functionTypeR1C1 -> functionTypeR1C4}
    functionTypeR0C1 -> functionTypeR1C1 [weight=100000000]
    rank = same {functionTypeR0C0 -> functionTypeR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionTypeR0C1 -> functionTypeR0C2}
    rank = same {functionTypeR0C2 -> functionTypeR0C3}
    rank = same {functionTypeR0C3 -> functionTypeR0C4}
    functionTypeR0C0 -> functionTypeR1C0 [weight=100000000]
    rank = same {functionTypeR1C0 -> functionTypeR1C1}
    functionTypeR0C4 -> functionTypeR1C4 [weight=100000000]
    functionTypeR1C0 -> functionTypeR2C0 [weight=100000000]
    rank = same {functionTypeR2C0 -> functionTypeR2C1}
    rank = same {functionTypeR2C1 -> functionTypeR2C2}
    rank = same {functionTypeR2C2 -> functionTypeR2C3}
    rank = same {functionTypeR2C3 -> functionTypeR2C4}
    functionTypeR2C0 -> functionTypeR3C0 [weight=100000000]
    rank = same {functionTypeR3C0 -> functionTypeR3C1}
    functionTypeR2C3 -> functionTypeR3C3 [weight=100000000]
    functionTypeR3C0 -> functionTypeR4C0 [weight=100000000]
    rank = same {functionTypeR4C0 -> functionTypeR4C1}
    functionTypeR3C4 -> functionTypeR4C4 [weight=100000000]
    rank = same {functionTypeR4C3 -> functionTypeR4C4}
    functionTypeR4C0 -> functionTypeR5C0 [weight=100000000]
    rank = same {functionTypeR5C0 -> functionTypeR5C1}
    functionTypeR4C4 -> functionTypeR5C4 [weight=100000000]
    rank = same {functionTypeR5C3 -> functionTypeR5C4}
    functionTypeR5C0 -> functionTypeR6C0 [weight=100000000]
    rank = same {functionTypeR6C0 -> functionTypeR6C1}
    functionTypeR5C3 -> functionTypeR6C3 [weight=100000000]
    rank = same {functionTypeR6C2 -> functionTypeR6C3}
    functionTypeR5C4 -> functionTypeR6C4 [weight=100000000]
    rank = same {functionTypeR6C3 -> functionTypeR6C4}
    functionTypeR6C0 -> functionTypeR7C0 [weight=100000000]
    rank = same {functionTypeR7C0 -> functionTypeR7C1}
    functionTypeR6C2 -> functionTypeR7C2 [weight=100000000]
    rank = same {functionTypeR7C1 -> functionTypeR7C2}
    functionTypeR6C3 -> functionTypeR7C3 [weight=100000000]
    rank = same {functionTypeR7C2 -> functionTypeR7C3}
    functionTypeR6C4 -> functionTypeR7C4 [weight=100000000]
    rank = same {functionTypeR7C3 -> functionTypeR7C4}
  }
  subgraph clusterprotocolMethodDeclaration {
    node [shape = box]
    label = <protocolMethodDeclaration = functionHead functionName [ genericParameterClause ] functionSignature [ genericWhereClause ] .>
    labeljust = l
    protocolMethodDeclarationR0C0 [label = <DKF<br/>N protocolMethodDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMethodDeclarationR0C1 [label = <DJS<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMethodDeclarationR1C1 [label = <DJT<br/>N functionHead<br/>fi ["", "@"]<br/>fo ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>am []<br/>>]
    protocolMethodDeclarationR2C1 [label = <DJU<br/>N functionName<br/>fi ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    protocolMethodDeclarationR3C1 [label = <DJY<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolMethodDeclarationR4C1 [label = <DJZ<br/>N functionSignature<br/>fi ["("]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR5C1 [label = <DKD<br/>OPT <br/>fi ["", "where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR6C1 [label = <DKE<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR5C1 -> protocolMethodDeclarationR6C1 [weight=100000000]
    protocolMethodDeclarationR5C2 [label = <DKB<br/>ALT <br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR6C2 [label = <DKA<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR7C2 [label = <DKC<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMethodDeclarationR6C2 -> protocolMethodDeclarationR7C2 [weight=100000000]
    protocolMethodDeclarationR5C2 -> protocolMethodDeclarationR6C2 [weight=100000000]
    rank = same {protocolMethodDeclarationR5C1 -> protocolMethodDeclarationR5C2}
    protocolMethodDeclarationR4C1 -> protocolMethodDeclarationR5C1 [weight=100000000]
    protocolMethodDeclarationR3C1 -> protocolMethodDeclarationR4C1 [weight=100000000]
    protocolMethodDeclarationR3C3 [label = <DJW<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolMethodDeclarationR4C3 [label = <DJV<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolMethodDeclarationR5C3 [label = <DJX<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    protocolMethodDeclarationR4C3 -> protocolMethodDeclarationR5C3 [weight=100000000]
    protocolMethodDeclarationR3C3 -> protocolMethodDeclarationR4C3 [weight=100000000]
    rank = same {protocolMethodDeclarationR3C1 -> protocolMethodDeclarationR3C3}
    protocolMethodDeclarationR2C1 -> protocolMethodDeclarationR3C1 [weight=100000000]
    protocolMethodDeclarationR1C1 -> protocolMethodDeclarationR2C1 [weight=100000000]
    protocolMethodDeclarationR0C1 -> protocolMethodDeclarationR1C1 [weight=100000000]
    rank = same {protocolMethodDeclarationR0C0 -> protocolMethodDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolMethodDeclarationR0C1 -> protocolMethodDeclarationR0C2}
    rank = same {protocolMethodDeclarationR0C2 -> protocolMethodDeclarationR0C3}
    protocolMethodDeclarationR0C0 -> protocolMethodDeclarationR1C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR1C0 -> protocolMethodDeclarationR1C1}
    protocolMethodDeclarationR0C2 -> protocolMethodDeclarationR1C2 [weight=100000000]
    rank = same {protocolMethodDeclarationR1C1 -> protocolMethodDeclarationR1C2}
    protocolMethodDeclarationR0C3 -> protocolMethodDeclarationR1C3 [weight=100000000]
    rank = same {protocolMethodDeclarationR1C2 -> protocolMethodDeclarationR1C3}
    protocolMethodDeclarationR1C0 -> protocolMethodDeclarationR2C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR2C0 -> protocolMethodDeclarationR2C1}
    protocolMethodDeclarationR1C2 -> protocolMethodDeclarationR2C2 [weight=100000000]
    rank = same {protocolMethodDeclarationR2C1 -> protocolMethodDeclarationR2C2}
    protocolMethodDeclarationR1C3 -> protocolMethodDeclarationR2C3 [weight=100000000]
    rank = same {protocolMethodDeclarationR2C2 -> protocolMethodDeclarationR2C3}
    protocolMethodDeclarationR2C0 -> protocolMethodDeclarationR3C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR3C0 -> protocolMethodDeclarationR3C1}
    protocolMethodDeclarationR2C3 -> protocolMethodDeclarationR3C3 [weight=100000000]
    protocolMethodDeclarationR3C0 -> protocolMethodDeclarationR4C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR4C0 -> protocolMethodDeclarationR4C1}
    rank = same {protocolMethodDeclarationR4C1 -> protocolMethodDeclarationR4C2}
    rank = same {protocolMethodDeclarationR4C2 -> protocolMethodDeclarationR4C3}
    protocolMethodDeclarationR4C0 -> protocolMethodDeclarationR5C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR5C0 -> protocolMethodDeclarationR5C1}
    protocolMethodDeclarationR4C2 -> protocolMethodDeclarationR5C2 [weight=100000000]
    protocolMethodDeclarationR5C0 -> protocolMethodDeclarationR6C0 [weight=100000000]
    rank = same {protocolMethodDeclarationR6C0 -> protocolMethodDeclarationR6C1}
    protocolMethodDeclarationR5C3 -> protocolMethodDeclarationR6C3 [weight=100000000]
    rank = same {protocolMethodDeclarationR6C2 -> protocolMethodDeclarationR6C3}
    protocolMethodDeclarationR6C0 -> protocolMethodDeclarationR7C0 [weight=100000000]
    protocolMethodDeclarationR6C1 -> protocolMethodDeclarationR7C1 [weight=100000000]
    rank = same {protocolMethodDeclarationR7C0 -> protocolMethodDeclarationR7C1}
    rank = same {protocolMethodDeclarationR7C1 -> protocolMethodDeclarationR7C2}
    protocolMethodDeclarationR6C3 -> protocolMethodDeclarationR7C3 [weight=100000000]
    rank = same {protocolMethodDeclarationR7C2 -> protocolMethodDeclarationR7C3}
  }
  subgraph clusterprecedenceGroupAssociativity {
    node [shape = box]
    label = <precedenceGroupAssociativity = "associativity" ":" "left" | "associativity" ":" "right" | "associativity" ":" "none" .>
    labeljust = l
    precedenceGroupAssociativityR0C0 [label = <DZD<br/>N precedenceGroupAssociativity<br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am ["associativity"]<br/>>]
    precedenceGroupAssociativityR0C1 [label = <DYY<br/>ALT <br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR1C1 [label = <DYZ<br/>T "associativity"<br/>fi ["associativity"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupAssociativityR2C1 [label = <DZA<br/>T ":"<br/>fi [":"]<br/>fo ["left"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C1 [label = <DZB<br/>T "left"<br/>fi ["left"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR4C1 [label = <DZC<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C1 -> precedenceGroupAssociativityR4C1 [weight=100000000]
    precedenceGroupAssociativityR2C1 -> precedenceGroupAssociativityR3C1 [weight=100000000]
    precedenceGroupAssociativityR1C1 -> precedenceGroupAssociativityR2C1 [weight=100000000]
    precedenceGroupAssociativityR0C1 -> precedenceGroupAssociativityR1C1 [weight=100000000]
    precedenceGroupAssociativityR0C2 [label = <DZE<br/>ALT <br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR1C2 [label = <DZF<br/>T "associativity"<br/>fi ["associativity"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupAssociativityR2C2 [label = <DZG<br/>T ":"<br/>fi [":"]<br/>fo ["right"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C2 [label = <DZH<br/>T "right"<br/>fi ["right"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR4C2 [label = <DZI<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C2 -> precedenceGroupAssociativityR4C2 [weight=100000000]
    precedenceGroupAssociativityR2C2 -> precedenceGroupAssociativityR3C2 [weight=100000000]
    precedenceGroupAssociativityR1C2 -> precedenceGroupAssociativityR2C2 [weight=100000000]
    precedenceGroupAssociativityR0C2 -> precedenceGroupAssociativityR1C2 [weight=100000000]
    precedenceGroupAssociativityR0C3 [label = <DZJ<br/>ALT <br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR1C3 [label = <DZK<br/>T "associativity"<br/>fi ["associativity"]<br/>fo [":"]<br/>am []<br/>>]
    precedenceGroupAssociativityR2C3 [label = <DZL<br/>T ":"<br/>fi [":"]<br/>fo ["none"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C3 [label = <DZM<br/>T "none"<br/>fi ["none"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR4C3 [label = <DZN<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAssociativityR3C3 -> precedenceGroupAssociativityR4C3 [weight=100000000]
    precedenceGroupAssociativityR2C3 -> precedenceGroupAssociativityR3C3 [weight=100000000]
    precedenceGroupAssociativityR1C3 -> precedenceGroupAssociativityR2C3 [weight=100000000]
    precedenceGroupAssociativityR0C3 -> precedenceGroupAssociativityR1C3 [weight=100000000]
    rank = same {precedenceGroupAssociativityR0C2 -> precedenceGroupAssociativityR0C3}
    rank = same {precedenceGroupAssociativityR0C1 -> precedenceGroupAssociativityR0C2}
    rank = same {precedenceGroupAssociativityR0C0 -> precedenceGroupAssociativityR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupAssociativityR0C0 -> precedenceGroupAssociativityR1C0 [weight=100000000]
    rank = same {precedenceGroupAssociativityR1C0 -> precedenceGroupAssociativityR1C1}
    precedenceGroupAssociativityR1C0 -> precedenceGroupAssociativityR2C0 [weight=100000000]
    rank = same {precedenceGroupAssociativityR2C0 -> precedenceGroupAssociativityR2C1}
    precedenceGroupAssociativityR2C0 -> precedenceGroupAssociativityR3C0 [weight=100000000]
    rank = same {precedenceGroupAssociativityR3C0 -> precedenceGroupAssociativityR3C1}
    precedenceGroupAssociativityR3C0 -> precedenceGroupAssociativityR4C0 [weight=100000000]
    rank = same {precedenceGroupAssociativityR4C0 -> precedenceGroupAssociativityR4C1}
  }
  subgraph clusterkeyPathComponent {
    node [shape = box]
    label = <keyPathComponent = identifier [ keyPathPostfixes ] | keyPathPostfixes .>
    labeljust = l
    keyPathComponentR0C0 [label = <ALV<br/>N keyPathComponent<br/>fi ["!", "?", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR0C1 [label = <ALL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR1C1 [label = <ALM<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "self", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR2C1 [label = <ALQ<br/>OPT <br/>fi ["", "!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["!", "?", "["]<br/>>]
    keyPathComponentR3C1 [label = <ALR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR2C1 -> keyPathComponentR3C1 [weight=100000000]
    keyPathComponentR2C2 [label = <ALO<br/>ALT <br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR3C2 [label = <ALN<br/>N keyPathPostfixes<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR4C2 [label = <ALP<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR3C2 -> keyPathComponentR4C2 [weight=100000000]
    keyPathComponentR2C2 -> keyPathComponentR3C2 [weight=100000000]
    rank = same {keyPathComponentR2C1 -> keyPathComponentR2C2}
    keyPathComponentR1C1 -> keyPathComponentR2C1 [weight=100000000]
    keyPathComponentR0C1 -> keyPathComponentR1C1 [weight=100000000]
    keyPathComponentR0C3 [label = <ALS<br/>ALT <br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR1C3 [label = <ALT<br/>N keyPathPostfixes<br/>fi ["!", "?", "[", "self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR2C3 [label = <ALU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    keyPathComponentR1C3 -> keyPathComponentR2C3 [weight=100000000]
    keyPathComponentR0C3 -> keyPathComponentR1C3 [weight=100000000]
    rank = same {keyPathComponentR0C1 -> keyPathComponentR0C3}
    rank = same {keyPathComponentR0C0 -> keyPathComponentR0C1}
    node [style = invis]
    edge [style = invis]
    keyPathComponentR0C0 -> keyPathComponentR1C0 [weight=100000000]
    rank = same {keyPathComponentR1C0 -> keyPathComponentR1C1}
    rank = same {keyPathComponentR1C1 -> keyPathComponentR1C2}
    rank = same {keyPathComponentR1C2 -> keyPathComponentR1C3}
    keyPathComponentR1C0 -> keyPathComponentR2C0 [weight=100000000]
    rank = same {keyPathComponentR2C0 -> keyPathComponentR2C1}
    keyPathComponentR1C2 -> keyPathComponentR2C2 [weight=100000000]
    keyPathComponentR2C0 -> keyPathComponentR3C0 [weight=100000000]
    rank = same {keyPathComponentR3C0 -> keyPathComponentR3C1}
    keyPathComponentR2C3 -> keyPathComponentR3C3 [weight=100000000]
    rank = same {keyPathComponentR3C2 -> keyPathComponentR3C3}
    keyPathComponentR3C0 -> keyPathComponentR4C0 [weight=100000000]
    keyPathComponentR3C1 -> keyPathComponentR4C1 [weight=100000000]
    rank = same {keyPathComponentR4C0 -> keyPathComponentR4C1}
    rank = same {keyPathComponentR4C1 -> keyPathComponentR4C2}
    keyPathComponentR3C3 -> keyPathComponentR4C3 [weight=100000000]
    rank = same {keyPathComponentR4C2 -> keyPathComponentR4C3}
  }
  subgraph clusterifExpressionTail {
    node [shape = box]
    label = <ifExpressionTail = "else" ifExpression | "else" "{" statement "}" .>
    labeljust = l
    ifExpressionTailR0C0 [label = <ABT<br/>N ifExpressionTail<br/>fi ["else"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["else"]<br/>>]
    ifExpressionTailR0C1 [label = <ABP<br/>ALT <br/>fi ["else"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR1C1 [label = <ABQ<br/>T "else"<br/>fi ["else"]<br/>fo ["if"]<br/>am []<br/>>]
    ifExpressionTailR2C1 [label = <ABR<br/>N ifExpression<br/>fi ["if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR3C1 [label = <ABS<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR2C1 -> ifExpressionTailR3C1 [weight=100000000]
    ifExpressionTailR1C1 -> ifExpressionTailR2C1 [weight=100000000]
    ifExpressionTailR0C1 -> ifExpressionTailR1C1 [weight=100000000]
    ifExpressionTailR0C2 [label = <ABU<br/>ALT <br/>fi ["else"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR1C2 [label = <ABV<br/>T "else"<br/>fi ["else"]<br/>fo ["{"]<br/>am []<br/>>]
    ifExpressionTailR2C2 [label = <ABW<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    ifExpressionTailR3C2 [label = <ABX<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    ifExpressionTailR4C2 [label = <ABY<br/>T "}"<br/>fi ["}"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR5C2 [label = <ABZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    ifExpressionTailR4C2 -> ifExpressionTailR5C2 [weight=100000000]
    ifExpressionTailR3C2 -> ifExpressionTailR4C2 [weight=100000000]
    ifExpressionTailR2C2 -> ifExpressionTailR3C2 [weight=100000000]
    ifExpressionTailR1C2 -> ifExpressionTailR2C2 [weight=100000000]
    ifExpressionTailR0C2 -> ifExpressionTailR1C2 [weight=100000000]
    rank = same {ifExpressionTailR0C1 -> ifExpressionTailR0C2}
    rank = same {ifExpressionTailR0C0 -> ifExpressionTailR0C1}
    node [style = invis]
    edge [style = invis]
    ifExpressionTailR0C0 -> ifExpressionTailR1C0 [weight=100000000]
    rank = same {ifExpressionTailR1C0 -> ifExpressionTailR1C1}
    ifExpressionTailR1C0 -> ifExpressionTailR2C0 [weight=100000000]
    rank = same {ifExpressionTailR2C0 -> ifExpressionTailR2C1}
    ifExpressionTailR2C0 -> ifExpressionTailR3C0 [weight=100000000]
    rank = same {ifExpressionTailR3C0 -> ifExpressionTailR3C1}
    ifExpressionTailR3C0 -> ifExpressionTailR4C0 [weight=100000000]
    ifExpressionTailR3C1 -> ifExpressionTailR4C1 [weight=100000000]
    rank = same {ifExpressionTailR4C0 -> ifExpressionTailR4C1}
    rank = same {ifExpressionTailR4C1 -> ifExpressionTailR4C2}
    ifExpressionTailR4C0 -> ifExpressionTailR5C0 [weight=100000000]
    ifExpressionTailR4C1 -> ifExpressionTailR5C1 [weight=100000000]
    rank = same {ifExpressionTailR5C0 -> ifExpressionTailR5C1}
    rank = same {ifExpressionTailR5C1 -> ifExpressionTailR5C2}
  }
  subgraph clusterbooleanLiteral {
    node [shape = box]
    label = <booleanLiteral = "true" | "false" .>
    labeljust = l
    booleanLiteralR0C0 [label = <CC<br/>N booleanLiteral<br/>fi ["false", "true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR0C1 [label = <BW<br/>ALT <br/>fi ["true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR1C1 [label = <BX<br/>T "true"<br/>fi ["true"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR2C1 [label = <BY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR1C1 -> booleanLiteralR2C1 [weight=100000000]
    booleanLiteralR0C1 -> booleanLiteralR1C1 [weight=100000000]
    booleanLiteralR0C2 [label = <BZ<br/>ALT <br/>fi ["false"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR1C2 [label = <CA<br/>T "false"<br/>fi ["false"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR2C2 [label = <CB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;&amp;", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "assignment", "associativity", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "higherThan", "if", "implicitParameterName", "in", "infix", "is", "lowerThan", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "||", "}"]<br/>am []<br/>>]
    booleanLiteralR1C2 -> booleanLiteralR2C2 [weight=100000000]
    booleanLiteralR0C2 -> booleanLiteralR1C2 [weight=100000000]
    rank = same {booleanLiteralR0C1 -> booleanLiteralR0C2}
    rank = same {booleanLiteralR0C0 -> booleanLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    booleanLiteralR0C0 -> booleanLiteralR1C0 [weight=100000000]
    rank = same {booleanLiteralR1C0 -> booleanLiteralR1C1}
    booleanLiteralR1C0 -> booleanLiteralR2C0 [weight=100000000]
    rank = same {booleanLiteralR2C0 -> booleanLiteralR2C1}
  }
  subgraph clusterifDirective {
    node [shape = box]
    label = <ifDirective = "#if" .>
    labeljust = l
    ifDirectiveR0C0 [label = <BNU<br/>N ifDirective<br/>fi ["#if"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    ifDirectiveR0C1 [label = <BNR<br/>ALT <br/>fi ["#if"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    ifDirectiveR1C1 [label = <BNS<br/>T "#if"<br/>fi ["#if"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    ifDirectiveR2C1 [label = <BNT<br/>END <br/>fi [""]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    ifDirectiveR1C1 -> ifDirectiveR2C1 [weight=100000000]
    ifDirectiveR0C1 -> ifDirectiveR1C1 [weight=100000000]
    rank = same {ifDirectiveR0C0 -> ifDirectiveR0C1}
    node [style = invis]
    edge [style = invis]
    ifDirectiveR0C0 -> ifDirectiveR1C0 [weight=100000000]
    rank = same {ifDirectiveR1C0 -> ifDirectiveR1C1}
    ifDirectiveR1C0 -> ifDirectiveR2C0 [weight=100000000]
    rank = same {ifDirectiveR2C0 -> ifDirectiveR2C1}
  }
  subgraph clusterlabelName {
    node [shape = box]
    label = <labelName = identifier .>
    labeljust = l
    labelNameR0C0 [label = <BHO<br/>N labelName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ":", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labelNameR0C1 [label = <BHL<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ":", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labelNameR1C1 [label = <BHM<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ":", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labelNameR2C1 [label = <BHN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ":", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labelNameR1C1 -> labelNameR2C1 [weight=100000000]
    labelNameR0C1 -> labelNameR1C1 [weight=100000000]
    rank = same {labelNameR0C0 -> labelNameR0C1}
    node [style = invis]
    edge [style = invis]
    labelNameR0C0 -> labelNameR1C0 [weight=100000000]
    rank = same {labelNameR1C0 -> labelNameR1C1}
    labelNameR1C0 -> labelNameR2C0 [weight=100000000]
    rank = same {labelNameR2C0 -> labelNameR2C1}
  }
  subgraph clusterfunctionTypeArgumentClause {
    node [shape = box]
    label = <functionTypeArgumentClause = "(" ")" | "(" functionTypeArgumentList [ "..." ] ")" .>
    labeljust = l
    functionTypeArgumentClauseR0C0 [label = <IZ<br/>N functionTypeArgumentClause<br/>fi ["("]<br/>fo ["&gt;", "async", "throws"]<br/>am ["("]<br/>>]
    functionTypeArgumentClauseR0C1 [label = <IV<br/>ALT <br/>fi ["("]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR1C1 [label = <IW<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    functionTypeArgumentClauseR2C1 [label = <IX<br/>T ")"<br/>fi [")"]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR3C1 [label = <IY<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR2C1 -> functionTypeArgumentClauseR3C1 [weight=100000000]
    functionTypeArgumentClauseR1C1 -> functionTypeArgumentClauseR2C1 [weight=100000000]
    functionTypeArgumentClauseR0C1 -> functionTypeArgumentClauseR1C1 [weight=100000000]
    functionTypeArgumentClauseR0C2 [label = <JA<br/>ALT <br/>fi ["("]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR1C2 [label = <JB<br/>T "("<br/>fi ["("]<br/>fo [")", "...", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionTypeArgumentClauseR2C2 [label = <JC<br/>N functionTypeArgumentList<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentClauseR3C2 [label = <JG<br/>OPT <br/>fi ["", "..."]<br/>fo [")"]<br/>am []<br/>>]
    functionTypeArgumentClauseR4C2 [label = <JH<br/>T ")"<br/>fi [")"]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR5C2 [label = <JI<br/>END <br/>fi [""]<br/>fo ["&gt;", "async", "throws"]<br/>am []<br/>>]
    functionTypeArgumentClauseR4C2 -> functionTypeArgumentClauseR5C2 [weight=100000000]
    functionTypeArgumentClauseR3C2 -> functionTypeArgumentClauseR4C2 [weight=100000000]
    functionTypeArgumentClauseR3C3 [label = <JE<br/>ALT <br/>fi ["..."]<br/>fo [")"]<br/>am []<br/>>]
    functionTypeArgumentClauseR4C3 [label = <JD<br/>T "..."<br/>fi ["..."]<br/>fo [")"]<br/>am []<br/>>]
    functionTypeArgumentClauseR5C3 [label = <JF<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    functionTypeArgumentClauseR4C3 -> functionTypeArgumentClauseR5C3 [weight=100000000]
    functionTypeArgumentClauseR3C3 -> functionTypeArgumentClauseR4C3 [weight=100000000]
    rank = same {functionTypeArgumentClauseR3C2 -> functionTypeArgumentClauseR3C3}
    functionTypeArgumentClauseR2C2 -> functionTypeArgumentClauseR3C2 [weight=100000000]
    functionTypeArgumentClauseR1C2 -> functionTypeArgumentClauseR2C2 [weight=100000000]
    functionTypeArgumentClauseR0C2 -> functionTypeArgumentClauseR1C2 [weight=100000000]
    rank = same {functionTypeArgumentClauseR0C1 -> functionTypeArgumentClauseR0C2}
    rank = same {functionTypeArgumentClauseR0C0 -> functionTypeArgumentClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionTypeArgumentClauseR0C2 -> functionTypeArgumentClauseR0C3}
    functionTypeArgumentClauseR0C0 -> functionTypeArgumentClauseR1C0 [weight=100000000]
    rank = same {functionTypeArgumentClauseR1C0 -> functionTypeArgumentClauseR1C1}
    functionTypeArgumentClauseR0C3 -> functionTypeArgumentClauseR1C3 [weight=100000000]
    rank = same {functionTypeArgumentClauseR1C2 -> functionTypeArgumentClauseR1C3}
    functionTypeArgumentClauseR1C0 -> functionTypeArgumentClauseR2C0 [weight=100000000]
    rank = same {functionTypeArgumentClauseR2C0 -> functionTypeArgumentClauseR2C1}
    functionTypeArgumentClauseR1C3 -> functionTypeArgumentClauseR2C3 [weight=100000000]
    rank = same {functionTypeArgumentClauseR2C2 -> functionTypeArgumentClauseR2C3}
    functionTypeArgumentClauseR2C0 -> functionTypeArgumentClauseR3C0 [weight=100000000]
    rank = same {functionTypeArgumentClauseR3C0 -> functionTypeArgumentClauseR3C1}
    functionTypeArgumentClauseR2C3 -> functionTypeArgumentClauseR3C3 [weight=100000000]
    functionTypeArgumentClauseR3C0 -> functionTypeArgumentClauseR4C0 [weight=100000000]
    functionTypeArgumentClauseR3C1 -> functionTypeArgumentClauseR4C1 [weight=100000000]
    rank = same {functionTypeArgumentClauseR4C0 -> functionTypeArgumentClauseR4C1}
    rank = same {functionTypeArgumentClauseR4C1 -> functionTypeArgumentClauseR4C2}
    functionTypeArgumentClauseR4C0 -> functionTypeArgumentClauseR5C0 [weight=100000000]
    functionTypeArgumentClauseR4C1 -> functionTypeArgumentClauseR5C1 [weight=100000000]
    rank = same {functionTypeArgumentClauseR5C0 -> functionTypeArgumentClauseR5C1}
    rank = same {functionTypeArgumentClauseR5C1 -> functionTypeArgumentClauseR5C2}
  }
  subgraph clusteractorMember {
    node [shape = box]
    label = <actorMember = declaration | compilerControlStatement .>
    labeljust = l
    actorMemberR0C0 [label = <DGT<br/>N actorMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    actorMemberR0C1 [label = <DGN<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    actorMemberR1C1 [label = <DGO<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    actorMemberR2C1 [label = <DGP<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    actorMemberR1C1 -> actorMemberR2C1 [weight=100000000]
    actorMemberR0C1 -> actorMemberR1C1 [weight=100000000]
    actorMemberR0C2 [label = <DGQ<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    actorMemberR1C2 [label = <DGR<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    actorMemberR2C2 [label = <DGS<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    actorMemberR1C2 -> actorMemberR2C2 [weight=100000000]
    actorMemberR0C2 -> actorMemberR1C2 [weight=100000000]
    rank = same {actorMemberR0C1 -> actorMemberR0C2}
    rank = same {actorMemberR0C0 -> actorMemberR0C1}
    node [style = invis]
    edge [style = invis]
    actorMemberR0C0 -> actorMemberR1C0 [weight=100000000]
    rank = same {actorMemberR1C0 -> actorMemberR1C1}
    actorMemberR1C0 -> actorMemberR2C0 [weight=100000000]
    rank = same {actorMemberR2C0 -> actorMemberR2C1}
  }
  subgraph clusterclosureParameterName {
    node [shape = box]
    label = <closureParameterName = identifier .>
    labeljust = l
    closureParameterNameR0C0 [label = <AGB<br/>N closureParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", ":"]<br/>am []<br/>>]
    closureParameterNameR0C1 [label = <AFY<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", ":"]<br/>am []<br/>>]
    closureParameterNameR1C1 [label = <AFZ<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", ",", ":"]<br/>am []<br/>>]
    closureParameterNameR2C1 [label = <AGA<br/>END <br/>fi [""]<br/>fo [")", ",", ":"]<br/>am []<br/>>]
    closureParameterNameR1C1 -> closureParameterNameR2C1 [weight=100000000]
    closureParameterNameR0C1 -> closureParameterNameR1C1 [weight=100000000]
    rank = same {closureParameterNameR0C0 -> closureParameterNameR0C1}
    node [style = invis]
    edge [style = invis]
    closureParameterNameR0C0 -> closureParameterNameR1C0 [weight=100000000]
    rank = same {closureParameterNameR1C0 -> closureParameterNameR1C1}
    closureParameterNameR1C0 -> closureParameterNameR2C0 [weight=100000000]
    rank = same {closureParameterNameR2C0 -> closureParameterNameR2C1}
  }
  subgraph clusterimportPath {
    node [shape = box]
    label = <importPath = identifier | identifier "." importPath .>
    labeljust = l
    importPathR0C0 [label = <CCF<br/>N importPath<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    importPathR0C1 [label = <CBX<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR1C1 [label = <CBY<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR2C1 [label = <CBZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR1C1 -> importPathR2C1 [weight=100000000]
    importPathR0C1 -> importPathR1C1 [weight=100000000]
    importPathR0C2 [label = <CCA<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR1C2 [label = <CCB<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["."]<br/>am []<br/>>]
    importPathR2C2 [label = <CCC<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    importPathR3C2 [label = <CCD<br/>N importPath<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR4C2 [label = <CCE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    importPathR3C2 -> importPathR4C2 [weight=100000000]
    importPathR2C2 -> importPathR3C2 [weight=100000000]
    importPathR1C2 -> importPathR2C2 [weight=100000000]
    importPathR0C2 -> importPathR1C2 [weight=100000000]
    rank = same {importPathR0C1 -> importPathR0C2}
    rank = same {importPathR0C0 -> importPathR0C1}
    node [style = invis]
    edge [style = invis]
    importPathR0C0 -> importPathR1C0 [weight=100000000]
    rank = same {importPathR1C0 -> importPathR1C1}
    importPathR1C0 -> importPathR2C0 [weight=100000000]
    rank = same {importPathR2C0 -> importPathR2C1}
    importPathR2C0 -> importPathR3C0 [weight=100000000]
    importPathR2C1 -> importPathR3C1 [weight=100000000]
    rank = same {importPathR3C0 -> importPathR3C1}
    rank = same {importPathR3C1 -> importPathR3C2}
    importPathR3C0 -> importPathR4C0 [weight=100000000]
    importPathR3C1 -> importPathR4C1 [weight=100000000]
    rank = same {importPathR4C0 -> importPathR4C1}
    rank = same {importPathR4C1 -> importPathR4C2}
  }
  subgraph clustertupleExpression {
    node [shape = box]
    label = <tupleExpression = "(" ")" | "(" tupleElement "," tupleElementList ")" .>
    labeljust = l
    tupleExpressionR0C0 [label = <AJE<br/>N tupleExpression<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    tupleExpressionR0C1 [label = <AIT<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR1C1 [label = <AIU<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    tupleExpressionR2C1 [label = <AIV<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR3C1 [label = <AIW<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR2C1 -> tupleExpressionR3C1 [weight=100000000]
    tupleExpressionR1C1 -> tupleExpressionR2C1 [weight=100000000]
    tupleExpressionR0C1 -> tupleExpressionR1C1 [weight=100000000]
    tupleExpressionR0C2 [label = <AIX<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR1C2 [label = <AIY<br/>T "("<br/>fi ["("]<br/>fo [",", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    tupleExpressionR2C2 [label = <AIZ<br/>N tupleElement<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [","]<br/>am []<br/>>]
    tupleExpressionR3C2 [label = <AJA<br/>T ","<br/>fi [","]<br/>fo [")", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    tupleExpressionR4C2 [label = <AJB<br/>N tupleElementList<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>fo [")"]<br/>am []<br/>>]
    tupleExpressionR5C2 [label = <AJC<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR6C2 [label = <AJD<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleExpressionR5C2 -> tupleExpressionR6C2 [weight=100000000]
    tupleExpressionR4C2 -> tupleExpressionR5C2 [weight=100000000]
    tupleExpressionR3C2 -> tupleExpressionR4C2 [weight=100000000]
    tupleExpressionR2C2 -> tupleExpressionR3C2 [weight=100000000]
    tupleExpressionR1C2 -> tupleExpressionR2C2 [weight=100000000]
    tupleExpressionR0C2 -> tupleExpressionR1C2 [weight=100000000]
    rank = same {tupleExpressionR0C1 -> tupleExpressionR0C2}
    rank = same {tupleExpressionR0C0 -> tupleExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    tupleExpressionR0C0 -> tupleExpressionR1C0 [weight=100000000]
    rank = same {tupleExpressionR1C0 -> tupleExpressionR1C1}
    tupleExpressionR1C0 -> tupleExpressionR2C0 [weight=100000000]
    rank = same {tupleExpressionR2C0 -> tupleExpressionR2C1}
    tupleExpressionR2C0 -> tupleExpressionR3C0 [weight=100000000]
    rank = same {tupleExpressionR3C0 -> tupleExpressionR3C1}
    tupleExpressionR3C0 -> tupleExpressionR4C0 [weight=100000000]
    tupleExpressionR3C1 -> tupleExpressionR4C1 [weight=100000000]
    rank = same {tupleExpressionR4C0 -> tupleExpressionR4C1}
    rank = same {tupleExpressionR4C1 -> tupleExpressionR4C2}
    tupleExpressionR4C0 -> tupleExpressionR5C0 [weight=100000000]
    tupleExpressionR4C1 -> tupleExpressionR5C1 [weight=100000000]
    rank = same {tupleExpressionR5C0 -> tupleExpressionR5C1}
    rank = same {tupleExpressionR5C1 -> tupleExpressionR5C2}
    tupleExpressionR5C0 -> tupleExpressionR6C0 [weight=100000000]
    tupleExpressionR5C1 -> tupleExpressionR6C1 [weight=100000000]
    rank = same {tupleExpressionR6C0 -> tupleExpressionR6C1}
    rank = same {tupleExpressionR6C1 -> tupleExpressionR6C2}
  }
  subgraph clusterprotocolMembers {
    node [shape = box]
    label = <protocolMembers = protocolMember [ protocolMembers ] .>
    labeljust = l
    protocolMembersR0C0 [label = <DIK<br/>N protocolMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR0C1 [label = <DID<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR1C1 [label = <DIE<br/>N protocolMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@"]<br/>>]
    protocolMembersR2C1 [label = <DII<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR3C1 [label = <DIJ<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR2C1 -> protocolMembersR3C1 [weight=100000000]
    protocolMembersR2C2 [label = <DIG<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR3C2 [label = <DIF<br/>N protocolMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR4C2 [label = <DIH<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    protocolMembersR3C2 -> protocolMembersR4C2 [weight=100000000]
    protocolMembersR2C2 -> protocolMembersR3C2 [weight=100000000]
    rank = same {protocolMembersR2C1 -> protocolMembersR2C2}
    protocolMembersR1C1 -> protocolMembersR2C1 [weight=100000000]
    protocolMembersR0C1 -> protocolMembersR1C1 [weight=100000000]
    rank = same {protocolMembersR0C0 -> protocolMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolMembersR0C1 -> protocolMembersR0C2}
    protocolMembersR0C0 -> protocolMembersR1C0 [weight=100000000]
    rank = same {protocolMembersR1C0 -> protocolMembersR1C1}
    protocolMembersR0C2 -> protocolMembersR1C2 [weight=100000000]
    rank = same {protocolMembersR1C1 -> protocolMembersR1C2}
    protocolMembersR1C0 -> protocolMembersR2C0 [weight=100000000]
    rank = same {protocolMembersR2C0 -> protocolMembersR2C1}
    protocolMembersR1C2 -> protocolMembersR2C2 [weight=100000000]
    protocolMembersR2C0 -> protocolMembersR3C0 [weight=100000000]
    rank = same {protocolMembersR3C0 -> protocolMembersR3C1}
    protocolMembersR3C0 -> protocolMembersR4C0 [weight=100000000]
    protocolMembersR3C1 -> protocolMembersR4C1 [weight=100000000]
    rank = same {protocolMembersR4C0 -> protocolMembersR4C1}
    rank = same {protocolMembersR4C1 -> protocolMembersR4C2}
  }
  subgraph clusterelseifDirectiveClauses {
    node [shape = box]
    label = <elseifDirectiveClauses = elseifDirectiveClause [ elseifDirectiveClauses ] .>
    labeljust = l
    elseifDirectiveClausesR0C0 [label = <BMZ<br/>N elseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR0C1 [label = <BMS<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR1C1 [label = <BMT<br/>N elseifDirectiveClause<br/>fi ["#elseif"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR2C1 [label = <BMX<br/>OPT <br/>fi ["", "#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR3C1 [label = <BMY<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR2C1 -> elseifDirectiveClausesR3C1 [weight=100000000]
    elseifDirectiveClausesR2C2 [label = <BMV<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR3C2 [label = <BMU<br/>N elseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR4C2 [label = <BMW<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClausesR3C2 -> elseifDirectiveClausesR4C2 [weight=100000000]
    elseifDirectiveClausesR2C2 -> elseifDirectiveClausesR3C2 [weight=100000000]
    rank = same {elseifDirectiveClausesR2C1 -> elseifDirectiveClausesR2C2}
    elseifDirectiveClausesR1C1 -> elseifDirectiveClausesR2C1 [weight=100000000]
    elseifDirectiveClausesR0C1 -> elseifDirectiveClausesR1C1 [weight=100000000]
    rank = same {elseifDirectiveClausesR0C0 -> elseifDirectiveClausesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {elseifDirectiveClausesR0C1 -> elseifDirectiveClausesR0C2}
    elseifDirectiveClausesR0C0 -> elseifDirectiveClausesR1C0 [weight=100000000]
    rank = same {elseifDirectiveClausesR1C0 -> elseifDirectiveClausesR1C1}
    elseifDirectiveClausesR0C2 -> elseifDirectiveClausesR1C2 [weight=100000000]
    rank = same {elseifDirectiveClausesR1C1 -> elseifDirectiveClausesR1C2}
    elseifDirectiveClausesR1C0 -> elseifDirectiveClausesR2C0 [weight=100000000]
    rank = same {elseifDirectiveClausesR2C0 -> elseifDirectiveClausesR2C1}
    elseifDirectiveClausesR1C2 -> elseifDirectiveClausesR2C2 [weight=100000000]
    elseifDirectiveClausesR2C0 -> elseifDirectiveClausesR3C0 [weight=100000000]
    rank = same {elseifDirectiveClausesR3C0 -> elseifDirectiveClausesR3C1}
    elseifDirectiveClausesR3C0 -> elseifDirectiveClausesR4C0 [weight=100000000]
    elseifDirectiveClausesR3C1 -> elseifDirectiveClausesR4C1 [weight=100000000]
    rank = same {elseifDirectiveClausesR4C0 -> elseifDirectiveClausesR4C1}
    rank = same {elseifDirectiveClausesR4C1 -> elseifDirectiveClausesR4C2}
  }
  subgraph clusterconditionList {
    node [shape = box]
    label = <conditionList = condition | condition "," conditionList .>
    labeljust = l
    conditionListR0C0 [label = <AYU<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else", "{"]<br/>am ["#available", "#unavailable", "case", "let", "try", "var"]<br/>>]
    conditionListR0C1 [label = <AYM<br/>ALT <br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR1C1 [label = <AYN<br/>N condition<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR2C1 [label = <AYO<br/>END <br/>fi [""]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR1C1 -> conditionListR2C1 [weight=100000000]
    conditionListR0C1 -> conditionListR1C1 [weight=100000000]
    conditionListR0C2 [label = <AYP<br/>ALT <br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR1C2 [label = <AYQ<br/>N condition<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo [","]<br/>am []<br/>>]
    conditionListR2C2 [label = <AYR<br/>T ","<br/>fi [","]<br/>fo ["#available", "#unavailable", "case", "else", "let", "try", "var", "{"]<br/>am []<br/>>]
    conditionListR3C2 [label = <AYS<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR4C2 [label = <AYT<br/>END <br/>fi [""]<br/>fo ["else", "{"]<br/>am []<br/>>]
    conditionListR3C2 -> conditionListR4C2 [weight=100000000]
    conditionListR2C2 -> conditionListR3C2 [weight=100000000]
    conditionListR1C2 -> conditionListR2C2 [weight=100000000]
    conditionListR0C2 -> conditionListR1C2 [weight=100000000]
    rank = same {conditionListR0C1 -> conditionListR0C2}
    rank = same {conditionListR0C0 -> conditionListR0C1}
    node [style = invis]
    edge [style = invis]
    conditionListR0C0 -> conditionListR1C0 [weight=100000000]
    rank = same {conditionListR1C0 -> conditionListR1C1}
    conditionListR1C0 -> conditionListR2C0 [weight=100000000]
    rank = same {conditionListR2C0 -> conditionListR2C1}
    conditionListR2C0 -> conditionListR3C0 [weight=100000000]
    conditionListR2C1 -> conditionListR3C1 [weight=100000000]
    rank = same {conditionListR3C0 -> conditionListR3C1}
    rank = same {conditionListR3C1 -> conditionListR3C2}
    conditionListR3C0 -> conditionListR4C0 [weight=100000000]
    conditionListR3C1 -> conditionListR4C1 [weight=100000000]
    rank = same {conditionListR4C0 -> conditionListR4C1}
    rank = same {conditionListR4C1 -> conditionListR4C2}
  }
  subgraph clusterstringLiteral {
    node [shape = box]
    label = <stringLiteral = "staticStringLiteral" | "interpolatedStringLiteral" .>
    labeljust = l
    stringLiteralR0C0 [label = <DC<br/>N stringLiteral<br/>fi ["interpolatedStringLiteral", "staticStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR0C1 [label = <CW<br/>ALT <br/>fi ["staticStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR1C1 [label = <CX<br/>T "staticStringLiteral"<br/>fi ["staticStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR2C1 [label = <CY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR1C1 -> stringLiteralR2C1 [weight=100000000]
    stringLiteralR0C1 -> stringLiteralR1C1 [weight=100000000]
    stringLiteralR0C2 [label = <CZ<br/>ALT <br/>fi ["interpolatedStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR1C2 [label = <DA<br/>T "interpolatedStringLiteral"<br/>fi ["interpolatedStringLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR2C2 [label = <DB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    stringLiteralR1C2 -> stringLiteralR2C2 [weight=100000000]
    stringLiteralR0C2 -> stringLiteralR1C2 [weight=100000000]
    rank = same {stringLiteralR0C1 -> stringLiteralR0C2}
    rank = same {stringLiteralR0C0 -> stringLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    stringLiteralR0C0 -> stringLiteralR1C0 [weight=100000000]
    rank = same {stringLiteralR1C0 -> stringLiteralR1C1}
    stringLiteralR1C0 -> stringLiteralR2C0 [weight=100000000]
    rank = same {stringLiteralR2C0 -> stringLiteralR2C1}
  }
  subgraph clusterstatements {
    node [shape = box]
    label = <statements = statement [ statements ] .>
    labeljust = l
    statementsR0C0 [label = <AXF<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    statementsR0C1 [label = <AWY<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    statementsR1C1 [label = <AWZ<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>>]
    statementsR2C1 [label = <AXD<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    statementsR3C1 [label = <AXE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am []<br/>>]
    statementsR2C1 -> statementsR3C1 [weight=100000000]
    statementsR2C2 [label = <AXB<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    statementsR3C2 [label = <AXA<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    statementsR4C2 [label = <AXC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#if", "$", "@", "}"]<br/>am []<br/>>]
    statementsR3C2 -> statementsR4C2 [weight=100000000]
    statementsR2C2 -> statementsR3C2 [weight=100000000]
    rank = same {statementsR2C1 -> statementsR2C2}
    statementsR1C1 -> statementsR2C1 [weight=100000000]
    statementsR0C1 -> statementsR1C1 [weight=100000000]
    rank = same {statementsR0C0 -> statementsR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {statementsR0C1 -> statementsR0C2}
    statementsR0C0 -> statementsR1C0 [weight=100000000]
    rank = same {statementsR1C0 -> statementsR1C1}
    statementsR0C2 -> statementsR1C2 [weight=100000000]
    rank = same {statementsR1C1 -> statementsR1C2}
    statementsR1C0 -> statementsR2C0 [weight=100000000]
    rank = same {statementsR2C0 -> statementsR2C1}
    statementsR1C2 -> statementsR2C2 [weight=100000000]
    statementsR2C0 -> statementsR3C0 [weight=100000000]
    rank = same {statementsR3C0 -> statementsR3C1}
    statementsR3C0 -> statementsR4C0 [weight=100000000]
    statementsR3C1 -> statementsR4C1 [weight=100000000]
    rank = same {statementsR4C0 -> statementsR4C1}
    rank = same {statementsR4C1 -> statementsR4C2}
  }
  subgraph clusterprecedenceGroupAttribute {
    node [shape = box]
    label = <precedenceGroupAttribute = precedenceGroupRelation | precedenceGroupAssignment | precedenceGroupAssociativity .>
    labeljust = l
    precedenceGroupAttributeR0C0 [label = <DYA<br/>N precedenceGroupAttribute<br/>fi ["assignment", "associativity", "higherThan", "lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR0C1 [label = <DXX<br/>ALT <br/>fi ["higherThan", "lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C1 [label = <DXY<br/>N precedenceGroupRelation<br/>fi ["higherThan", "lowerThan"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR2C1 [label = <DXZ<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C1 -> precedenceGroupAttributeR2C1 [weight=100000000]
    precedenceGroupAttributeR0C1 -> precedenceGroupAttributeR1C1 [weight=100000000]
    precedenceGroupAttributeR0C2 [label = <DYB<br/>ALT <br/>fi ["assignment"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C2 [label = <DYC<br/>N precedenceGroupAssignment<br/>fi ["assignment"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR2C2 [label = <DYD<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C2 -> precedenceGroupAttributeR2C2 [weight=100000000]
    precedenceGroupAttributeR0C2 -> precedenceGroupAttributeR1C2 [weight=100000000]
    precedenceGroupAttributeR0C3 [label = <DYE<br/>ALT <br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C3 [label = <DYF<br/>N precedenceGroupAssociativity<br/>fi ["associativity"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR2C3 [label = <DYG<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupAttributeR1C3 -> precedenceGroupAttributeR2C3 [weight=100000000]
    precedenceGroupAttributeR0C3 -> precedenceGroupAttributeR1C3 [weight=100000000]
    rank = same {precedenceGroupAttributeR0C2 -> precedenceGroupAttributeR0C3}
    rank = same {precedenceGroupAttributeR0C1 -> precedenceGroupAttributeR0C2}
    rank = same {precedenceGroupAttributeR0C0 -> precedenceGroupAttributeR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupAttributeR0C0 -> precedenceGroupAttributeR1C0 [weight=100000000]
    rank = same {precedenceGroupAttributeR1C0 -> precedenceGroupAttributeR1C1}
    precedenceGroupAttributeR1C0 -> precedenceGroupAttributeR2C0 [weight=100000000]
    rank = same {precedenceGroupAttributeR2C0 -> precedenceGroupAttributeR2C1}
  }
  subgraph clusterenumCasePattern {
    node [shape = box]
    label = <enumCasePattern = [ typeIdentifier ] "." enumCaseName [ tuplePattern ] .>
    labeljust = l
    enumCasePatternR0C0 [label = <EMK<br/>N enumCasePattern<br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    enumCasePatternR0C1 [label = <ELY<br/>ALT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    enumCasePatternR1C1 [label = <EMC<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["."]<br/>am []<br/>>]
    enumCasePatternR2C1 [label = <EMD<br/>T "."<br/>fi ["."]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    enumCasePatternR3C1 [label = <EME<br/>N enumCaseName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR4C1 [label = <EMI<br/>OPT <br/>fi ["", "("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR5C1 [label = <EMJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR4C1 -> enumCasePatternR5C1 [weight=100000000]
    enumCasePatternR4C2 [label = <EMG<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR5C2 [label = <EMF<br/>N tuplePattern<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR6C2 [label = <EMH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    enumCasePatternR5C2 -> enumCasePatternR6C2 [weight=100000000]
    enumCasePatternR4C2 -> enumCasePatternR5C2 [weight=100000000]
    rank = same {enumCasePatternR4C1 -> enumCasePatternR4C2}
    enumCasePatternR3C1 -> enumCasePatternR4C1 [weight=100000000]
    enumCasePatternR2C1 -> enumCasePatternR3C1 [weight=100000000]
    enumCasePatternR1C1 -> enumCasePatternR2C1 [weight=100000000]
    enumCasePatternR1C3 [label = <EMA<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["."]<br/>am []<br/>>]
    enumCasePatternR2C3 [label = <ELZ<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["."]<br/>am []<br/>>]
    enumCasePatternR3C3 [label = <EMB<br/>END <br/>fi [""]<br/>fo ["."]<br/>am []<br/>>]
    enumCasePatternR2C3 -> enumCasePatternR3C3 [weight=100000000]
    enumCasePatternR1C3 -> enumCasePatternR2C3 [weight=100000000]
    rank = same {enumCasePatternR1C1 -> enumCasePatternR1C3}
    enumCasePatternR0C1 -> enumCasePatternR1C1 [weight=100000000]
    rank = same {enumCasePatternR0C0 -> enumCasePatternR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {enumCasePatternR0C1 -> enumCasePatternR0C2}
    rank = same {enumCasePatternR0C2 -> enumCasePatternR0C3}
    enumCasePatternR0C0 -> enumCasePatternR1C0 [weight=100000000]
    rank = same {enumCasePatternR1C0 -> enumCasePatternR1C1}
    enumCasePatternR0C3 -> enumCasePatternR1C3 [weight=100000000]
    enumCasePatternR1C0 -> enumCasePatternR2C0 [weight=100000000]
    rank = same {enumCasePatternR2C0 -> enumCasePatternR2C1}
    rank = same {enumCasePatternR2C1 -> enumCasePatternR2C2}
    rank = same {enumCasePatternR2C2 -> enumCasePatternR2C3}
    enumCasePatternR2C0 -> enumCasePatternR3C0 [weight=100000000]
    rank = same {enumCasePatternR3C0 -> enumCasePatternR3C1}
    enumCasePatternR2C2 -> enumCasePatternR3C2 [weight=100000000]
    rank = same {enumCasePatternR3C1 -> enumCasePatternR3C2}
    rank = same {enumCasePatternR3C2 -> enumCasePatternR3C3}
    enumCasePatternR3C0 -> enumCasePatternR4C0 [weight=100000000]
    rank = same {enumCasePatternR4C0 -> enumCasePatternR4C1}
    enumCasePatternR3C2 -> enumCasePatternR4C2 [weight=100000000]
    enumCasePatternR3C3 -> enumCasePatternR4C3 [weight=100000000]
    rank = same {enumCasePatternR4C2 -> enumCasePatternR4C3}
    enumCasePatternR4C0 -> enumCasePatternR5C0 [weight=100000000]
    rank = same {enumCasePatternR5C0 -> enumCasePatternR5C1}
    enumCasePatternR4C3 -> enumCasePatternR5C3 [weight=100000000]
    rank = same {enumCasePatternR5C2 -> enumCasePatternR5C3}
    enumCasePatternR5C0 -> enumCasePatternR6C0 [weight=100000000]
    enumCasePatternR5C1 -> enumCasePatternR6C1 [weight=100000000]
    rank = same {enumCasePatternR6C0 -> enumCasePatternR6C1}
    rank = same {enumCasePatternR6C1 -> enumCasePatternR6C2}
    enumCasePatternR5C3 -> enumCasePatternR6C3 [weight=100000000]
    rank = same {enumCasePatternR6C2 -> enumCasePatternR6C3}
  }
  subgraph clusterifDirectiveClause {
    node [shape = box]
    label = <ifDirectiveClause = ifDirective compilationCondition [ statements ] .>
    labeljust = l
    ifDirectiveClauseR0C0 [label = <BMR<br/>N ifDirectiveClause<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR0C1 [label = <BMJ<br/>ALT <br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR1C1 [label = <BMK<br/>N ifDirective<br/>fi ["#if"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    ifDirectiveClauseR2C1 [label = <BML<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    ifDirectiveClauseR3C1 [label = <BMP<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR4C1 [label = <BMQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR3C1 -> ifDirectiveClauseR4C1 [weight=100000000]
    ifDirectiveClauseR3C2 [label = <BMN<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR4C2 [label = <BMM<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR5C2 [label = <BMO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    ifDirectiveClauseR4C2 -> ifDirectiveClauseR5C2 [weight=100000000]
    ifDirectiveClauseR3C2 -> ifDirectiveClauseR4C2 [weight=100000000]
    rank = same {ifDirectiveClauseR3C1 -> ifDirectiveClauseR3C2}
    ifDirectiveClauseR2C1 -> ifDirectiveClauseR3C1 [weight=100000000]
    ifDirectiveClauseR1C1 -> ifDirectiveClauseR2C1 [weight=100000000]
    ifDirectiveClauseR0C1 -> ifDirectiveClauseR1C1 [weight=100000000]
    rank = same {ifDirectiveClauseR0C0 -> ifDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {ifDirectiveClauseR0C1 -> ifDirectiveClauseR0C2}
    ifDirectiveClauseR0C0 -> ifDirectiveClauseR1C0 [weight=100000000]
    rank = same {ifDirectiveClauseR1C0 -> ifDirectiveClauseR1C1}
    ifDirectiveClauseR0C2 -> ifDirectiveClauseR1C2 [weight=100000000]
    rank = same {ifDirectiveClauseR1C1 -> ifDirectiveClauseR1C2}
    ifDirectiveClauseR1C0 -> ifDirectiveClauseR2C0 [weight=100000000]
    rank = same {ifDirectiveClauseR2C0 -> ifDirectiveClauseR2C1}
    ifDirectiveClauseR1C2 -> ifDirectiveClauseR2C2 [weight=100000000]
    rank = same {ifDirectiveClauseR2C1 -> ifDirectiveClauseR2C2}
    ifDirectiveClauseR2C0 -> ifDirectiveClauseR3C0 [weight=100000000]
    rank = same {ifDirectiveClauseR3C0 -> ifDirectiveClauseR3C1}
    ifDirectiveClauseR2C2 -> ifDirectiveClauseR3C2 [weight=100000000]
    ifDirectiveClauseR3C0 -> ifDirectiveClauseR4C0 [weight=100000000]
    rank = same {ifDirectiveClauseR4C0 -> ifDirectiveClauseR4C1}
    ifDirectiveClauseR4C0 -> ifDirectiveClauseR5C0 [weight=100000000]
    ifDirectiveClauseR4C1 -> ifDirectiveClauseR5C1 [weight=100000000]
    rank = same {ifDirectiveClauseR5C0 -> ifDirectiveClauseR5C1}
    rank = same {ifDirectiveClauseR5C1 -> ifDirectiveClauseR5C2}
  }
  subgraph clusteractorBody {
    node [shape = box]
    label = <actorBody = "{" [ actorMembers ] "}" .>
    labeljust = l
    actorBodyR0C0 [label = <DGE<br/>N actorBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorBodyR0C1 [label = <DFW<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorBodyR1C1 [label = <DFX<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    actorBodyR2C1 [label = <DGB<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorBodyR3C1 [label = <DGC<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorBodyR4C1 [label = <DGD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    actorBodyR3C1 -> actorBodyR4C1 [weight=100000000]
    actorBodyR2C1 -> actorBodyR3C1 [weight=100000000]
    actorBodyR2C2 [label = <DFZ<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorBodyR3C2 [label = <DFY<br/>N actorMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    actorBodyR4C2 [label = <DGA<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    actorBodyR3C2 -> actorBodyR4C2 [weight=100000000]
    actorBodyR2C2 -> actorBodyR3C2 [weight=100000000]
    rank = same {actorBodyR2C1 -> actorBodyR2C2}
    actorBodyR1C1 -> actorBodyR2C1 [weight=100000000]
    actorBodyR0C1 -> actorBodyR1C1 [weight=100000000]
    rank = same {actorBodyR0C0 -> actorBodyR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {actorBodyR0C1 -> actorBodyR0C2}
    actorBodyR0C0 -> actorBodyR1C0 [weight=100000000]
    rank = same {actorBodyR1C0 -> actorBodyR1C1}
    actorBodyR0C2 -> actorBodyR1C2 [weight=100000000]
    rank = same {actorBodyR1C1 -> actorBodyR1C2}
    actorBodyR1C0 -> actorBodyR2C0 [weight=100000000]
    rank = same {actorBodyR2C0 -> actorBodyR2C1}
    actorBodyR1C2 -> actorBodyR2C2 [weight=100000000]
    actorBodyR2C0 -> actorBodyR3C0 [weight=100000000]
    rank = same {actorBodyR3C0 -> actorBodyR3C1}
    actorBodyR3C0 -> actorBodyR4C0 [weight=100000000]
    rank = same {actorBodyR4C0 -> actorBodyR4C1}
  }
  subgraph clusterdeinitializerDeclaration {
    node [shape = box]
    label = <deinitializerDeclaration = [ attributes ] "deinit" codeBlock .>
    labeljust = l
    deinitializerDeclarationR0C0 [label = <DQD<br/>N deinitializerDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    deinitializerDeclarationR0C1 [label = <DPV<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    deinitializerDeclarationR1C1 [label = <DPZ<br/>OPT <br/>fi ["", "@"]<br/>fo ["deinit"]<br/>am []<br/>>]
    deinitializerDeclarationR2C1 [label = <DQA<br/>T "deinit"<br/>fi ["deinit"]<br/>fo ["{"]<br/>am []<br/>>]
    deinitializerDeclarationR3C1 [label = <DQB<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deinitializerDeclarationR4C1 [label = <DQC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    deinitializerDeclarationR3C1 -> deinitializerDeclarationR4C1 [weight=100000000]
    deinitializerDeclarationR2C1 -> deinitializerDeclarationR3C1 [weight=100000000]
    deinitializerDeclarationR1C1 -> deinitializerDeclarationR2C1 [weight=100000000]
    deinitializerDeclarationR1C2 [label = <DPX<br/>ALT <br/>fi ["@"]<br/>fo ["deinit"]<br/>am []<br/>>]
    deinitializerDeclarationR2C2 [label = <DPW<br/>N attributes<br/>fi ["@"]<br/>fo ["deinit"]<br/>am []<br/>>]
    deinitializerDeclarationR3C2 [label = <DPY<br/>END <br/>fi [""]<br/>fo ["deinit"]<br/>am []<br/>>]
    deinitializerDeclarationR2C2 -> deinitializerDeclarationR3C2 [weight=100000000]
    deinitializerDeclarationR1C2 -> deinitializerDeclarationR2C2 [weight=100000000]
    rank = same {deinitializerDeclarationR1C1 -> deinitializerDeclarationR1C2}
    deinitializerDeclarationR0C1 -> deinitializerDeclarationR1C1 [weight=100000000]
    rank = same {deinitializerDeclarationR0C0 -> deinitializerDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {deinitializerDeclarationR0C1 -> deinitializerDeclarationR0C2}
    deinitializerDeclarationR0C0 -> deinitializerDeclarationR1C0 [weight=100000000]
    rank = same {deinitializerDeclarationR1C0 -> deinitializerDeclarationR1C1}
    deinitializerDeclarationR0C2 -> deinitializerDeclarationR1C2 [weight=100000000]
    deinitializerDeclarationR1C0 -> deinitializerDeclarationR2C0 [weight=100000000]
    rank = same {deinitializerDeclarationR2C0 -> deinitializerDeclarationR2C1}
    deinitializerDeclarationR2C0 -> deinitializerDeclarationR3C0 [weight=100000000]
    rank = same {deinitializerDeclarationR3C0 -> deinitializerDeclarationR3C1}
    deinitializerDeclarationR3C0 -> deinitializerDeclarationR4C0 [weight=100000000]
    rank = same {deinitializerDeclarationR4C0 -> deinitializerDeclarationR4C1}
    deinitializerDeclarationR3C2 -> deinitializerDeclarationR4C2 [weight=100000000]
    rank = same {deinitializerDeclarationR4C1 -> deinitializerDeclarationR4C2}
  }
  subgraph clustercodeBlock {
    node [shape = box]
    label = <codeBlock = "{" [ statements ] "}" .>
    labeljust = l
    codeBlockR0C0 [label = <CAK<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    codeBlockR0C1 [label = <CAC<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    codeBlockR1C1 [label = <CAD<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    codeBlockR2C1 [label = <CAH<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    codeBlockR3C1 [label = <CAI<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    codeBlockR4C1 [label = <CAJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    codeBlockR3C1 -> codeBlockR4C1 [weight=100000000]
    codeBlockR2C1 -> codeBlockR3C1 [weight=100000000]
    codeBlockR2C2 [label = <CAF<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    codeBlockR3C2 [label = <CAE<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["}"]<br/>am []<br/>>]
    codeBlockR4C2 [label = <CAG<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    codeBlockR3C2 -> codeBlockR4C2 [weight=100000000]
    codeBlockR2C2 -> codeBlockR3C2 [weight=100000000]
    rank = same {codeBlockR2C1 -> codeBlockR2C2}
    codeBlockR1C1 -> codeBlockR2C1 [weight=100000000]
    codeBlockR0C1 -> codeBlockR1C1 [weight=100000000]
    rank = same {codeBlockR0C0 -> codeBlockR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {codeBlockR0C1 -> codeBlockR0C2}
    codeBlockR0C0 -> codeBlockR1C0 [weight=100000000]
    rank = same {codeBlockR1C0 -> codeBlockR1C1}
    codeBlockR0C2 -> codeBlockR1C2 [weight=100000000]
    rank = same {codeBlockR1C1 -> codeBlockR1C2}
    codeBlockR1C0 -> codeBlockR2C0 [weight=100000000]
    rank = same {codeBlockR2C0 -> codeBlockR2C1}
    codeBlockR1C2 -> codeBlockR2C2 [weight=100000000]
    codeBlockR2C0 -> codeBlockR3C0 [weight=100000000]
    rank = same {codeBlockR3C0 -> codeBlockR3C1}
    codeBlockR3C0 -> codeBlockR4C0 [weight=100000000]
    rank = same {codeBlockR4C0 -> codeBlockR4C1}
  }
  subgraph clusterinfixExpressions {
    node [shape = box]
    label = <infixExpressions = infixExpression [ infixExpressions ] .>
    labeljust = l
    infixExpressionsR0C0 [label = <RP<br/>N infixExpressions<br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR0C1 [label = <RI<br/>ALT <br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR1C1 [label = <RJ<br/>N infixExpression<br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR2C1 [label = <RN<br/>OPT <br/>fi ["", "=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["=", "as"]<br/>>]
    infixExpressionsR3C1 [label = <RO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR2C1 -> infixExpressionsR3C1 [weight=100000000]
    infixExpressionsR2C2 [label = <RL<br/>ALT <br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR3C2 [label = <RK<br/>N infixExpressions<br/>fi ["=", "?", "as", "dotOperator", "is", "plainOperator"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR4C2 [label = <RM<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ":", ";", "=", "@", "]", "as", "break", "continue", "defer", "do", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    infixExpressionsR3C2 -> infixExpressionsR4C2 [weight=100000000]
    infixExpressionsR2C2 -> infixExpressionsR3C2 [weight=100000000]
    rank = same {infixExpressionsR2C1 -> infixExpressionsR2C2}
    infixExpressionsR1C1 -> infixExpressionsR2C1 [weight=100000000]
    infixExpressionsR0C1 -> infixExpressionsR1C1 [weight=100000000]
    rank = same {infixExpressionsR0C0 -> infixExpressionsR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {infixExpressionsR0C1 -> infixExpressionsR0C2}
    infixExpressionsR0C0 -> infixExpressionsR1C0 [weight=100000000]
    rank = same {infixExpressionsR1C0 -> infixExpressionsR1C1}
    infixExpressionsR0C2 -> infixExpressionsR1C2 [weight=100000000]
    rank = same {infixExpressionsR1C1 -> infixExpressionsR1C2}
    infixExpressionsR1C0 -> infixExpressionsR2C0 [weight=100000000]
    rank = same {infixExpressionsR2C0 -> infixExpressionsR2C1}
    infixExpressionsR1C2 -> infixExpressionsR2C2 [weight=100000000]
    infixExpressionsR2C0 -> infixExpressionsR3C0 [weight=100000000]
    rank = same {infixExpressionsR3C0 -> infixExpressionsR3C1}
    infixExpressionsR3C0 -> infixExpressionsR4C0 [weight=100000000]
    infixExpressionsR3C1 -> infixExpressionsR4C1 [weight=100000000]
    rank = same {infixExpressionsR4C0 -> infixExpressionsR4C1}
    rank = same {infixExpressionsR4C1 -> infixExpressionsR4C2}
  }
  subgraph clusterprotocolInitializerDeclaration {
    node [shape = box]
    label = <protocolInitializerDeclaration = initializerHead [ genericParameterClause ] parameterClause [ throwsClause ] [ genericWhereClause ] | initializerHead [ genericParameterClause ] parameterClause "rethrows" [ genericWhereClause ] .>
    labeljust = l
    protocolInitializerDeclarationR0C0 [label = <DKW<br/>N protocolInitializerDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolInitializerDeclarationR0C1 [label = <DKG<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolInitializerDeclarationR1C1 [label = <DKH<br/>N initializerHead<br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    protocolInitializerDeclarationR2C1 [label = <DKL<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C1 [label = <DKM<br/>N parameterClause<br/>fi ["("]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "throws", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR4C1 [label = <DKQ<br/>OPT <br/>fi ["", "throws"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C1 [label = <DKU<br/>OPT <br/>fi ["", "where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C1 [label = <DKV<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C1 -> protocolInitializerDeclarationR6C1 [weight=100000000]
    protocolInitializerDeclarationR5C2 [label = <DKS<br/>ALT <br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C2 [label = <DKR<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR7C2 [label = <DKT<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C2 -> protocolInitializerDeclarationR7C2 [weight=100000000]
    protocolInitializerDeclarationR5C2 -> protocolInitializerDeclarationR6C2 [weight=100000000]
    rank = same {protocolInitializerDeclarationR5C1 -> protocolInitializerDeclarationR5C2}
    protocolInitializerDeclarationR4C1 -> protocolInitializerDeclarationR5C1 [weight=100000000]
    protocolInitializerDeclarationR4C3 [label = <DKO<br/>ALT <br/>fi ["throws"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C3 [label = <DKN<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C3 [label = <DKP<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C3 -> protocolInitializerDeclarationR6C3 [weight=100000000]
    protocolInitializerDeclarationR4C3 -> protocolInitializerDeclarationR5C3 [weight=100000000]
    rank = same {protocolInitializerDeclarationR4C1 -> protocolInitializerDeclarationR4C3}
    protocolInitializerDeclarationR3C1 -> protocolInitializerDeclarationR4C1 [weight=100000000]
    protocolInitializerDeclarationR2C1 -> protocolInitializerDeclarationR3C1 [weight=100000000]
    protocolInitializerDeclarationR2C4 [label = <DKJ<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C4 [label = <DKI<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR4C4 [label = <DKK<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C4 -> protocolInitializerDeclarationR4C4 [weight=100000000]
    protocolInitializerDeclarationR2C4 -> protocolInitializerDeclarationR3C4 [weight=100000000]
    rank = same {protocolInitializerDeclarationR2C1 -> protocolInitializerDeclarationR2C4}
    protocolInitializerDeclarationR1C1 -> protocolInitializerDeclarationR2C1 [weight=100000000]
    protocolInitializerDeclarationR0C1 -> protocolInitializerDeclarationR1C1 [weight=100000000]
    protocolInitializerDeclarationR0C5 [label = <DKX<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolInitializerDeclarationR1C5 [label = <DKY<br/>N initializerHead<br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    protocolInitializerDeclarationR2C5 [label = <DLC<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C5 [label = <DLD<br/>N parameterClause<br/>fi ["("]<br/>fo ["rethrows"]<br/>am []<br/>>]
    protocolInitializerDeclarationR4C5 [label = <DLE<br/>T "rethrows"<br/>fi ["rethrows"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C5 [label = <DLI<br/>OPT <br/>fi ["", "where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C5 [label = <DLJ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR5C5 -> protocolInitializerDeclarationR6C5 [weight=100000000]
    protocolInitializerDeclarationR5C6 [label = <DLG<br/>ALT <br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C6 [label = <DLF<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR7C6 [label = <DLH<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolInitializerDeclarationR6C6 -> protocolInitializerDeclarationR7C6 [weight=100000000]
    protocolInitializerDeclarationR5C6 -> protocolInitializerDeclarationR6C6 [weight=100000000]
    rank = same {protocolInitializerDeclarationR5C5 -> protocolInitializerDeclarationR5C6}
    protocolInitializerDeclarationR4C5 -> protocolInitializerDeclarationR5C5 [weight=100000000]
    protocolInitializerDeclarationR3C5 -> protocolInitializerDeclarationR4C5 [weight=100000000]
    protocolInitializerDeclarationR2C5 -> protocolInitializerDeclarationR3C5 [weight=100000000]
    protocolInitializerDeclarationR2C7 [label = <DLA<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C7 [label = <DKZ<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR4C7 [label = <DLB<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    protocolInitializerDeclarationR3C7 -> protocolInitializerDeclarationR4C7 [weight=100000000]
    protocolInitializerDeclarationR2C7 -> protocolInitializerDeclarationR3C7 [weight=100000000]
    rank = same {protocolInitializerDeclarationR2C5 -> protocolInitializerDeclarationR2C7}
    protocolInitializerDeclarationR1C5 -> protocolInitializerDeclarationR2C5 [weight=100000000]
    protocolInitializerDeclarationR0C5 -> protocolInitializerDeclarationR1C5 [weight=100000000]
    rank = same {protocolInitializerDeclarationR0C1 -> protocolInitializerDeclarationR0C5}
    rank = same {protocolInitializerDeclarationR0C0 -> protocolInitializerDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolInitializerDeclarationR0C5 -> protocolInitializerDeclarationR0C6}
    rank = same {protocolInitializerDeclarationR0C6 -> protocolInitializerDeclarationR0C7}
    protocolInitializerDeclarationR0C0 -> protocolInitializerDeclarationR1C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR1C0 -> protocolInitializerDeclarationR1C1}
    rank = same {protocolInitializerDeclarationR1C1 -> protocolInitializerDeclarationR1C2}
    rank = same {protocolInitializerDeclarationR1C2 -> protocolInitializerDeclarationR1C3}
    rank = same {protocolInitializerDeclarationR1C3 -> protocolInitializerDeclarationR1C4}
    rank = same {protocolInitializerDeclarationR1C4 -> protocolInitializerDeclarationR1C5}
    protocolInitializerDeclarationR0C6 -> protocolInitializerDeclarationR1C6 [weight=100000000]
    rank = same {protocolInitializerDeclarationR1C5 -> protocolInitializerDeclarationR1C6}
    protocolInitializerDeclarationR0C7 -> protocolInitializerDeclarationR1C7 [weight=100000000]
    rank = same {protocolInitializerDeclarationR1C6 -> protocolInitializerDeclarationR1C7}
    protocolInitializerDeclarationR1C0 -> protocolInitializerDeclarationR2C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR2C0 -> protocolInitializerDeclarationR2C1}
    protocolInitializerDeclarationR1C4 -> protocolInitializerDeclarationR2C4 [weight=100000000]
    protocolInitializerDeclarationR1C7 -> protocolInitializerDeclarationR2C7 [weight=100000000]
    protocolInitializerDeclarationR2C0 -> protocolInitializerDeclarationR3C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR3C0 -> protocolInitializerDeclarationR3C1}
    rank = same {protocolInitializerDeclarationR3C1 -> protocolInitializerDeclarationR3C2}
    rank = same {protocolInitializerDeclarationR3C2 -> protocolInitializerDeclarationR3C3}
    rank = same {protocolInitializerDeclarationR3C3 -> protocolInitializerDeclarationR3C4}
    rank = same {protocolInitializerDeclarationR3C5 -> protocolInitializerDeclarationR3C6}
    rank = same {protocolInitializerDeclarationR3C6 -> protocolInitializerDeclarationR3C7}
    protocolInitializerDeclarationR3C0 -> protocolInitializerDeclarationR4C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR4C0 -> protocolInitializerDeclarationR4C1}
    protocolInitializerDeclarationR3C3 -> protocolInitializerDeclarationR4C3 [weight=100000000]
    protocolInitializerDeclarationR3C6 -> protocolInitializerDeclarationR4C6 [weight=100000000]
    rank = same {protocolInitializerDeclarationR4C5 -> protocolInitializerDeclarationR4C6}
    rank = same {protocolInitializerDeclarationR4C6 -> protocolInitializerDeclarationR4C7}
    protocolInitializerDeclarationR4C0 -> protocolInitializerDeclarationR5C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR5C0 -> protocolInitializerDeclarationR5C1}
    protocolInitializerDeclarationR4C4 -> protocolInitializerDeclarationR5C4 [weight=100000000]
    rank = same {protocolInitializerDeclarationR5C3 -> protocolInitializerDeclarationR5C4}
    rank = same {protocolInitializerDeclarationR5C4 -> protocolInitializerDeclarationR5C5}
    protocolInitializerDeclarationR4C6 -> protocolInitializerDeclarationR5C6 [weight=100000000]
    protocolInitializerDeclarationR4C7 -> protocolInitializerDeclarationR5C7 [weight=100000000]
    rank = same {protocolInitializerDeclarationR5C6 -> protocolInitializerDeclarationR5C7}
    protocolInitializerDeclarationR5C0 -> protocolInitializerDeclarationR6C0 [weight=100000000]
    rank = same {protocolInitializerDeclarationR6C0 -> protocolInitializerDeclarationR6C1}
    protocolInitializerDeclarationR5C4 -> protocolInitializerDeclarationR6C4 [weight=100000000]
    rank = same {protocolInitializerDeclarationR6C3 -> protocolInitializerDeclarationR6C4}
    rank = same {protocolInitializerDeclarationR6C4 -> protocolInitializerDeclarationR6C5}
    protocolInitializerDeclarationR5C7 -> protocolInitializerDeclarationR6C7 [weight=100000000]
    rank = same {protocolInitializerDeclarationR6C6 -> protocolInitializerDeclarationR6C7}
    protocolInitializerDeclarationR6C0 -> protocolInitializerDeclarationR7C0 [weight=100000000]
    protocolInitializerDeclarationR6C1 -> protocolInitializerDeclarationR7C1 [weight=100000000]
    rank = same {protocolInitializerDeclarationR7C0 -> protocolInitializerDeclarationR7C1}
    rank = same {protocolInitializerDeclarationR7C1 -> protocolInitializerDeclarationR7C2}
    protocolInitializerDeclarationR6C3 -> protocolInitializerDeclarationR7C3 [weight=100000000]
    rank = same {protocolInitializerDeclarationR7C2 -> protocolInitializerDeclarationR7C3}
    protocolInitializerDeclarationR6C4 -> protocolInitializerDeclarationR7C4 [weight=100000000]
    rank = same {protocolInitializerDeclarationR7C3 -> protocolInitializerDeclarationR7C4}
    protocolInitializerDeclarationR6C5 -> protocolInitializerDeclarationR7C5 [weight=100000000]
    rank = same {protocolInitializerDeclarationR7C4 -> protocolInitializerDeclarationR7C5}
    rank = same {protocolInitializerDeclarationR7C5 -> protocolInitializerDeclarationR7C6}
    protocolInitializerDeclarationR6C7 -> protocolInitializerDeclarationR7C7 [weight=100000000]
    rank = same {protocolInitializerDeclarationR7C6 -> protocolInitializerDeclarationR7C7}
  }
  subgraph clusterenumDeclaration {
    node [shape = box]
    label = <enumDeclaration = [ attributes ] [ accessLevelModifier ] unionStyleEnum | [ attributes ] [ accessLevelModifier ] rawValueStyleEnum .>
    labeljust = l
    enumDeclarationR0C0 [label = <CSV<br/>N enumDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    enumDeclarationR0C1 [label = <CSK<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    enumDeclarationR1C1 [label = <CSO<br/>OPT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "fileprivate", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "internal", "open", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "public", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    enumDeclarationR2C1 [label = <CSS<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C1 [label = <CST<br/>N unionStyleEnum<br/>fi ["", "indirect"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR4C1 [label = <CSU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C1 -> enumDeclarationR4C1 [weight=100000000]
    enumDeclarationR2C1 -> enumDeclarationR3C1 [weight=100000000]
    enumDeclarationR2C2 [label = <CSQ<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C2 [label = <CSP<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR4C2 [label = <CSR<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C2 -> enumDeclarationR4C2 [weight=100000000]
    enumDeclarationR2C2 -> enumDeclarationR3C2 [weight=100000000]
    rank = same {enumDeclarationR2C1 -> enumDeclarationR2C2}
    enumDeclarationR1C1 -> enumDeclarationR2C1 [weight=100000000]
    enumDeclarationR1C3 [label = <CSM<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "fileprivate", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "internal", "open", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "public", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR2C3 [label = <CSL<br/>N attributes<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "fileprivate", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "internal", "open", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "public", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C3 [label = <CSN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "fileprivate", "for", "guard", "if", "implicitParameterName", "indirect", "infix", "internal", "open", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "public", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR2C3 -> enumDeclarationR3C3 [weight=100000000]
    enumDeclarationR1C3 -> enumDeclarationR2C3 [weight=100000000]
    rank = same {enumDeclarationR1C1 -> enumDeclarationR1C3}
    enumDeclarationR0C1 -> enumDeclarationR1C1 [weight=100000000]
    enumDeclarationR0C4 [label = <CSW<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    enumDeclarationR1C4 [label = <CTA<br/>OPT <br/>fi ["", "@"]<br/>fo ["enum", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    enumDeclarationR2C4 [label = <CTE<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["enum"]<br/>am []<br/>>]
    enumDeclarationR3C4 [label = <CTF<br/>N rawValueStyleEnum<br/>fi ["enum"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR4C4 [label = <CTG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    enumDeclarationR3C4 -> enumDeclarationR4C4 [weight=100000000]
    enumDeclarationR2C4 -> enumDeclarationR3C4 [weight=100000000]
    enumDeclarationR2C5 [label = <CTC<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["enum"]<br/>am []<br/>>]
    enumDeclarationR3C5 [label = <CTB<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["enum"]<br/>am []<br/>>]
    enumDeclarationR4C5 [label = <CTD<br/>END <br/>fi [""]<br/>fo ["enum"]<br/>am []<br/>>]
    enumDeclarationR3C5 -> enumDeclarationR4C5 [weight=100000000]
    enumDeclarationR2C5 -> enumDeclarationR3C5 [weight=100000000]
    rank = same {enumDeclarationR2C4 -> enumDeclarationR2C5}
    enumDeclarationR1C4 -> enumDeclarationR2C4 [weight=100000000]
    enumDeclarationR1C6 [label = <CSY<br/>ALT <br/>fi ["@"]<br/>fo ["enum", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    enumDeclarationR2C6 [label = <CSX<br/>N attributes<br/>fi ["@"]<br/>fo ["enum", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    enumDeclarationR3C6 [label = <CSZ<br/>END <br/>fi [""]<br/>fo ["enum", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    enumDeclarationR2C6 -> enumDeclarationR3C6 [weight=100000000]
    enumDeclarationR1C6 -> enumDeclarationR2C6 [weight=100000000]
    rank = same {enumDeclarationR1C4 -> enumDeclarationR1C6}
    enumDeclarationR0C4 -> enumDeclarationR1C4 [weight=100000000]
    rank = same {enumDeclarationR0C1 -> enumDeclarationR0C4}
    rank = same {enumDeclarationR0C0 -> enumDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {enumDeclarationR0C4 -> enumDeclarationR0C5}
    rank = same {enumDeclarationR0C5 -> enumDeclarationR0C6}
    enumDeclarationR0C0 -> enumDeclarationR1C0 [weight=100000000]
    rank = same {enumDeclarationR1C0 -> enumDeclarationR1C1}
    enumDeclarationR0C6 -> enumDeclarationR1C6 [weight=100000000]
    enumDeclarationR1C0 -> enumDeclarationR2C0 [weight=100000000]
    rank = same {enumDeclarationR2C0 -> enumDeclarationR2C1}
    enumDeclarationR2C0 -> enumDeclarationR3C0 [weight=100000000]
    rank = same {enumDeclarationR3C0 -> enumDeclarationR3C1}
    enumDeclarationR3C0 -> enumDeclarationR4C0 [weight=100000000]
    rank = same {enumDeclarationR4C0 -> enumDeclarationR4C1}
    enumDeclarationR3C3 -> enumDeclarationR4C3 [weight=100000000]
    rank = same {enumDeclarationR4C2 -> enumDeclarationR4C3}
    rank = same {enumDeclarationR4C3 -> enumDeclarationR4C4}
    enumDeclarationR3C6 -> enumDeclarationR4C6 [weight=100000000]
    rank = same {enumDeclarationR4C5 -> enumDeclarationR4C6}
  }
  subgraph clustertryOperator {
    node [shape = box]
    label = <tryOperator = "try" | "try" "?" | "try" "!" .>
    labeljust = l
    tryOperatorR0C0 [label = <PX<br/>N tryOperator<br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["try"]<br/>>]
    tryOperatorR0C1 [label = <PM<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR1C1 [label = <PN<br/>T "try"<br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR2C1 [label = <PO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR1C1 -> tryOperatorR2C1 [weight=100000000]
    tryOperatorR0C1 -> tryOperatorR1C1 [weight=100000000]
    tryOperatorR0C2 [label = <PP<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR1C2 [label = <PQ<br/>T "try"<br/>fi ["try"]<br/>fo ["?"]<br/>am []<br/>>]
    tryOperatorR2C2 [label = <PR<br/>T "?"<br/>fi ["?"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR3C2 [label = <PS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR2C2 -> tryOperatorR3C2 [weight=100000000]
    tryOperatorR1C2 -> tryOperatorR2C2 [weight=100000000]
    tryOperatorR0C2 -> tryOperatorR1C2 [weight=100000000]
    tryOperatorR0C3 [label = <PT<br/>ALT <br/>fi ["try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR1C3 [label = <PU<br/>T "try"<br/>fi ["try"]<br/>fo ["!"]<br/>am []<br/>>]
    tryOperatorR2C3 [label = <PV<br/>T "!"<br/>fi ["!"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR3C3 [label = <PW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", ")", ",", ":", ";", "=", "?", "@", "]", "as", "await", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tryOperatorR2C3 -> tryOperatorR3C3 [weight=100000000]
    tryOperatorR1C3 -> tryOperatorR2C3 [weight=100000000]
    tryOperatorR0C3 -> tryOperatorR1C3 [weight=100000000]
    rank = same {tryOperatorR0C2 -> tryOperatorR0C3}
    rank = same {tryOperatorR0C1 -> tryOperatorR0C2}
    rank = same {tryOperatorR0C0 -> tryOperatorR0C1}
    node [style = invis]
    edge [style = invis]
    tryOperatorR0C0 -> tryOperatorR1C0 [weight=100000000]
    rank = same {tryOperatorR1C0 -> tryOperatorR1C1}
    tryOperatorR1C0 -> tryOperatorR2C0 [weight=100000000]
    rank = same {tryOperatorR2C0 -> tryOperatorR2C1}
    tryOperatorR2C0 -> tryOperatorR3C0 [weight=100000000]
    tryOperatorR2C1 -> tryOperatorR3C1 [weight=100000000]
    rank = same {tryOperatorR3C0 -> tryOperatorR3C1}
    rank = same {tryOperatorR3C1 -> tryOperatorR3C2}
  }
  subgraph clusterconditionalCompilationBlock {
    node [shape = box]
    label = <conditionalCompilationBlock = ifDirectiveClause [ elseifDirectiveClauses ] [ elseDirectiveClause ] endifDirective .>
    labeljust = l
    conditionalCompilationBlockR0C0 [label = <BMI<br/>N conditionalCompilationBlock<br/>fi ["#if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalCompilationBlockR0C1 [label = <BLW<br/>ALT <br/>fi ["#if"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalCompilationBlockR1C1 [label = <BLX<br/>N ifDirectiveClause<br/>fi ["#if"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR2C1 [label = <BMB<br/>OPT <br/>fi ["", "#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR3C1 [label = <BMF<br/>OPT <br/>fi ["", "#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR4C1 [label = <BMG<br/>N endifDirective<br/>fi ["#endif"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalCompilationBlockR5C1 [label = <BMH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    conditionalCompilationBlockR4C1 -> conditionalCompilationBlockR5C1 [weight=100000000]
    conditionalCompilationBlockR3C1 -> conditionalCompilationBlockR4C1 [weight=100000000]
    conditionalCompilationBlockR3C2 [label = <BMD<br/>ALT <br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR4C2 [label = <BMC<br/>N elseDirectiveClause<br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR5C2 [label = <BME<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR4C2 -> conditionalCompilationBlockR5C2 [weight=100000000]
    conditionalCompilationBlockR3C2 -> conditionalCompilationBlockR4C2 [weight=100000000]
    rank = same {conditionalCompilationBlockR3C1 -> conditionalCompilationBlockR3C2}
    conditionalCompilationBlockR2C1 -> conditionalCompilationBlockR3C1 [weight=100000000]
    conditionalCompilationBlockR2C3 [label = <BLZ<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR3C3 [label = <BLY<br/>N elseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR4C3 [label = <BMA<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    conditionalCompilationBlockR3C3 -> conditionalCompilationBlockR4C3 [weight=100000000]
    conditionalCompilationBlockR2C3 -> conditionalCompilationBlockR3C3 [weight=100000000]
    rank = same {conditionalCompilationBlockR2C1 -> conditionalCompilationBlockR2C3}
    conditionalCompilationBlockR1C1 -> conditionalCompilationBlockR2C1 [weight=100000000]
    conditionalCompilationBlockR0C1 -> conditionalCompilationBlockR1C1 [weight=100000000]
    rank = same {conditionalCompilationBlockR0C0 -> conditionalCompilationBlockR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {conditionalCompilationBlockR0C1 -> conditionalCompilationBlockR0C2}
    rank = same {conditionalCompilationBlockR0C2 -> conditionalCompilationBlockR0C3}
    conditionalCompilationBlockR0C0 -> conditionalCompilationBlockR1C0 [weight=100000000]
    rank = same {conditionalCompilationBlockR1C0 -> conditionalCompilationBlockR1C1}
    conditionalCompilationBlockR0C2 -> conditionalCompilationBlockR1C2 [weight=100000000]
    rank = same {conditionalCompilationBlockR1C1 -> conditionalCompilationBlockR1C2}
    conditionalCompilationBlockR0C3 -> conditionalCompilationBlockR1C3 [weight=100000000]
    rank = same {conditionalCompilationBlockR1C2 -> conditionalCompilationBlockR1C3}
    conditionalCompilationBlockR1C0 -> conditionalCompilationBlockR2C0 [weight=100000000]
    rank = same {conditionalCompilationBlockR2C0 -> conditionalCompilationBlockR2C1}
    conditionalCompilationBlockR1C3 -> conditionalCompilationBlockR2C3 [weight=100000000]
    conditionalCompilationBlockR2C0 -> conditionalCompilationBlockR3C0 [weight=100000000]
    rank = same {conditionalCompilationBlockR3C0 -> conditionalCompilationBlockR3C1}
    conditionalCompilationBlockR3C0 -> conditionalCompilationBlockR4C0 [weight=100000000]
    rank = same {conditionalCompilationBlockR4C0 -> conditionalCompilationBlockR4C1}
    conditionalCompilationBlockR4C0 -> conditionalCompilationBlockR5C0 [weight=100000000]
    rank = same {conditionalCompilationBlockR5C0 -> conditionalCompilationBlockR5C1}
    conditionalCompilationBlockR4C3 -> conditionalCompilationBlockR5C3 [weight=100000000]
    rank = same {conditionalCompilationBlockR5C2 -> conditionalCompilationBlockR5C3}
  }
  subgraph clusterfunctionSignature {
    node [shape = box]
    label = <functionSignature = parameterClause [ "async" ] [ throwsClause ] [ functionResult ] | parameterClause [ "async" ] "rethrows" [ functionResult ] .>
    labeljust = l
    functionSignatureR0C0 [label = <COD<br/>N functionSignature<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    functionSignatureR0C1 [label = <CNO<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR1C1 [label = <CNP<br/>N parameterClause<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "async", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR2C1 [label = <CNT<br/>OPT <br/>fi ["", "async"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR3C1 [label = <CNX<br/>OPT <br/>fi ["", "throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C1 [label = <COB<br/>OPT <br/>fi ["", "&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C1 [label = <COC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C1 -> functionSignatureR5C1 [weight=100000000]
    functionSignatureR4C2 [label = <CNZ<br/>ALT <br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C2 [label = <CNY<br/>N functionResult<br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR6C2 [label = <COA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C2 -> functionSignatureR6C2 [weight=100000000]
    functionSignatureR4C2 -> functionSignatureR5C2 [weight=100000000]
    rank = same {functionSignatureR4C1 -> functionSignatureR4C2}
    functionSignatureR3C1 -> functionSignatureR4C1 [weight=100000000]
    functionSignatureR3C3 [label = <CNV<br/>ALT <br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C3 [label = <CNU<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C3 [label = <CNW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C3 -> functionSignatureR5C3 [weight=100000000]
    functionSignatureR3C3 -> functionSignatureR4C3 [weight=100000000]
    rank = same {functionSignatureR3C1 -> functionSignatureR3C3}
    functionSignatureR2C1 -> functionSignatureR3C1 [weight=100000000]
    functionSignatureR2C4 [label = <CNR<br/>ALT <br/>fi ["async"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR3C4 [label = <CNQ<br/>T "async"<br/>fi ["async"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C4 [label = <CNS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "throws", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR3C4 -> functionSignatureR4C4 [weight=100000000]
    functionSignatureR2C4 -> functionSignatureR3C4 [weight=100000000]
    rank = same {functionSignatureR2C1 -> functionSignatureR2C4}
    functionSignatureR1C1 -> functionSignatureR2C1 [weight=100000000]
    functionSignatureR0C1 -> functionSignatureR1C1 [weight=100000000]
    functionSignatureR0C5 [label = <COE<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR1C5 [label = <COF<br/>N parameterClause<br/>fi ["("]<br/>fo ["async", "rethrows"]<br/>am []<br/>>]
    functionSignatureR2C5 [label = <COJ<br/>OPT <br/>fi ["", "async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    functionSignatureR3C5 [label = <COK<br/>T "rethrows"<br/>fi ["rethrows"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C5 [label = <COO<br/>OPT <br/>fi ["", "&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C5 [label = <COP<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR4C5 -> functionSignatureR5C5 [weight=100000000]
    functionSignatureR4C6 [label = <COM<br/>ALT <br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C6 [label = <COL<br/>N functionResult<br/>fi ["&gt;"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR6C6 [label = <CON<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    functionSignatureR5C6 -> functionSignatureR6C6 [weight=100000000]
    functionSignatureR4C6 -> functionSignatureR5C6 [weight=100000000]
    rank = same {functionSignatureR4C5 -> functionSignatureR4C6}
    functionSignatureR3C5 -> functionSignatureR4C5 [weight=100000000]
    functionSignatureR2C5 -> functionSignatureR3C5 [weight=100000000]
    functionSignatureR2C7 [label = <COH<br/>ALT <br/>fi ["async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    functionSignatureR3C7 [label = <COG<br/>T "async"<br/>fi ["async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    functionSignatureR4C7 [label = <COI<br/>END <br/>fi [""]<br/>fo ["rethrows"]<br/>am []<br/>>]
    functionSignatureR3C7 -> functionSignatureR4C7 [weight=100000000]
    functionSignatureR2C7 -> functionSignatureR3C7 [weight=100000000]
    rank = same {functionSignatureR2C5 -> functionSignatureR2C7}
    functionSignatureR1C5 -> functionSignatureR2C5 [weight=100000000]
    functionSignatureR0C5 -> functionSignatureR1C5 [weight=100000000]
    rank = same {functionSignatureR0C1 -> functionSignatureR0C5}
    rank = same {functionSignatureR0C0 -> functionSignatureR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {functionSignatureR0C5 -> functionSignatureR0C6}
    rank = same {functionSignatureR0C6 -> functionSignatureR0C7}
    functionSignatureR0C0 -> functionSignatureR1C0 [weight=100000000]
    rank = same {functionSignatureR1C0 -> functionSignatureR1C1}
    rank = same {functionSignatureR1C1 -> functionSignatureR1C2}
    rank = same {functionSignatureR1C2 -> functionSignatureR1C3}
    rank = same {functionSignatureR1C3 -> functionSignatureR1C4}
    rank = same {functionSignatureR1C4 -> functionSignatureR1C5}
    functionSignatureR0C6 -> functionSignatureR1C6 [weight=100000000]
    rank = same {functionSignatureR1C5 -> functionSignatureR1C6}
    functionSignatureR0C7 -> functionSignatureR1C7 [weight=100000000]
    rank = same {functionSignatureR1C6 -> functionSignatureR1C7}
    functionSignatureR1C0 -> functionSignatureR2C0 [weight=100000000]
    rank = same {functionSignatureR2C0 -> functionSignatureR2C1}
    functionSignatureR1C4 -> functionSignatureR2C4 [weight=100000000]
    functionSignatureR1C7 -> functionSignatureR2C7 [weight=100000000]
    functionSignatureR2C0 -> functionSignatureR3C0 [weight=100000000]
    rank = same {functionSignatureR3C0 -> functionSignatureR3C1}
    rank = same {functionSignatureR3C5 -> functionSignatureR3C6}
    rank = same {functionSignatureR3C6 -> functionSignatureR3C7}
    functionSignatureR3C0 -> functionSignatureR4C0 [weight=100000000]
    rank = same {functionSignatureR4C0 -> functionSignatureR4C1}
    functionSignatureR3C6 -> functionSignatureR4C6 [weight=100000000]
    functionSignatureR4C0 -> functionSignatureR5C0 [weight=100000000]
    rank = same {functionSignatureR5C0 -> functionSignatureR5C1}
    functionSignatureR4C4 -> functionSignatureR5C4 [weight=100000000]
    rank = same {functionSignatureR5C3 -> functionSignatureR5C4}
    rank = same {functionSignatureR5C4 -> functionSignatureR5C5}
    functionSignatureR4C7 -> functionSignatureR5C7 [weight=100000000]
    rank = same {functionSignatureR5C6 -> functionSignatureR5C7}
    functionSignatureR5C0 -> functionSignatureR6C0 [weight=100000000]
    functionSignatureR5C1 -> functionSignatureR6C1 [weight=100000000]
    rank = same {functionSignatureR6C0 -> functionSignatureR6C1}
    rank = same {functionSignatureR6C1 -> functionSignatureR6C2}
    functionSignatureR5C3 -> functionSignatureR6C3 [weight=100000000]
    rank = same {functionSignatureR6C2 -> functionSignatureR6C3}
    functionSignatureR5C4 -> functionSignatureR6C4 [weight=100000000]
    rank = same {functionSignatureR6C3 -> functionSignatureR6C4}
    functionSignatureR5C5 -> functionSignatureR6C5 [weight=100000000]
    rank = same {functionSignatureR6C4 -> functionSignatureR6C5}
    rank = same {functionSignatureR6C5 -> functionSignatureR6C6}
    functionSignatureR5C7 -> functionSignatureR6C7 [weight=100000000]
    rank = same {functionSignatureR6C6 -> functionSignatureR6C7}
  }
  subgraph clusterdictionaryLiteral {
    node [shape = box]
    label = <dictionaryLiteral = "[" dictionaryLiteralItems "]" | "[" ":" "]" .>
    labeljust = l
    dictionaryLiteralR0C0 [label = <WL<br/>N dictionaryLiteral<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["["]<br/>>]
    dictionaryLiteralR0C1 [label = <WB<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR1C1 [label = <WC<br/>T "["<br/>fi ["["]<br/>fo ["]", "try"]<br/>am []<br/>>]
    dictionaryLiteralR2C1 [label = <WD<br/>N dictionaryLiteralItems<br/>fi ["", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralR3C1 [label = <WE<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR4C1 [label = <WF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR3C1 -> dictionaryLiteralR4C1 [weight=100000000]
    dictionaryLiteralR2C1 -> dictionaryLiteralR3C1 [weight=100000000]
    dictionaryLiteralR1C1 -> dictionaryLiteralR2C1 [weight=100000000]
    dictionaryLiteralR0C1 -> dictionaryLiteralR1C1 [weight=100000000]
    dictionaryLiteralR0C2 [label = <WG<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR1C2 [label = <WH<br/>T "["<br/>fi ["["]<br/>fo [":"]<br/>am []<br/>>]
    dictionaryLiteralR2C2 [label = <WI<br/>T ":"<br/>fi [":"]<br/>fo ["]"]<br/>am []<br/>>]
    dictionaryLiteralR3C2 [label = <WJ<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR4C2 [label = <WK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    dictionaryLiteralR3C2 -> dictionaryLiteralR4C2 [weight=100000000]
    dictionaryLiteralR2C2 -> dictionaryLiteralR3C2 [weight=100000000]
    dictionaryLiteralR1C2 -> dictionaryLiteralR2C2 [weight=100000000]
    dictionaryLiteralR0C2 -> dictionaryLiteralR1C2 [weight=100000000]
    rank = same {dictionaryLiteralR0C1 -> dictionaryLiteralR0C2}
    rank = same {dictionaryLiteralR0C0 -> dictionaryLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    dictionaryLiteralR0C0 -> dictionaryLiteralR1C0 [weight=100000000]
    rank = same {dictionaryLiteralR1C0 -> dictionaryLiteralR1C1}
    dictionaryLiteralR1C0 -> dictionaryLiteralR2C0 [weight=100000000]
    rank = same {dictionaryLiteralR2C0 -> dictionaryLiteralR2C1}
    dictionaryLiteralR2C0 -> dictionaryLiteralR3C0 [weight=100000000]
    rank = same {dictionaryLiteralR3C0 -> dictionaryLiteralR3C1}
    dictionaryLiteralR3C0 -> dictionaryLiteralR4C0 [weight=100000000]
    rank = same {dictionaryLiteralR4C0 -> dictionaryLiteralR4C1}
  }
  subgraph clusterpatternInitializer {
    node [shape = box]
    label = <patternInitializer = pattern [ initializer ] .>
    labeljust = l
    patternInitializerR0C0 [label = <CDJ<br/>N patternInitializer<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerR0C1 [label = <CDC<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerR1C1 [label = <CDD<br/>N pattern<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "=", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerR2C1 [label = <CDH<br/>OPT <br/>fi ["", "="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerR3C1 [label = <CDI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerR2C1 -> patternInitializerR3C1 [weight=100000000]
    patternInitializerR2C2 [label = <CDF<br/>ALT <br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerR3C2 [label = <CDE<br/>N initializer<br/>fi ["="]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerR4C2 [label = <CDG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ",", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerR3C2 -> patternInitializerR4C2 [weight=100000000]
    patternInitializerR2C2 -> patternInitializerR3C2 [weight=100000000]
    rank = same {patternInitializerR2C1 -> patternInitializerR2C2}
    patternInitializerR1C1 -> patternInitializerR2C1 [weight=100000000]
    patternInitializerR0C1 -> patternInitializerR1C1 [weight=100000000]
    rank = same {patternInitializerR0C0 -> patternInitializerR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {patternInitializerR0C1 -> patternInitializerR0C2}
    patternInitializerR0C0 -> patternInitializerR1C0 [weight=100000000]
    rank = same {patternInitializerR1C0 -> patternInitializerR1C1}
    patternInitializerR0C2 -> patternInitializerR1C2 [weight=100000000]
    rank = same {patternInitializerR1C1 -> patternInitializerR1C2}
    patternInitializerR1C0 -> patternInitializerR2C0 [weight=100000000]
    rank = same {patternInitializerR2C0 -> patternInitializerR2C1}
    patternInitializerR1C2 -> patternInitializerR2C2 [weight=100000000]
    patternInitializerR2C0 -> patternInitializerR3C0 [weight=100000000]
    rank = same {patternInitializerR3C0 -> patternInitializerR3C1}
    patternInitializerR3C0 -> patternInitializerR4C0 [weight=100000000]
    patternInitializerR3C1 -> patternInitializerR4C1 [weight=100000000]
    rank = same {patternInitializerR4C0 -> patternInitializerR4C1}
    rank = same {patternInitializerR4C1 -> patternInitializerR4C2}
  }
  subgraph clusterrawValueStyleEnumCaseList {
    node [shape = box]
    label = <rawValueStyleEnumCaseList = rawValueStyleEnumCase | rawValueStyleEnumCase "," rawValueStyleEnumCaseList .>
    labeljust = l
    rawValueStyleEnumCaseListR0C0 [label = <CYM<br/>N rawValueStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    rawValueStyleEnumCaseListR0C1 [label = <CYE<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR1C1 [label = <CYF<br/>N rawValueStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR2C1 [label = <CYG<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR1C1 -> rawValueStyleEnumCaseListR2C1 [weight=100000000]
    rawValueStyleEnumCaseListR0C1 -> rawValueStyleEnumCaseListR1C1 [weight=100000000]
    rawValueStyleEnumCaseListR0C2 [label = <CYH<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR1C2 [label = <CYI<br/>N rawValueStyleEnumCase<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR2C2 [label = <CYJ<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR3C2 [label = <CYK<br/>N rawValueStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR4C2 [label = <CYL<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseListR3C2 -> rawValueStyleEnumCaseListR4C2 [weight=100000000]
    rawValueStyleEnumCaseListR2C2 -> rawValueStyleEnumCaseListR3C2 [weight=100000000]
    rawValueStyleEnumCaseListR1C2 -> rawValueStyleEnumCaseListR2C2 [weight=100000000]
    rawValueStyleEnumCaseListR0C2 -> rawValueStyleEnumCaseListR1C2 [weight=100000000]
    rank = same {rawValueStyleEnumCaseListR0C1 -> rawValueStyleEnumCaseListR0C2}
    rank = same {rawValueStyleEnumCaseListR0C0 -> rawValueStyleEnumCaseListR0C1}
    node [style = invis]
    edge [style = invis]
    rawValueStyleEnumCaseListR0C0 -> rawValueStyleEnumCaseListR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseListR1C0 -> rawValueStyleEnumCaseListR1C1}
    rawValueStyleEnumCaseListR1C0 -> rawValueStyleEnumCaseListR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseListR2C0 -> rawValueStyleEnumCaseListR2C1}
    rawValueStyleEnumCaseListR2C0 -> rawValueStyleEnumCaseListR3C0 [weight=100000000]
    rawValueStyleEnumCaseListR2C1 -> rawValueStyleEnumCaseListR3C1 [weight=100000000]
    rank = same {rawValueStyleEnumCaseListR3C0 -> rawValueStyleEnumCaseListR3C1}
    rank = same {rawValueStyleEnumCaseListR3C1 -> rawValueStyleEnumCaseListR3C2}
    rawValueStyleEnumCaseListR3C0 -> rawValueStyleEnumCaseListR4C0 [weight=100000000]
    rawValueStyleEnumCaseListR3C1 -> rawValueStyleEnumCaseListR4C1 [weight=100000000]
    rank = same {rawValueStyleEnumCaseListR4C0 -> rawValueStyleEnumCaseListR4C1}
    rank = same {rawValueStyleEnumCaseListR4C1 -> rawValueStyleEnumCaseListR4C2}
  }
  subgraph clusterwhileStatement {
    node [shape = box]
    label = <whileStatement = "while" conditionList codeBlock .>
    labeljust = l
    whileStatementR0C0 [label = <AYL<br/>N whileStatement<br/>fi ["while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    whileStatementR0C1 [label = <AYG<br/>ALT <br/>fi ["while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    whileStatementR1C1 [label = <AYH<br/>T "while"<br/>fi ["while"]<br/>fo ["#available", "#unavailable", "case", "let", "try", "var", "{"]<br/>am []<br/>>]
    whileStatementR2C1 [label = <AYI<br/>N conditionList<br/>fi ["", "#available", "#unavailable", "case", "let", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    whileStatementR3C1 [label = <AYJ<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    whileStatementR4C1 [label = <AYK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    whileStatementR3C1 -> whileStatementR4C1 [weight=100000000]
    whileStatementR2C1 -> whileStatementR3C1 [weight=100000000]
    whileStatementR1C1 -> whileStatementR2C1 [weight=100000000]
    whileStatementR0C1 -> whileStatementR1C1 [weight=100000000]
    rank = same {whileStatementR0C0 -> whileStatementR0C1}
    node [style = invis]
    edge [style = invis]
    whileStatementR0C0 -> whileStatementR1C0 [weight=100000000]
    rank = same {whileStatementR1C0 -> whileStatementR1C1}
    whileStatementR1C0 -> whileStatementR2C0 [weight=100000000]
    rank = same {whileStatementR2C0 -> whileStatementR2C1}
    whileStatementR2C0 -> whileStatementR3C0 [weight=100000000]
    rank = same {whileStatementR3C0 -> whileStatementR3C1}
    whileStatementR3C0 -> whileStatementR4C0 [weight=100000000]
    rank = same {whileStatementR4C0 -> whileStatementR4C1}
  }
  subgraph clusterelseifDirective {
    node [shape = box]
    label = <elseifDirective = "#elseif" .>
    labeljust = l
    elseifDirectiveR0C0 [label = <BNY<br/>N elseifDirective<br/>fi ["#elseif"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    elseifDirectiveR0C1 [label = <BNV<br/>ALT <br/>fi ["#elseif"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    elseifDirectiveR1C1 [label = <BNW<br/>T "#elseif"<br/>fi ["#elseif"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    elseifDirectiveR2C1 [label = <BNX<br/>END <br/>fi [""]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    elseifDirectiveR1C1 -> elseifDirectiveR2C1 [weight=100000000]
    elseifDirectiveR0C1 -> elseifDirectiveR1C1 [weight=100000000]
    rank = same {elseifDirectiveR0C0 -> elseifDirectiveR0C1}
    node [style = invis]
    edge [style = invis]
    elseifDirectiveR0C0 -> elseifDirectiveR1C0 [weight=100000000]
    rank = same {elseifDirectiveR1C0 -> elseifDirectiveR1C1}
    elseifDirectiveR1C0 -> elseifDirectiveR2C0 [weight=100000000]
    rank = same {elseifDirectiveR2C0 -> elseifDirectiveR2C1}
  }
  subgraph clusterfunctionTypeArgumentList {
    node [shape = box]
    label = <functionTypeArgumentList = functionTypeArgument | functionTypeArgument "," functionTypeArgumentList .>
    labeljust = l
    functionTypeArgumentListR0C0 [label = <JR<br/>N functionTypeArgumentList<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    functionTypeArgumentListR0C1 [label = <JJ<br/>ALT <br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR1C1 [label = <JK<br/>N functionTypeArgument<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR2C1 [label = <JL<br/>END <br/>fi [""]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR1C1 -> functionTypeArgumentListR2C1 [weight=100000000]
    functionTypeArgumentListR0C1 -> functionTypeArgumentListR1C1 [weight=100000000]
    functionTypeArgumentListR0C2 [label = <JM<br/>ALT <br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR1C2 [label = <JN<br/>N functionTypeArgument<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    functionTypeArgumentListR2C2 [label = <JO<br/>T ","<br/>fi [","]<br/>fo [")", "...", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    functionTypeArgumentListR3C2 [label = <JP<br/>N functionTypeArgumentList<br/>fi ["", "@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR4C2 [label = <JQ<br/>END <br/>fi [""]<br/>fo [")", "..."]<br/>am []<br/>>]
    functionTypeArgumentListR3C2 -> functionTypeArgumentListR4C2 [weight=100000000]
    functionTypeArgumentListR2C2 -> functionTypeArgumentListR3C2 [weight=100000000]
    functionTypeArgumentListR1C2 -> functionTypeArgumentListR2C2 [weight=100000000]
    functionTypeArgumentListR0C2 -> functionTypeArgumentListR1C2 [weight=100000000]
    rank = same {functionTypeArgumentListR0C1 -> functionTypeArgumentListR0C2}
    rank = same {functionTypeArgumentListR0C0 -> functionTypeArgumentListR0C1}
    node [style = invis]
    edge [style = invis]
    functionTypeArgumentListR0C0 -> functionTypeArgumentListR1C0 [weight=100000000]
    rank = same {functionTypeArgumentListR1C0 -> functionTypeArgumentListR1C1}
    functionTypeArgumentListR1C0 -> functionTypeArgumentListR2C0 [weight=100000000]
    rank = same {functionTypeArgumentListR2C0 -> functionTypeArgumentListR2C1}
    functionTypeArgumentListR2C0 -> functionTypeArgumentListR3C0 [weight=100000000]
    functionTypeArgumentListR2C1 -> functionTypeArgumentListR3C1 [weight=100000000]
    rank = same {functionTypeArgumentListR3C0 -> functionTypeArgumentListR3C1}
    rank = same {functionTypeArgumentListR3C1 -> functionTypeArgumentListR3C2}
    functionTypeArgumentListR3C0 -> functionTypeArgumentListR4C0 [weight=100000000]
    functionTypeArgumentListR3C1 -> functionTypeArgumentListR4C1 [weight=100000000]
    rank = same {functionTypeArgumentListR4C0 -> functionTypeArgumentListR4C1}
    rank = same {functionTypeArgumentListR4C1 -> functionTypeArgumentListR4C2}
  }
  subgraph clusterparenthesizedExpression {
    node [shape = box]
    label = <parenthesizedExpression = "(" expression ")" .>
    labeljust = l
    parenthesizedExpressionR0C0 [label = <AIS<br/>N parenthesizedExpression<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parenthesizedExpressionR0C1 [label = <AIN<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parenthesizedExpressionR1C1 [label = <AIO<br/>T "("<br/>fi ["("]<br/>fo [")", "try"]<br/>am []<br/>>]
    parenthesizedExpressionR2C1 [label = <AIP<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    parenthesizedExpressionR3C1 [label = <AIQ<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parenthesizedExpressionR4C1 [label = <AIR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    parenthesizedExpressionR3C1 -> parenthesizedExpressionR4C1 [weight=100000000]
    parenthesizedExpressionR2C1 -> parenthesizedExpressionR3C1 [weight=100000000]
    parenthesizedExpressionR1C1 -> parenthesizedExpressionR2C1 [weight=100000000]
    parenthesizedExpressionR0C1 -> parenthesizedExpressionR1C1 [weight=100000000]
    rank = same {parenthesizedExpressionR0C0 -> parenthesizedExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    parenthesizedExpressionR0C0 -> parenthesizedExpressionR1C0 [weight=100000000]
    rank = same {parenthesizedExpressionR1C0 -> parenthesizedExpressionR1C1}
    parenthesizedExpressionR1C0 -> parenthesizedExpressionR2C0 [weight=100000000]
    rank = same {parenthesizedExpressionR2C0 -> parenthesizedExpressionR2C1}
    parenthesizedExpressionR2C0 -> parenthesizedExpressionR3C0 [weight=100000000]
    rank = same {parenthesizedExpressionR3C0 -> parenthesizedExpressionR3C1}
    parenthesizedExpressionR3C0 -> parenthesizedExpressionR4C0 [weight=100000000]
    rank = same {parenthesizedExpressionR4C0 -> parenthesizedExpressionR4C1}
  }
  subgraph clusterswitchElseifDirectiveClauses {
    node [shape = box]
    label = <switchElseifDirectiveClauses = elseifDirectiveClause [ switchElseifDirectiveClauses ] .>
    labeljust = l
    switchElseifDirectiveClausesR0C0 [label = <BFX<br/>N switchElseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR0C1 [label = <BFQ<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR1C1 [label = <BFR<br/>N elseifDirectiveClause<br/>fi ["#elseif"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR2C1 [label = <BFV<br/>OPT <br/>fi ["", "#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR3C1 [label = <BFW<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR2C1 -> switchElseifDirectiveClausesR3C1 [weight=100000000]
    switchElseifDirectiveClausesR2C2 [label = <BFT<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR3C2 [label = <BFS<br/>N switchElseifDirectiveClauses<br/>fi ["#elseif"]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR4C2 [label = <BFU<br/>END <br/>fi [""]<br/>fo ["#else", "#endif"]<br/>am []<br/>>]
    switchElseifDirectiveClausesR3C2 -> switchElseifDirectiveClausesR4C2 [weight=100000000]
    switchElseifDirectiveClausesR2C2 -> switchElseifDirectiveClausesR3C2 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR2C1 -> switchElseifDirectiveClausesR2C2}
    switchElseifDirectiveClausesR1C1 -> switchElseifDirectiveClausesR2C1 [weight=100000000]
    switchElseifDirectiveClausesR0C1 -> switchElseifDirectiveClausesR1C1 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR0C0 -> switchElseifDirectiveClausesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchElseifDirectiveClausesR0C1 -> switchElseifDirectiveClausesR0C2}
    switchElseifDirectiveClausesR0C0 -> switchElseifDirectiveClausesR1C0 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR1C0 -> switchElseifDirectiveClausesR1C1}
    switchElseifDirectiveClausesR0C2 -> switchElseifDirectiveClausesR1C2 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR1C1 -> switchElseifDirectiveClausesR1C2}
    switchElseifDirectiveClausesR1C0 -> switchElseifDirectiveClausesR2C0 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR2C0 -> switchElseifDirectiveClausesR2C1}
    switchElseifDirectiveClausesR1C2 -> switchElseifDirectiveClausesR2C2 [weight=100000000]
    switchElseifDirectiveClausesR2C0 -> switchElseifDirectiveClausesR3C0 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR3C0 -> switchElseifDirectiveClausesR3C1}
    switchElseifDirectiveClausesR3C0 -> switchElseifDirectiveClausesR4C0 [weight=100000000]
    switchElseifDirectiveClausesR3C1 -> switchElseifDirectiveClausesR4C1 [weight=100000000]
    rank = same {switchElseifDirectiveClausesR4C0 -> switchElseifDirectiveClausesR4C1}
    rank = same {switchElseifDirectiveClausesR4C1 -> switchElseifDirectiveClausesR4C2}
  }
  subgraph clusterstructDeclaration {
    node [shape = box]
    label = <structDeclaration = [ attributes ] [ accessLevelModifier ] "struct" structName [ genericParameterClause ] [ typeInheritanceClause ] [ genericWhereClause ] structBody .>
    labeljust = l
    structDeclarationR0C0 [label = <DAJ<br/>N structDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    structDeclarationR0C1 [label = <CZK<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    structDeclarationR1C1 [label = <CZO<br/>OPT <br/>fi ["", "@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "struct"]<br/>am []<br/>>]
    structDeclarationR2C1 [label = <CZS<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["struct"]<br/>am []<br/>>]
    structDeclarationR3C1 [label = <CZT<br/>T "struct"<br/>fi ["struct"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    structDeclarationR4C1 [label = <CZU<br/>N structName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "&lt;", "where", "{"]<br/>am []<br/>>]
    structDeclarationR5C1 [label = <CZY<br/>OPT <br/>fi ["", "&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    structDeclarationR6C1 [label = <DAC<br/>OPT <br/>fi ["", ":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    structDeclarationR7C1 [label = <DAG<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    structDeclarationR8C1 [label = <DAH<br/>N structBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structDeclarationR9C1 [label = <DAI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structDeclarationR8C1 -> structDeclarationR9C1 [weight=100000000]
    structDeclarationR7C1 -> structDeclarationR8C1 [weight=100000000]
    structDeclarationR7C2 [label = <DAE<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    structDeclarationR8C2 [label = <DAD<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    structDeclarationR9C2 [label = <DAF<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    structDeclarationR8C2 -> structDeclarationR9C2 [weight=100000000]
    structDeclarationR7C2 -> structDeclarationR8C2 [weight=100000000]
    rank = same {structDeclarationR7C1 -> structDeclarationR7C2}
    structDeclarationR6C1 -> structDeclarationR7C1 [weight=100000000]
    structDeclarationR6C3 [label = <DAA<br/>ALT <br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    structDeclarationR7C3 [label = <CZZ<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    structDeclarationR8C3 [label = <DAB<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    structDeclarationR7C3 -> structDeclarationR8C3 [weight=100000000]
    structDeclarationR6C3 -> structDeclarationR7C3 [weight=100000000]
    rank = same {structDeclarationR6C1 -> structDeclarationR6C3}
    structDeclarationR5C1 -> structDeclarationR6C1 [weight=100000000]
    structDeclarationR5C4 [label = <CZW<br/>ALT <br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    structDeclarationR6C4 [label = <CZV<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    structDeclarationR7C4 [label = <CZX<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    structDeclarationR6C4 -> structDeclarationR7C4 [weight=100000000]
    structDeclarationR5C4 -> structDeclarationR6C4 [weight=100000000]
    rank = same {structDeclarationR5C1 -> structDeclarationR5C4}
    structDeclarationR4C1 -> structDeclarationR5C1 [weight=100000000]
    structDeclarationR3C1 -> structDeclarationR4C1 [weight=100000000]
    structDeclarationR2C1 -> structDeclarationR3C1 [weight=100000000]
    structDeclarationR2C5 [label = <CZQ<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["struct"]<br/>am []<br/>>]
    structDeclarationR3C5 [label = <CZP<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["struct"]<br/>am []<br/>>]
    structDeclarationR4C5 [label = <CZR<br/>END <br/>fi [""]<br/>fo ["struct"]<br/>am []<br/>>]
    structDeclarationR3C5 -> structDeclarationR4C5 [weight=100000000]
    structDeclarationR2C5 -> structDeclarationR3C5 [weight=100000000]
    rank = same {structDeclarationR2C1 -> structDeclarationR2C5}
    structDeclarationR1C1 -> structDeclarationR2C1 [weight=100000000]
    structDeclarationR1C6 [label = <CZM<br/>ALT <br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "struct"]<br/>am []<br/>>]
    structDeclarationR2C6 [label = <CZL<br/>N attributes<br/>fi ["@"]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "struct"]<br/>am []<br/>>]
    structDeclarationR3C6 [label = <CZN<br/>END <br/>fi [""]<br/>fo ["fileprivate", "internal", "open", "package", "private", "public", "struct"]<br/>am []<br/>>]
    structDeclarationR2C6 -> structDeclarationR3C6 [weight=100000000]
    structDeclarationR1C6 -> structDeclarationR2C6 [weight=100000000]
    rank = same {structDeclarationR1C1 -> structDeclarationR1C6}
    structDeclarationR0C1 -> structDeclarationR1C1 [weight=100000000]
    rank = same {structDeclarationR0C0 -> structDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {structDeclarationR0C1 -> structDeclarationR0C2}
    rank = same {structDeclarationR0C2 -> structDeclarationR0C3}
    rank = same {structDeclarationR0C3 -> structDeclarationR0C4}
    rank = same {structDeclarationR0C4 -> structDeclarationR0C5}
    rank = same {structDeclarationR0C5 -> structDeclarationR0C6}
    structDeclarationR0C0 -> structDeclarationR1C0 [weight=100000000]
    rank = same {structDeclarationR1C0 -> structDeclarationR1C1}
    structDeclarationR0C6 -> structDeclarationR1C6 [weight=100000000]
    structDeclarationR1C0 -> structDeclarationR2C0 [weight=100000000]
    rank = same {structDeclarationR2C0 -> structDeclarationR2C1}
    structDeclarationR2C0 -> structDeclarationR3C0 [weight=100000000]
    rank = same {structDeclarationR3C0 -> structDeclarationR3C1}
    rank = same {structDeclarationR3C1 -> structDeclarationR3C2}
    rank = same {structDeclarationR3C2 -> structDeclarationR3C3}
    rank = same {structDeclarationR3C3 -> structDeclarationR3C4}
    rank = same {structDeclarationR3C4 -> structDeclarationR3C5}
    structDeclarationR3C0 -> structDeclarationR4C0 [weight=100000000]
    rank = same {structDeclarationR4C0 -> structDeclarationR4C1}
    structDeclarationR3C2 -> structDeclarationR4C2 [weight=100000000]
    rank = same {structDeclarationR4C1 -> structDeclarationR4C2}
    structDeclarationR3C3 -> structDeclarationR4C3 [weight=100000000]
    rank = same {structDeclarationR4C2 -> structDeclarationR4C3}
    structDeclarationR3C4 -> structDeclarationR4C4 [weight=100000000]
    rank = same {structDeclarationR4C3 -> structDeclarationR4C4}
    rank = same {structDeclarationR4C4 -> structDeclarationR4C5}
    structDeclarationR3C6 -> structDeclarationR4C6 [weight=100000000]
    rank = same {structDeclarationR4C5 -> structDeclarationR4C6}
    structDeclarationR4C0 -> structDeclarationR5C0 [weight=100000000]
    rank = same {structDeclarationR5C0 -> structDeclarationR5C1}
    structDeclarationR4C4 -> structDeclarationR5C4 [weight=100000000]
    structDeclarationR4C5 -> structDeclarationR5C5 [weight=100000000]
    rank = same {structDeclarationR5C4 -> structDeclarationR5C5}
    structDeclarationR4C6 -> structDeclarationR5C6 [weight=100000000]
    rank = same {structDeclarationR5C5 -> structDeclarationR5C6}
    structDeclarationR5C0 -> structDeclarationR6C0 [weight=100000000]
    rank = same {structDeclarationR6C0 -> structDeclarationR6C1}
    structDeclarationR5C5 -> structDeclarationR6C5 [weight=100000000]
    rank = same {structDeclarationR6C4 -> structDeclarationR6C5}
    structDeclarationR5C6 -> structDeclarationR6C6 [weight=100000000]
    rank = same {structDeclarationR6C5 -> structDeclarationR6C6}
    structDeclarationR6C0 -> structDeclarationR7C0 [weight=100000000]
    rank = same {structDeclarationR7C0 -> structDeclarationR7C1}
    structDeclarationR6C5 -> structDeclarationR7C5 [weight=100000000]
    rank = same {structDeclarationR7C4 -> structDeclarationR7C5}
    structDeclarationR6C6 -> structDeclarationR7C6 [weight=100000000]
    rank = same {structDeclarationR7C5 -> structDeclarationR7C6}
    structDeclarationR7C0 -> structDeclarationR8C0 [weight=100000000]
    rank = same {structDeclarationR8C0 -> structDeclarationR8C1}
    structDeclarationR7C4 -> structDeclarationR8C4 [weight=100000000]
    rank = same {structDeclarationR8C3 -> structDeclarationR8C4}
    structDeclarationR7C5 -> structDeclarationR8C5 [weight=100000000]
    rank = same {structDeclarationR8C4 -> structDeclarationR8C5}
    structDeclarationR7C6 -> structDeclarationR8C6 [weight=100000000]
    rank = same {structDeclarationR8C5 -> structDeclarationR8C6}
    structDeclarationR8C0 -> structDeclarationR9C0 [weight=100000000]
    rank = same {structDeclarationR9C0 -> structDeclarationR9C1}
    structDeclarationR8C3 -> structDeclarationR9C3 [weight=100000000]
    rank = same {structDeclarationR9C2 -> structDeclarationR9C3}
    structDeclarationR8C4 -> structDeclarationR9C4 [weight=100000000]
    rank = same {structDeclarationR9C3 -> structDeclarationR9C4}
    structDeclarationR8C5 -> structDeclarationR9C5 [weight=100000000]
    rank = same {structDeclarationR9C4 -> structDeclarationR9C5}
    structDeclarationR8C6 -> structDeclarationR9C6 [weight=100000000]
    rank = same {structDeclarationR9C5 -> structDeclarationR9C6}
  }
  subgraph clusterclassMember {
    node [shape = box]
    label = <classMember = declaration | compilerControlStatement .>
    labeljust = l
    classMemberR0C0 [label = <DER<br/>N classMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    classMemberR0C1 [label = <DEL<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    classMemberR1C1 [label = <DEM<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    classMemberR2C1 [label = <DEN<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    classMemberR1C1 -> classMemberR2C1 [weight=100000000]
    classMemberR0C1 -> classMemberR1C1 [weight=100000000]
    classMemberR0C2 [label = <DEO<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    classMemberR1C2 [label = <DEP<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    classMemberR2C2 [label = <DEQ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    classMemberR1C2 -> classMemberR2C2 [weight=100000000]
    classMemberR0C2 -> classMemberR1C2 [weight=100000000]
    rank = same {classMemberR0C1 -> classMemberR0C2}
    rank = same {classMemberR0C0 -> classMemberR0C1}
    node [style = invis]
    edge [style = invis]
    classMemberR0C0 -> classMemberR1C0 [weight=100000000]
    rank = same {classMemberR1C0 -> classMemberR1C1}
    classMemberR1C0 -> classMemberR2C0 [weight=100000000]
    rank = same {classMemberR2C0 -> classMemberR2C1}
  }
  subgraph clusterprotocolMemberDeclaration {
    node [shape = box]
    label = <protocolMemberDeclaration = protocolPropertyDeclaration | protocolMethodDeclaration | protocolInitializerDeclaration | protocolSubscriptDeclaration | protocolAssociatedTypeDeclaration | typealiasDeclaration .>
    labeljust = l
    protocolMemberDeclarationR0C0 [label = <DIV<br/>N protocolMemberDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR0C1 [label = <DIS<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C1 [label = <DIT<br/>N protocolPropertyDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C1 [label = <DIU<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C1 -> protocolMemberDeclarationR2C1 [weight=100000000]
    protocolMemberDeclarationR0C1 -> protocolMemberDeclarationR1C1 [weight=100000000]
    protocolMemberDeclarationR0C2 [label = <DIW<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C2 [label = <DIX<br/>N protocolMethodDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C2 [label = <DIY<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C2 -> protocolMemberDeclarationR2C2 [weight=100000000]
    protocolMemberDeclarationR0C2 -> protocolMemberDeclarationR1C2 [weight=100000000]
    protocolMemberDeclarationR0C3 [label = <DIZ<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C3 [label = <DJA<br/>N protocolInitializerDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C3 [label = <DJB<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C3 -> protocolMemberDeclarationR2C3 [weight=100000000]
    protocolMemberDeclarationR0C3 -> protocolMemberDeclarationR1C3 [weight=100000000]
    protocolMemberDeclarationR0C4 [label = <DJC<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C4 [label = <DJD<br/>N protocolSubscriptDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C4 [label = <DJE<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C4 -> protocolMemberDeclarationR2C4 [weight=100000000]
    protocolMemberDeclarationR0C4 -> protocolMemberDeclarationR1C4 [weight=100000000]
    protocolMemberDeclarationR0C5 [label = <DJF<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C5 [label = <DJG<br/>N protocolAssociatedTypeDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C5 [label = <DJH<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C5 -> protocolMemberDeclarationR2C5 [weight=100000000]
    protocolMemberDeclarationR0C5 -> protocolMemberDeclarationR1C5 [weight=100000000]
    protocolMemberDeclarationR0C6 [label = <DJI<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR1C6 [label = <DJJ<br/>N typealiasDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberDeclarationR2C6 [label = <DJK<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberDeclarationR1C6 -> protocolMemberDeclarationR2C6 [weight=100000000]
    protocolMemberDeclarationR0C6 -> protocolMemberDeclarationR1C6 [weight=100000000]
    rank = same {protocolMemberDeclarationR0C5 -> protocolMemberDeclarationR0C6}
    rank = same {protocolMemberDeclarationR0C4 -> protocolMemberDeclarationR0C5}
    rank = same {protocolMemberDeclarationR0C3 -> protocolMemberDeclarationR0C4}
    rank = same {protocolMemberDeclarationR0C2 -> protocolMemberDeclarationR0C3}
    rank = same {protocolMemberDeclarationR0C1 -> protocolMemberDeclarationR0C2}
    rank = same {protocolMemberDeclarationR0C0 -> protocolMemberDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    protocolMemberDeclarationR0C0 -> protocolMemberDeclarationR1C0 [weight=100000000]
    rank = same {protocolMemberDeclarationR1C0 -> protocolMemberDeclarationR1C1}
    protocolMemberDeclarationR1C0 -> protocolMemberDeclarationR2C0 [weight=100000000]
    rank = same {protocolMemberDeclarationR2C0 -> protocolMemberDeclarationR2C1}
  }
  subgraph clusterdictionaryLiteralItem {
    node [shape = box]
    label = <dictionaryLiteralItem = expression ":" expression .>
    labeljust = l
    dictionaryLiteralItemR0C0 [label = <XE<br/>N dictionaryLiteralItem<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    dictionaryLiteralItemR0C1 [label = <WZ<br/>ALT <br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    dictionaryLiteralItemR1C1 [label = <XA<br/>N expression<br/>fi ["", "try"]<br/>fo [":"]<br/>am []<br/>>]
    dictionaryLiteralItemR2C1 [label = <XB<br/>T ":"<br/>fi [":"]<br/>fo [",", "]", "try"]<br/>am []<br/>>]
    dictionaryLiteralItemR3C1 [label = <XC<br/>N expression<br/>fi ["", "try"]<br/>fo [",", "]"]<br/>am []<br/>>]
    dictionaryLiteralItemR4C1 [label = <XD<br/>END <br/>fi [""]<br/>fo [",", "]"]<br/>am []<br/>>]
    dictionaryLiteralItemR3C1 -> dictionaryLiteralItemR4C1 [weight=100000000]
    dictionaryLiteralItemR2C1 -> dictionaryLiteralItemR3C1 [weight=100000000]
    dictionaryLiteralItemR1C1 -> dictionaryLiteralItemR2C1 [weight=100000000]
    dictionaryLiteralItemR0C1 -> dictionaryLiteralItemR1C1 [weight=100000000]
    rank = same {dictionaryLiteralItemR0C0 -> dictionaryLiteralItemR0C1}
    node [style = invis]
    edge [style = invis]
    dictionaryLiteralItemR0C0 -> dictionaryLiteralItemR1C0 [weight=100000000]
    rank = same {dictionaryLiteralItemR1C0 -> dictionaryLiteralItemR1C1}
    dictionaryLiteralItemR1C0 -> dictionaryLiteralItemR2C0 [weight=100000000]
    rank = same {dictionaryLiteralItemR2C0 -> dictionaryLiteralItemR2C1}
    dictionaryLiteralItemR2C0 -> dictionaryLiteralItemR3C0 [weight=100000000]
    rank = same {dictionaryLiteralItemR3C0 -> dictionaryLiteralItemR3C1}
    dictionaryLiteralItemR3C0 -> dictionaryLiteralItemR4C0 [weight=100000000]
    rank = same {dictionaryLiteralItemR4C0 -> dictionaryLiteralItemR4C1}
  }
  subgraph clustergenericParameterList {
    node [shape = box]
    label = <genericParameterList = genericParameter | genericParameter "," genericParameterList .>
    labeljust = l
    genericParameterListR0C0 [label = <EOA<br/>N genericParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    genericParameterListR0C1 [label = <ENS<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR1C1 [label = <ENT<br/>N genericParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR2C1 [label = <ENU<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR1C1 -> genericParameterListR2C1 [weight=100000000]
    genericParameterListR0C1 -> genericParameterListR1C1 [weight=100000000]
    genericParameterListR0C2 [label = <ENV<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR1C2 [label = <ENW<br/>N genericParameter<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    genericParameterListR2C2 [label = <ENX<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    genericParameterListR3C2 [label = <ENY<br/>N genericParameterList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR4C2 [label = <ENZ<br/>END <br/>fi [""]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericParameterListR3C2 -> genericParameterListR4C2 [weight=100000000]
    genericParameterListR2C2 -> genericParameterListR3C2 [weight=100000000]
    genericParameterListR1C2 -> genericParameterListR2C2 [weight=100000000]
    genericParameterListR0C2 -> genericParameterListR1C2 [weight=100000000]
    rank = same {genericParameterListR0C1 -> genericParameterListR0C2}
    rank = same {genericParameterListR0C0 -> genericParameterListR0C1}
    node [style = invis]
    edge [style = invis]
    genericParameterListR0C0 -> genericParameterListR1C0 [weight=100000000]
    rank = same {genericParameterListR1C0 -> genericParameterListR1C1}
    genericParameterListR1C0 -> genericParameterListR2C0 [weight=100000000]
    rank = same {genericParameterListR2C0 -> genericParameterListR2C1}
    genericParameterListR2C0 -> genericParameterListR3C0 [weight=100000000]
    genericParameterListR2C1 -> genericParameterListR3C1 [weight=100000000]
    rank = same {genericParameterListR3C0 -> genericParameterListR3C1}
    rank = same {genericParameterListR3C1 -> genericParameterListR3C2}
    genericParameterListR3C0 -> genericParameterListR4C0 [weight=100000000]
    genericParameterListR3C1 -> genericParameterListR4C1 [weight=100000000]
    rank = same {genericParameterListR4C0 -> genericParameterListR4C1}
    rank = same {genericParameterListR4C1 -> genericParameterListR4C2}
  }
  subgraph clustersubscriptDeclaration {
    node [shape = box]
    label = <subscriptDeclaration = subscriptHead subscriptResult [ genericWhereClause ] codeBlock | subscriptHead subscriptResult [ genericWhereClause ] getterSetterBlock | subscriptHead subscriptResult [ genericWhereClause ] getterSetterKeywordBlock .>
    labeljust = l
    subscriptDeclarationR0C0 [label = <DSH<br/>N subscriptDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    subscriptDeclarationR0C1 [label = <DRY<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    subscriptDeclarationR1C1 [label = <DRZ<br/>N subscriptHead<br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptDeclarationR2C1 [label = <DSA<br/>N subscriptResult<br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptDeclarationR3C1 [label = <DSE<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C1 [label = <DSF<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR5C1 [label = <DSG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR4C1 -> subscriptDeclarationR5C1 [weight=100000000]
    subscriptDeclarationR3C1 -> subscriptDeclarationR4C1 [weight=100000000]
    subscriptDeclarationR3C2 [label = <DSC<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C2 [label = <DSB<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR5C2 [label = <DSD<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C2 -> subscriptDeclarationR5C2 [weight=100000000]
    subscriptDeclarationR3C2 -> subscriptDeclarationR4C2 [weight=100000000]
    rank = same {subscriptDeclarationR3C1 -> subscriptDeclarationR3C2}
    subscriptDeclarationR2C1 -> subscriptDeclarationR3C1 [weight=100000000]
    subscriptDeclarationR1C1 -> subscriptDeclarationR2C1 [weight=100000000]
    subscriptDeclarationR0C1 -> subscriptDeclarationR1C1 [weight=100000000]
    subscriptDeclarationR0C3 [label = <DSI<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    subscriptDeclarationR1C3 [label = <DSJ<br/>N subscriptHead<br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptDeclarationR2C3 [label = <DSK<br/>N subscriptResult<br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptDeclarationR3C3 [label = <DSO<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C3 [label = <DSP<br/>N getterSetterBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR5C3 [label = <DSQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR4C3 -> subscriptDeclarationR5C3 [weight=100000000]
    subscriptDeclarationR3C3 -> subscriptDeclarationR4C3 [weight=100000000]
    subscriptDeclarationR3C4 [label = <DSM<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C4 [label = <DSL<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR5C4 [label = <DSN<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C4 -> subscriptDeclarationR5C4 [weight=100000000]
    subscriptDeclarationR3C4 -> subscriptDeclarationR4C4 [weight=100000000]
    rank = same {subscriptDeclarationR3C3 -> subscriptDeclarationR3C4}
    subscriptDeclarationR2C3 -> subscriptDeclarationR3C3 [weight=100000000]
    subscriptDeclarationR1C3 -> subscriptDeclarationR2C3 [weight=100000000]
    subscriptDeclarationR0C3 -> subscriptDeclarationR1C3 [weight=100000000]
    subscriptDeclarationR0C5 [label = <DSR<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    subscriptDeclarationR1C5 [label = <DSS<br/>N subscriptHead<br/>fi ["", "@"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    subscriptDeclarationR2C5 [label = <DST<br/>N subscriptResult<br/>fi ["&gt;"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    subscriptDeclarationR3C5 [label = <DSX<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C5 [label = <DSY<br/>N getterSetterKeywordBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR5C5 [label = <DSZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    subscriptDeclarationR4C5 -> subscriptDeclarationR5C5 [weight=100000000]
    subscriptDeclarationR3C5 -> subscriptDeclarationR4C5 [weight=100000000]
    subscriptDeclarationR3C6 [label = <DSV<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C6 [label = <DSU<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR5C6 [label = <DSW<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    subscriptDeclarationR4C6 -> subscriptDeclarationR5C6 [weight=100000000]
    subscriptDeclarationR3C6 -> subscriptDeclarationR4C6 [weight=100000000]
    rank = same {subscriptDeclarationR3C5 -> subscriptDeclarationR3C6}
    subscriptDeclarationR2C5 -> subscriptDeclarationR3C5 [weight=100000000]
    subscriptDeclarationR1C5 -> subscriptDeclarationR2C5 [weight=100000000]
    subscriptDeclarationR0C5 -> subscriptDeclarationR1C5 [weight=100000000]
    rank = same {subscriptDeclarationR0C3 -> subscriptDeclarationR0C5}
    rank = same {subscriptDeclarationR0C1 -> subscriptDeclarationR0C3}
    rank = same {subscriptDeclarationR0C0 -> subscriptDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {subscriptDeclarationR0C5 -> subscriptDeclarationR0C6}
    subscriptDeclarationR0C0 -> subscriptDeclarationR1C0 [weight=100000000]
    rank = same {subscriptDeclarationR1C0 -> subscriptDeclarationR1C1}
    rank = same {subscriptDeclarationR1C1 -> subscriptDeclarationR1C2}
    rank = same {subscriptDeclarationR1C2 -> subscriptDeclarationR1C3}
    rank = same {subscriptDeclarationR1C3 -> subscriptDeclarationR1C4}
    rank = same {subscriptDeclarationR1C4 -> subscriptDeclarationR1C5}
    subscriptDeclarationR0C6 -> subscriptDeclarationR1C6 [weight=100000000]
    rank = same {subscriptDeclarationR1C5 -> subscriptDeclarationR1C6}
    subscriptDeclarationR1C0 -> subscriptDeclarationR2C0 [weight=100000000]
    rank = same {subscriptDeclarationR2C0 -> subscriptDeclarationR2C1}
    subscriptDeclarationR1C2 -> subscriptDeclarationR2C2 [weight=100000000]
    rank = same {subscriptDeclarationR2C1 -> subscriptDeclarationR2C2}
    rank = same {subscriptDeclarationR2C2 -> subscriptDeclarationR2C3}
    subscriptDeclarationR1C4 -> subscriptDeclarationR2C4 [weight=100000000]
    rank = same {subscriptDeclarationR2C3 -> subscriptDeclarationR2C4}
    rank = same {subscriptDeclarationR2C4 -> subscriptDeclarationR2C5}
    subscriptDeclarationR1C6 -> subscriptDeclarationR2C6 [weight=100000000]
    rank = same {subscriptDeclarationR2C5 -> subscriptDeclarationR2C6}
    subscriptDeclarationR2C0 -> subscriptDeclarationR3C0 [weight=100000000]
    rank = same {subscriptDeclarationR3C0 -> subscriptDeclarationR3C1}
    subscriptDeclarationR2C2 -> subscriptDeclarationR3C2 [weight=100000000]
    subscriptDeclarationR2C4 -> subscriptDeclarationR3C4 [weight=100000000]
    subscriptDeclarationR2C6 -> subscriptDeclarationR3C6 [weight=100000000]
    subscriptDeclarationR3C0 -> subscriptDeclarationR4C0 [weight=100000000]
    rank = same {subscriptDeclarationR4C0 -> subscriptDeclarationR4C1}
    subscriptDeclarationR4C0 -> subscriptDeclarationR5C0 [weight=100000000]
    rank = same {subscriptDeclarationR5C0 -> subscriptDeclarationR5C1}
  }
  subgraph clusterextensionMember {
    node [shape = box]
    label = <extensionMember = declaration | compilerControlStatement .>
    labeljust = l
    extensionMemberR0C0 [label = <DRX<br/>N extensionMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    extensionMemberR0C1 [label = <DRR<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    extensionMemberR1C1 [label = <DRS<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    extensionMemberR2C1 [label = <DRT<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    extensionMemberR1C1 -> extensionMemberR2C1 [weight=100000000]
    extensionMemberR0C1 -> extensionMemberR1C1 [weight=100000000]
    extensionMemberR0C2 [label = <DRU<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    extensionMemberR1C2 [label = <DRV<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    extensionMemberR2C2 [label = <DRW<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    extensionMemberR1C2 -> extensionMemberR2C2 [weight=100000000]
    extensionMemberR0C2 -> extensionMemberR1C2 [weight=100000000]
    rank = same {extensionMemberR0C1 -> extensionMemberR0C2}
    rank = same {extensionMemberR0C0 -> extensionMemberR0C1}
    node [style = invis]
    edge [style = invis]
    extensionMemberR0C0 -> extensionMemberR1C0 [weight=100000000]
    rank = same {extensionMemberR1C0 -> extensionMemberR1C1}
    extensionMemberR1C0 -> extensionMemberR2C0 [weight=100000000]
    rank = same {extensionMemberR2C0 -> extensionMemberR2C1}
  }
  subgraph clusterselfSubscriptExpression {
    node [shape = box]
    label = <selfSubscriptExpression = "self" "[" functionCallArgumentList "]" .>
    labeljust = l
    selfSubscriptExpressionR0C0 [label = <ZP<br/>N selfSubscriptExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfSubscriptExpressionR0C1 [label = <ZJ<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfSubscriptExpressionR1C1 [label = <ZK<br/>T "self"<br/>fi ["self"]<br/>fo ["["]<br/>am []<br/>>]
    selfSubscriptExpressionR2C1 [label = <ZL<br/>T "["<br/>fi ["["]<br/>fo ["]", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>am []<br/>>]
    selfSubscriptExpressionR3C1 [label = <ZM<br/>N functionCallArgumentList<br/>fi ["", "dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection", "try"]<br/>fo ["]"]<br/>am []<br/>>]
    selfSubscriptExpressionR4C1 [label = <ZN<br/>T "]"<br/>fi ["]"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfSubscriptExpressionR5C1 [label = <ZO<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfSubscriptExpressionR4C1 -> selfSubscriptExpressionR5C1 [weight=100000000]
    selfSubscriptExpressionR3C1 -> selfSubscriptExpressionR4C1 [weight=100000000]
    selfSubscriptExpressionR2C1 -> selfSubscriptExpressionR3C1 [weight=100000000]
    selfSubscriptExpressionR1C1 -> selfSubscriptExpressionR2C1 [weight=100000000]
    selfSubscriptExpressionR0C1 -> selfSubscriptExpressionR1C1 [weight=100000000]
    rank = same {selfSubscriptExpressionR0C0 -> selfSubscriptExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    selfSubscriptExpressionR0C0 -> selfSubscriptExpressionR1C0 [weight=100000000]
    rank = same {selfSubscriptExpressionR1C0 -> selfSubscriptExpressionR1C1}
    selfSubscriptExpressionR1C0 -> selfSubscriptExpressionR2C0 [weight=100000000]
    rank = same {selfSubscriptExpressionR2C0 -> selfSubscriptExpressionR2C1}
    selfSubscriptExpressionR2C0 -> selfSubscriptExpressionR3C0 [weight=100000000]
    rank = same {selfSubscriptExpressionR3C0 -> selfSubscriptExpressionR3C1}
    selfSubscriptExpressionR3C0 -> selfSubscriptExpressionR4C0 [weight=100000000]
    rank = same {selfSubscriptExpressionR4C0 -> selfSubscriptExpressionR4C1}
    selfSubscriptExpressionR4C0 -> selfSubscriptExpressionR5C0 [weight=100000000]
    rank = same {selfSubscriptExpressionR5C0 -> selfSubscriptExpressionR5C1}
  }
  subgraph clustertypeInheritanceClause {
    node [shape = box]
    label = <typeInheritanceClause = ":" typeInheritanceList .>
    labeljust = l
    typeInheritanceClauseR0C0 [label = <NO<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceClauseR0C1 [label = <NK<br/>ALT <br/>fi [":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceClauseR1C1 [label = <NL<br/>T ":"<br/>fi [":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceClauseR2C1 [label = <NM<br/>N typeInheritanceList<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am ["@"]<br/>>]
    typeInheritanceClauseR3C1 [label = <NN<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "{", "}"]<br/>am []<br/>>]
    typeInheritanceClauseR2C1 -> typeInheritanceClauseR3C1 [weight=100000000]
    typeInheritanceClauseR1C1 -> typeInheritanceClauseR2C1 [weight=100000000]
    typeInheritanceClauseR0C1 -> typeInheritanceClauseR1C1 [weight=100000000]
    rank = same {typeInheritanceClauseR0C0 -> typeInheritanceClauseR0C1}
    node [style = invis]
    edge [style = invis]
    typeInheritanceClauseR0C0 -> typeInheritanceClauseR1C0 [weight=100000000]
    rank = same {typeInheritanceClauseR1C0 -> typeInheritanceClauseR1C1}
    typeInheritanceClauseR1C0 -> typeInheritanceClauseR2C0 [weight=100000000]
    rank = same {typeInheritanceClauseR2C0 -> typeInheritanceClauseR2C1}
    typeInheritanceClauseR2C0 -> typeInheritanceClauseR3C0 [weight=100000000]
    rank = same {typeInheritanceClauseR3C0 -> typeInheritanceClauseR3C1}
  }
  subgraph clusterstructBody {
    node [shape = box]
    label = <structBody = "{" [ structMembers ] "}" .>
    labeljust = l
    structBodyR0C0 [label = <DAW<br/>N structBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structBodyR0C1 [label = <DAO<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structBodyR1C1 [label = <DAP<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    structBodyR2C1 [label = <DAT<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structBodyR3C1 [label = <DAU<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structBodyR4C1 [label = <DAV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    structBodyR3C1 -> structBodyR4C1 [weight=100000000]
    structBodyR2C1 -> structBodyR3C1 [weight=100000000]
    structBodyR2C2 [label = <DAR<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structBodyR3C2 [label = <DAQ<br/>N structMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    structBodyR4C2 [label = <DAS<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    structBodyR3C2 -> structBodyR4C2 [weight=100000000]
    structBodyR2C2 -> structBodyR3C2 [weight=100000000]
    rank = same {structBodyR2C1 -> structBodyR2C2}
    structBodyR1C1 -> structBodyR2C1 [weight=100000000]
    structBodyR0C1 -> structBodyR1C1 [weight=100000000]
    rank = same {structBodyR0C0 -> structBodyR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {structBodyR0C1 -> structBodyR0C2}
    structBodyR0C0 -> structBodyR1C0 [weight=100000000]
    rank = same {structBodyR1C0 -> structBodyR1C1}
    structBodyR0C2 -> structBodyR1C2 [weight=100000000]
    rank = same {structBodyR1C1 -> structBodyR1C2}
    structBodyR1C0 -> structBodyR2C0 [weight=100000000]
    rank = same {structBodyR2C0 -> structBodyR2C1}
    structBodyR1C2 -> structBodyR2C2 [weight=100000000]
    structBodyR2C0 -> structBodyR3C0 [weight=100000000]
    rank = same {structBodyR3C0 -> structBodyR3C1}
    structBodyR3C0 -> structBodyR4C0 [weight=100000000]
    rank = same {structBodyR4C0 -> structBodyR4C1}
  }
  subgraph clusterlabeledTrailingClosures {
    node [shape = box]
    label = <labeledTrailingClosures = labeledTrailingClosure [ labeledTrailingClosures ] .>
    labeljust = l
    labeledTrailingClosuresR0C0 [label = <ARK<br/>N labeledTrailingClosures<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR0C1 [label = <ARD<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR1C1 [label = <ARE<br/>N labeledTrailingClosure<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR2C1 [label = <ARI<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    labeledTrailingClosuresR3C1 [label = <ARJ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR2C1 -> labeledTrailingClosuresR3C1 [weight=100000000]
    labeledTrailingClosuresR2C2 [label = <ARG<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR3C2 [label = <ARF<br/>N labeledTrailingClosures<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR4C2 [label = <ARH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    labeledTrailingClosuresR3C2 -> labeledTrailingClosuresR4C2 [weight=100000000]
    labeledTrailingClosuresR2C2 -> labeledTrailingClosuresR3C2 [weight=100000000]
    rank = same {labeledTrailingClosuresR2C1 -> labeledTrailingClosuresR2C2}
    labeledTrailingClosuresR1C1 -> labeledTrailingClosuresR2C1 [weight=100000000]
    labeledTrailingClosuresR0C1 -> labeledTrailingClosuresR1C1 [weight=100000000]
    rank = same {labeledTrailingClosuresR0C0 -> labeledTrailingClosuresR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {labeledTrailingClosuresR0C1 -> labeledTrailingClosuresR0C2}
    labeledTrailingClosuresR0C0 -> labeledTrailingClosuresR1C0 [weight=100000000]
    rank = same {labeledTrailingClosuresR1C0 -> labeledTrailingClosuresR1C1}
    labeledTrailingClosuresR0C2 -> labeledTrailingClosuresR1C2 [weight=100000000]
    rank = same {labeledTrailingClosuresR1C1 -> labeledTrailingClosuresR1C2}
    labeledTrailingClosuresR1C0 -> labeledTrailingClosuresR2C0 [weight=100000000]
    rank = same {labeledTrailingClosuresR2C0 -> labeledTrailingClosuresR2C1}
    labeledTrailingClosuresR1C2 -> labeledTrailingClosuresR2C2 [weight=100000000]
    labeledTrailingClosuresR2C0 -> labeledTrailingClosuresR3C0 [weight=100000000]
    rank = same {labeledTrailingClosuresR3C0 -> labeledTrailingClosuresR3C1}
    labeledTrailingClosuresR3C0 -> labeledTrailingClosuresR4C0 [weight=100000000]
    labeledTrailingClosuresR3C1 -> labeledTrailingClosuresR4C1 [weight=100000000]
    rank = same {labeledTrailingClosuresR4C0 -> labeledTrailingClosuresR4C1}
    rank = same {labeledTrailingClosuresR4C1 -> labeledTrailingClosuresR4C2}
  }
  subgraph clusterselfExpression {
    node [shape = box]
    label = <selfExpression = "self" | selfMethodExpression | selfSubscriptExpression | selfInitializerExpression .>
    labeljust = l
    selfExpressionR0C0 [label = <ZC<br/>N selfExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["self"]<br/>>]
    selfExpressionR0C1 [label = <YQ<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C1 [label = <YR<br/>T "self"<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR2C1 [label = <YS<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C1 -> selfExpressionR2C1 [weight=100000000]
    selfExpressionR0C1 -> selfExpressionR1C1 [weight=100000000]
    selfExpressionR0C2 [label = <YT<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C2 [label = <YU<br/>N selfMethodExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR2C2 [label = <YV<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C2 -> selfExpressionR2C2 [weight=100000000]
    selfExpressionR0C2 -> selfExpressionR1C2 [weight=100000000]
    selfExpressionR0C3 [label = <YW<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C3 [label = <YX<br/>N selfSubscriptExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR2C3 [label = <YY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C3 -> selfExpressionR2C3 [weight=100000000]
    selfExpressionR0C3 -> selfExpressionR1C3 [weight=100000000]
    selfExpressionR0C4 [label = <YZ<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C4 [label = <ZA<br/>N selfInitializerExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR2C4 [label = <ZB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfExpressionR1C4 -> selfExpressionR2C4 [weight=100000000]
    selfExpressionR0C4 -> selfExpressionR1C4 [weight=100000000]
    rank = same {selfExpressionR0C3 -> selfExpressionR0C4}
    rank = same {selfExpressionR0C2 -> selfExpressionR0C3}
    rank = same {selfExpressionR0C1 -> selfExpressionR0C2}
    rank = same {selfExpressionR0C0 -> selfExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    selfExpressionR0C0 -> selfExpressionR1C0 [weight=100000000]
    rank = same {selfExpressionR1C0 -> selfExpressionR1C1}
    selfExpressionR1C0 -> selfExpressionR2C0 [weight=100000000]
    rank = same {selfExpressionR2C0 -> selfExpressionR2C1}
  }
  subgraph clusterelseClause {
    node [shape = box]
    label = <elseClause = "else" codeBlock | "else" ifStatement .>
    labeljust = l
    elseClauseR0C0 [label = <BBO<br/>N elseClause<br/>fi ["else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["else"]<br/>>]
    elseClauseR0C1 [label = <BBG<br/>ALT <br/>fi ["else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR1C1 [label = <BBH<br/>T "else"<br/>fi ["else"]<br/>fo ["{"]<br/>am []<br/>>]
    elseClauseR2C1 [label = <BBI<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR3C1 [label = <BBJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR2C1 -> elseClauseR3C1 [weight=100000000]
    elseClauseR1C1 -> elseClauseR2C1 [weight=100000000]
    elseClauseR0C1 -> elseClauseR1C1 [weight=100000000]
    elseClauseR0C2 [label = <BBK<br/>ALT <br/>fi ["else"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR1C2 [label = <BBL<br/>T "else"<br/>fi ["else"]<br/>fo ["if"]<br/>am []<br/>>]
    elseClauseR2C2 [label = <BBM<br/>N ifStatement<br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR3C2 [label = <BBN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    elseClauseR2C2 -> elseClauseR3C2 [weight=100000000]
    elseClauseR1C2 -> elseClauseR2C2 [weight=100000000]
    elseClauseR0C2 -> elseClauseR1C2 [weight=100000000]
    rank = same {elseClauseR0C1 -> elseClauseR0C2}
    rank = same {elseClauseR0C0 -> elseClauseR0C1}
    node [style = invis]
    edge [style = invis]
    elseClauseR0C0 -> elseClauseR1C0 [weight=100000000]
    rank = same {elseClauseR1C0 -> elseClauseR1C1}
    elseClauseR1C0 -> elseClauseR2C0 [weight=100000000]
    rank = same {elseClauseR2C0 -> elseClauseR2C1}
    elseClauseR2C0 -> elseClauseR3C0 [weight=100000000]
    rank = same {elseClauseR3C0 -> elseClauseR3C1}
  }
  subgraph clusterswitchCases {
    node [shape = box]
    label = <switchCases = switchCase [ switchCases ] .>
    labeljust = l
    switchCasesR0C0 [label = <BCO<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR0C1 [label = <BCH<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR1C1 [label = <BCI<br/>N switchCase<br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "#if", "@", "}"]<br/>am ["#if", "@"]<br/>>]
    switchCasesR2C1 [label = <BCM<br/>OPT <br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR3C1 [label = <BCN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR2C1 -> switchCasesR3C1 [weight=100000000]
    switchCasesR2C2 [label = <BCK<br/>ALT <br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR3C2 [label = <BCJ<br/>N switchCases<br/>fi ["", "#if", "@"]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR4C2 [label = <BCL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "}"]<br/>am []<br/>>]
    switchCasesR3C2 -> switchCasesR4C2 [weight=100000000]
    switchCasesR2C2 -> switchCasesR3C2 [weight=100000000]
    rank = same {switchCasesR2C1 -> switchCasesR2C2}
    switchCasesR1C1 -> switchCasesR2C1 [weight=100000000]
    switchCasesR0C1 -> switchCasesR1C1 [weight=100000000]
    rank = same {switchCasesR0C0 -> switchCasesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {switchCasesR0C1 -> switchCasesR0C2}
    switchCasesR0C0 -> switchCasesR1C0 [weight=100000000]
    rank = same {switchCasesR1C0 -> switchCasesR1C1}
    switchCasesR0C2 -> switchCasesR1C2 [weight=100000000]
    rank = same {switchCasesR1C1 -> switchCasesR1C2}
    switchCasesR1C0 -> switchCasesR2C0 [weight=100000000]
    rank = same {switchCasesR2C0 -> switchCasesR2C1}
    switchCasesR1C2 -> switchCasesR2C2 [weight=100000000]
    switchCasesR2C0 -> switchCasesR3C0 [weight=100000000]
    rank = same {switchCasesR3C0 -> switchCasesR3C1}
    switchCasesR3C0 -> switchCasesR4C0 [weight=100000000]
    switchCasesR3C1 -> switchCasesR4C1 [weight=100000000]
    rank = same {switchCasesR4C0 -> switchCasesR4C1}
    rank = same {switchCasesR4C1 -> switchCasesR4C2}
  }
  subgraph clusterprotocolBody {
    node [shape = box]
    label = <protocolBody = "{" [ protocolMembers ] "}" .>
    labeljust = l
    protocolBodyR0C0 [label = <DIC<br/>N protocolBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolBodyR0C1 [label = <DHU<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolBodyR1C1 [label = <DHV<br/>T "{"<br/>fi ["{"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolBodyR2C1 [label = <DHZ<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolBodyR3C1 [label = <DIA<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolBodyR4C1 [label = <DIB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    protocolBodyR3C1 -> protocolBodyR4C1 [weight=100000000]
    protocolBodyR2C1 -> protocolBodyR3C1 [weight=100000000]
    protocolBodyR2C2 [label = <DHX<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolBodyR3C2 [label = <DHW<br/>N protocolMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    protocolBodyR4C2 [label = <DHY<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    protocolBodyR3C2 -> protocolBodyR4C2 [weight=100000000]
    protocolBodyR2C2 -> protocolBodyR3C2 [weight=100000000]
    rank = same {protocolBodyR2C1 -> protocolBodyR2C2}
    protocolBodyR1C1 -> protocolBodyR2C1 [weight=100000000]
    protocolBodyR0C1 -> protocolBodyR1C1 [weight=100000000]
    rank = same {protocolBodyR0C0 -> protocolBodyR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolBodyR0C1 -> protocolBodyR0C2}
    protocolBodyR0C0 -> protocolBodyR1C0 [weight=100000000]
    rank = same {protocolBodyR1C0 -> protocolBodyR1C1}
    protocolBodyR0C2 -> protocolBodyR1C2 [weight=100000000]
    rank = same {protocolBodyR1C1 -> protocolBodyR1C2}
    protocolBodyR1C0 -> protocolBodyR2C0 [weight=100000000]
    rank = same {protocolBodyR2C0 -> protocolBodyR2C1}
    protocolBodyR1C2 -> protocolBodyR2C2 [weight=100000000]
    protocolBodyR2C0 -> protocolBodyR3C0 [weight=100000000]
    rank = same {protocolBodyR3C0 -> protocolBodyR3C1}
    protocolBodyR3C0 -> protocolBodyR4C0 [weight=100000000]
    rank = same {protocolBodyR4C0 -> protocolBodyR4C1}
  }
  subgraph clustercatchClause {
    node [shape = box]
    label = <catchClause = "catch" [ catchPatternList ] codeBlock .>
    labeljust = l
    catchClauseR0C0 [label = <BKU<br/>N catchClause<br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClauseR0C1 [label = <BKM<br/>ALT <br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClauseR1C1 [label = <BKN<br/>T "catch"<br/>fi ["catch"]<br/>fo ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var", "{"]<br/>am []<br/>>]
    catchClauseR2C1 [label = <BKR<br/>OPT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchClauseR3C1 [label = <BKS<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClauseR4C1 [label = <BKT<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClauseR3C1 -> catchClauseR4C1 [weight=100000000]
    catchClauseR2C1 -> catchClauseR3C1 [weight=100000000]
    catchClauseR2C2 [label = <BKP<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchClauseR3C2 [label = <BKO<br/>N catchPatternList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["{"]<br/>am []<br/>>]
    catchClauseR4C2 [label = <BKQ<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    catchClauseR3C2 -> catchClauseR4C2 [weight=100000000]
    catchClauseR2C2 -> catchClauseR3C2 [weight=100000000]
    rank = same {catchClauseR2C1 -> catchClauseR2C2}
    catchClauseR1C1 -> catchClauseR2C1 [weight=100000000]
    catchClauseR0C1 -> catchClauseR1C1 [weight=100000000]
    rank = same {catchClauseR0C0 -> catchClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {catchClauseR0C1 -> catchClauseR0C2}
    catchClauseR0C0 -> catchClauseR1C0 [weight=100000000]
    rank = same {catchClauseR1C0 -> catchClauseR1C1}
    catchClauseR0C2 -> catchClauseR1C2 [weight=100000000]
    rank = same {catchClauseR1C1 -> catchClauseR1C2}
    catchClauseR1C0 -> catchClauseR2C0 [weight=100000000]
    rank = same {catchClauseR2C0 -> catchClauseR2C1}
    catchClauseR1C2 -> catchClauseR2C2 [weight=100000000]
    catchClauseR2C0 -> catchClauseR3C0 [weight=100000000]
    rank = same {catchClauseR3C0 -> catchClauseR3C1}
    catchClauseR3C0 -> catchClauseR4C0 [weight=100000000]
    rank = same {catchClauseR4C0 -> catchClauseR4C1}
  }
  subgraph clustercatchClauses {
    node [shape = box]
    label = <catchClauses = catchClause [ catchClauses ] .>
    labeljust = l
    catchClausesR0C0 [label = <BKL<br/>N catchClauses<br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR0C1 [label = <BKE<br/>ALT <br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR1C1 [label = <BKF<br/>N catchClause<br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "catch", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR2C1 [label = <BKJ<br/>OPT <br/>fi ["", "catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR3C1 [label = <BKK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR2C1 -> catchClausesR3C1 [weight=100000000]
    catchClausesR2C2 [label = <BKH<br/>ALT <br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR3C2 [label = <BKG<br/>N catchClauses<br/>fi ["catch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR4C2 [label = <BKI<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    catchClausesR3C2 -> catchClausesR4C2 [weight=100000000]
    catchClausesR2C2 -> catchClausesR3C2 [weight=100000000]
    rank = same {catchClausesR2C1 -> catchClausesR2C2}
    catchClausesR1C1 -> catchClausesR2C1 [weight=100000000]
    catchClausesR0C1 -> catchClausesR1C1 [weight=100000000]
    rank = same {catchClausesR0C0 -> catchClausesR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {catchClausesR0C1 -> catchClausesR0C2}
    catchClausesR0C0 -> catchClausesR1C0 [weight=100000000]
    rank = same {catchClausesR1C0 -> catchClausesR1C1}
    catchClausesR0C2 -> catchClausesR1C2 [weight=100000000]
    rank = same {catchClausesR1C1 -> catchClausesR1C2}
    catchClausesR1C0 -> catchClausesR2C0 [weight=100000000]
    rank = same {catchClausesR2C0 -> catchClausesR2C1}
    catchClausesR1C2 -> catchClausesR2C2 [weight=100000000]
    catchClausesR2C0 -> catchClausesR3C0 [weight=100000000]
    rank = same {catchClausesR3C0 -> catchClausesR3C1}
    catchClausesR3C0 -> catchClausesR4C0 [weight=100000000]
    catchClausesR3C1 -> catchClausesR4C1 [weight=100000000]
    rank = same {catchClausesR4C0 -> catchClausesR4C1}
    rank = same {catchClausesR4C1 -> catchClausesR4C2}
  }
  subgraph clusteropaqueType {
    node [shape = box]
    label = <opaqueType = "some" type .>
    labeljust = l
    opaqueTypeR0C0 [label = <ML<br/>N opaqueType<br/>fi ["some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    opaqueTypeR0C1 [label = <MH<br/>ALT <br/>fi ["some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    opaqueTypeR1C1 [label = <MI<br/>T "some"<br/>fi ["some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "Any", "Self", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "some", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    opaqueTypeR2C1 [label = <MJ<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    opaqueTypeR3C1 [label = <MK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    opaqueTypeR2C1 -> opaqueTypeR3C1 [weight=100000000]
    opaqueTypeR1C1 -> opaqueTypeR2C1 [weight=100000000]
    opaqueTypeR0C1 -> opaqueTypeR1C1 [weight=100000000]
    rank = same {opaqueTypeR0C0 -> opaqueTypeR0C1}
    node [style = invis]
    edge [style = invis]
    opaqueTypeR0C0 -> opaqueTypeR1C0 [weight=100000000]
    rank = same {opaqueTypeR1C0 -> opaqueTypeR1C1}
    opaqueTypeR1C0 -> opaqueTypeR2C0 [weight=100000000]
    rank = same {opaqueTypeR2C0 -> opaqueTypeR2C1}
    opaqueTypeR2C0 -> opaqueTypeR3C0 [weight=100000000]
    rank = same {opaqueTypeR3C0 -> opaqueTypeR3C1}
  }
  subgraph clusterthrowsClause {
    node [shape = box]
    label = <throwsClause = "throws" | "throws" "(" type ")" .>
    labeljust = l
    throwsClauseR0C0 [label = <KV<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["throws"]<br/>>]
    throwsClauseR0C1 [label = <KM<br/>ALT <br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR1C1 [label = <KN<br/>T "throws"<br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR2C1 [label = <KO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR1C1 -> throwsClauseR2C1 [weight=100000000]
    throwsClauseR0C1 -> throwsClauseR1C1 [weight=100000000]
    throwsClauseR0C2 [label = <KP<br/>ALT <br/>fi ["throws"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR1C2 [label = <KQ<br/>T "throws"<br/>fi ["throws"]<br/>fo ["("]<br/>am []<br/>>]
    throwsClauseR2C2 [label = <KR<br/>T "("<br/>fi ["("]<br/>fo ["(", ")", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    throwsClauseR3C2 [label = <KS<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    throwsClauseR4C2 [label = <KT<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR5C2 [label = <KU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "&gt;", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    throwsClauseR4C2 -> throwsClauseR5C2 [weight=100000000]
    throwsClauseR3C2 -> throwsClauseR4C2 [weight=100000000]
    throwsClauseR2C2 -> throwsClauseR3C2 [weight=100000000]
    throwsClauseR1C2 -> throwsClauseR2C2 [weight=100000000]
    throwsClauseR0C2 -> throwsClauseR1C2 [weight=100000000]
    rank = same {throwsClauseR0C1 -> throwsClauseR0C2}
    rank = same {throwsClauseR0C0 -> throwsClauseR0C1}
    node [style = invis]
    edge [style = invis]
    throwsClauseR0C0 -> throwsClauseR1C0 [weight=100000000]
    rank = same {throwsClauseR1C0 -> throwsClauseR1C1}
    throwsClauseR1C0 -> throwsClauseR2C0 [weight=100000000]
    rank = same {throwsClauseR2C0 -> throwsClauseR2C1}
    throwsClauseR2C0 -> throwsClauseR3C0 [weight=100000000]
    throwsClauseR2C1 -> throwsClauseR3C1 [weight=100000000]
    rank = same {throwsClauseR3C0 -> throwsClauseR3C1}
    rank = same {throwsClauseR3C1 -> throwsClauseR3C2}
    throwsClauseR3C0 -> throwsClauseR4C0 [weight=100000000]
    throwsClauseR3C1 -> throwsClauseR4C1 [weight=100000000]
    rank = same {throwsClauseR4C0 -> throwsClauseR4C1}
    rank = same {throwsClauseR4C1 -> throwsClauseR4C2}
    throwsClauseR4C0 -> throwsClauseR5C0 [weight=100000000]
    throwsClauseR4C1 -> throwsClauseR5C1 [weight=100000000]
    rank = same {throwsClauseR5C0 -> throwsClauseR5C1}
    rank = same {throwsClauseR5C1 -> throwsClauseR5C2}
  }
  subgraph clustertupleType {
    node [shape = box]
    label = <tupleType = "(" ")" | "(" tupleTypeElement "," tupleTypeElementList ")" .>
    labeljust = l
    tupleTypeR0C0 [label = <HH<br/>N tupleType<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["("]<br/>>]
    tupleTypeR0C1 [label = <GW<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR1C1 [label = <GX<br/>T "("<br/>fi ["("]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeR2C1 [label = <GY<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR3C1 [label = <GZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR2C1 -> tupleTypeR3C1 [weight=100000000]
    tupleTypeR1C1 -> tupleTypeR2C1 [weight=100000000]
    tupleTypeR0C1 -> tupleTypeR1C1 [weight=100000000]
    tupleTypeR0C2 [label = <HA<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR1C2 [label = <HB<br/>T "("<br/>fi ["("]<br/>fo ["(", ",", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    tupleTypeR2C2 [label = <HC<br/>N tupleTypeElement<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [","]<br/>am []<br/>>]
    tupleTypeR3C2 [label = <HD<br/>T ","<br/>fi [","]<br/>fo ["(", ")", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    tupleTypeR4C2 [label = <HE<br/>N tupleTypeElementList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    tupleTypeR5C2 [label = <HF<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR6C2 [label = <HG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    tupleTypeR5C2 -> tupleTypeR6C2 [weight=100000000]
    tupleTypeR4C2 -> tupleTypeR5C2 [weight=100000000]
    tupleTypeR3C2 -> tupleTypeR4C2 [weight=100000000]
    tupleTypeR2C2 -> tupleTypeR3C2 [weight=100000000]
    tupleTypeR1C2 -> tupleTypeR2C2 [weight=100000000]
    tupleTypeR0C2 -> tupleTypeR1C2 [weight=100000000]
    rank = same {tupleTypeR0C1 -> tupleTypeR0C2}
    rank = same {tupleTypeR0C0 -> tupleTypeR0C1}
    node [style = invis]
    edge [style = invis]
    tupleTypeR0C0 -> tupleTypeR1C0 [weight=100000000]
    rank = same {tupleTypeR1C0 -> tupleTypeR1C1}
    tupleTypeR1C0 -> tupleTypeR2C0 [weight=100000000]
    rank = same {tupleTypeR2C0 -> tupleTypeR2C1}
    tupleTypeR2C0 -> tupleTypeR3C0 [weight=100000000]
    rank = same {tupleTypeR3C0 -> tupleTypeR3C1}
    tupleTypeR3C0 -> tupleTypeR4C0 [weight=100000000]
    tupleTypeR3C1 -> tupleTypeR4C1 [weight=100000000]
    rank = same {tupleTypeR4C0 -> tupleTypeR4C1}
    rank = same {tupleTypeR4C1 -> tupleTypeR4C2}
    tupleTypeR4C0 -> tupleTypeR5C0 [weight=100000000]
    tupleTypeR4C1 -> tupleTypeR5C1 [weight=100000000]
    rank = same {tupleTypeR5C0 -> tupleTypeR5C1}
    rank = same {tupleTypeR5C1 -> tupleTypeR5C2}
    tupleTypeR5C0 -> tupleTypeR6C0 [weight=100000000]
    tupleTypeR5C1 -> tupleTypeR6C1 [weight=100000000]
    rank = same {tupleTypeR6C0 -> tupleTypeR6C1}
    rank = same {tupleTypeR6C1 -> tupleTypeR6C2}
  }
  subgraph clustertype {
    node [shape = box]
    label = <type = functionType | arrayType | dictionaryType | typeIdentifier | tupleType | optionalType | implicitlyUnwrappedOptionalType | protocolCompositionType | opaqueType | metatypeType | anyType | selfType | "(" type ")" .>
    labeljust = l
    typeR0C0 [label = <EB<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>>]
    typeR0C1 [label = <DY<br/>ALT <br/>fi ["", "@"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    typeR1C1 [label = <DZ<br/>N functionType<br/>fi ["", "@"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@"]<br/>>]
    typeR2C1 [label = <EA<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C1 -> typeR2C1 [weight=100000000]
    typeR0C1 -> typeR1C1 [weight=100000000]
    typeR0C2 [label = <EC<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C2 [label = <ED<br/>N arrayType<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C2 [label = <EE<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C2 -> typeR2C2 [weight=100000000]
    typeR0C2 -> typeR1C2 [weight=100000000]
    typeR0C3 [label = <EF<br/>ALT <br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C3 [label = <EG<br/>N dictionaryType<br/>fi ["["]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C3 [label = <EH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C3 -> typeR2C3 [weight=100000000]
    typeR0C3 -> typeR1C3 [weight=100000000]
    typeR0C4 [label = <EI<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C4 [label = <EJ<br/>N typeIdentifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C4 [label = <EK<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C4 -> typeR2C4 [weight=100000000]
    typeR0C4 -> typeR1C4 [weight=100000000]
    typeR0C5 [label = <EL<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C5 [label = <EM<br/>N tupleType<br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C5 [label = <EN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C5 -> typeR2C5 [weight=100000000]
    typeR0C5 -> typeR1C5 [weight=100000000]
    typeR0C6 [label = <EO<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR1C6 [label = <EP<br/>N optionalType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR2C6 [label = <EQ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C6 -> typeR2C6 [weight=100000000]
    typeR0C6 -> typeR1C6 [weight=100000000]
    typeR0C7 [label = <ER<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR1C7 [label = <ES<br/>N implicitlyUnwrappedOptionalType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR2C7 [label = <ET<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C7 -> typeR2C7 [weight=100000000]
    typeR0C7 -> typeR1C7 [weight=100000000]
    typeR0C8 [label = <EU<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C8 [label = <EV<br/>N protocolCompositionType<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C8 [label = <EW<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C8 -> typeR2C8 [weight=100000000]
    typeR0C8 -> typeR1C8 [weight=100000000]
    typeR0C9 [label = <EX<br/>ALT <br/>fi ["some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C9 [label = <EY<br/>N opaqueType<br/>fi ["some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C9 [label = <EZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C9 -> typeR2C9 [weight=100000000]
    typeR0C9 -> typeR1C9 [weight=100000000]
    typeR0C10 [label = <FA<br/>ALT <br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR1C10 [label = <FB<br/>N metatypeType<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["@", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    typeR2C10 [label = <FC<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C10 -> typeR2C10 [weight=100000000]
    typeR0C10 -> typeR1C10 [weight=100000000]
    typeR0C11 [label = <FD<br/>ALT <br/>fi ["Any"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C11 [label = <FE<br/>N anyType<br/>fi ["Any"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C11 [label = <FF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C11 -> typeR2C11 [weight=100000000]
    typeR0C11 -> typeR1C11 [weight=100000000]
    typeR0C12 [label = <FG<br/>ALT <br/>fi ["Self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C12 [label = <FH<br/>N selfType<br/>fi ["Self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR2C12 [label = <FI<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C12 -> typeR2C12 [weight=100000000]
    typeR0C12 -> typeR1C12 [weight=100000000]
    typeR0C13 [label = <FJ<br/>ALT <br/>fi ["("]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR1C13 [label = <FK<br/>T "("<br/>fi ["("]<br/>fo ["(", ")", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    typeR2C13 [label = <FL<br/>N type<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo [")"]<br/>am []<br/>>]
    typeR3C13 [label = <FM<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR4C13 [label = <FN<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ")", ",", ".", "...", ":", ";", "=", "&gt;", "?", "@", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    typeR3C13 -> typeR4C13 [weight=100000000]
    typeR2C13 -> typeR3C13 [weight=100000000]
    typeR1C13 -> typeR2C13 [weight=100000000]
    typeR0C13 -> typeR1C13 [weight=100000000]
    rank = same {typeR0C12 -> typeR0C13}
    rank = same {typeR0C11 -> typeR0C12}
    rank = same {typeR0C10 -> typeR0C11}
    rank = same {typeR0C9 -> typeR0C10}
    rank = same {typeR0C8 -> typeR0C9}
    rank = same {typeR0C7 -> typeR0C8}
    rank = same {typeR0C6 -> typeR0C7}
    rank = same {typeR0C5 -> typeR0C6}
    rank = same {typeR0C4 -> typeR0C5}
    rank = same {typeR0C3 -> typeR0C4}
    rank = same {typeR0C2 -> typeR0C3}
    rank = same {typeR0C1 -> typeR0C2}
    rank = same {typeR0C0 -> typeR0C1}
    node [style = invis]
    edge [style = invis]
    typeR0C0 -> typeR1C0 [weight=100000000]
    rank = same {typeR1C0 -> typeR1C1}
    typeR1C0 -> typeR2C0 [weight=100000000]
    rank = same {typeR2C0 -> typeR2C1}
    typeR2C0 -> typeR3C0 [weight=100000000]
    typeR2C1 -> typeR3C1 [weight=100000000]
    rank = same {typeR3C0 -> typeR3C1}
    typeR2C2 -> typeR3C2 [weight=100000000]
    rank = same {typeR3C1 -> typeR3C2}
    typeR2C3 -> typeR3C3 [weight=100000000]
    rank = same {typeR3C2 -> typeR3C3}
    typeR2C4 -> typeR3C4 [weight=100000000]
    rank = same {typeR3C3 -> typeR3C4}
    typeR2C5 -> typeR3C5 [weight=100000000]
    rank = same {typeR3C4 -> typeR3C5}
    typeR2C6 -> typeR3C6 [weight=100000000]
    rank = same {typeR3C5 -> typeR3C6}
    typeR2C7 -> typeR3C7 [weight=100000000]
    rank = same {typeR3C6 -> typeR3C7}
    typeR2C8 -> typeR3C8 [weight=100000000]
    rank = same {typeR3C7 -> typeR3C8}
    typeR2C9 -> typeR3C9 [weight=100000000]
    rank = same {typeR3C8 -> typeR3C9}
    typeR2C10 -> typeR3C10 [weight=100000000]
    rank = same {typeR3C9 -> typeR3C10}
    typeR2C11 -> typeR3C11 [weight=100000000]
    rank = same {typeR3C10 -> typeR3C11}
    typeR2C12 -> typeR3C12 [weight=100000000]
    rank = same {typeR3C11 -> typeR3C12}
    rank = same {typeR3C12 -> typeR3C13}
    typeR3C0 -> typeR4C0 [weight=100000000]
    typeR3C1 -> typeR4C1 [weight=100000000]
    rank = same {typeR4C0 -> typeR4C1}
    typeR3C2 -> typeR4C2 [weight=100000000]
    rank = same {typeR4C1 -> typeR4C2}
    typeR3C3 -> typeR4C3 [weight=100000000]
    rank = same {typeR4C2 -> typeR4C3}
    typeR3C4 -> typeR4C4 [weight=100000000]
    rank = same {typeR4C3 -> typeR4C4}
    typeR3C5 -> typeR4C5 [weight=100000000]
    rank = same {typeR4C4 -> typeR4C5}
    typeR3C6 -> typeR4C6 [weight=100000000]
    rank = same {typeR4C5 -> typeR4C6}
    typeR3C7 -> typeR4C7 [weight=100000000]
    rank = same {typeR4C6 -> typeR4C7}
    typeR3C8 -> typeR4C8 [weight=100000000]
    rank = same {typeR4C7 -> typeR4C8}
    typeR3C9 -> typeR4C9 [weight=100000000]
    rank = same {typeR4C8 -> typeR4C9}
    typeR3C10 -> typeR4C10 [weight=100000000]
    rank = same {typeR4C9 -> typeR4C10}
    typeR3C11 -> typeR4C11 [weight=100000000]
    rank = same {typeR4C10 -> typeR4C11}
    typeR3C12 -> typeR4C12 [weight=100000000]
    rank = same {typeR4C11 -> typeR4C12}
    rank = same {typeR4C12 -> typeR4C13}
  }
  subgraph clusterpatternInitializerList {
    node [shape = box]
    label = <patternInitializerList = patternInitializer | patternInitializer "," patternInitializerList .>
    labeljust = l
    patternInitializerListR0C0 [label = <CDB<br/>N patternInitializerList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>>]
    patternInitializerListR0C1 [label = <CCT<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerListR1C1 [label = <CCU<br/>N patternInitializer<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerListR2C1 [label = <CCV<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerListR1C1 -> patternInitializerListR2C1 [weight=100000000]
    patternInitializerListR0C1 -> patternInitializerListR1C1 [weight=100000000]
    patternInitializerListR0C2 [label = <CCW<br/>ALT <br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerListR1C2 [label = <CCX<br/>N patternInitializer<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo [","]<br/>am []<br/>>]
    patternInitializerListR2C2 [label = <CCY<br/>T ","<br/>fi [","]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ";", "@", "_", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "is", "let", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "var", "while", "}"]<br/>am []<br/>>]
    patternInitializerListR3C2 [label = <CCZ<br/>N patternInitializerList<br/>fi ["", "(", "_", "escapedIdentifier", "implicitParameterName", "is", "let", "plainIdentifier", "propertyWrapperProjection", "try", "var"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "try"]<br/>>]
    patternInitializerListR4C2 [label = <CDA<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    patternInitializerListR3C2 -> patternInitializerListR4C2 [weight=100000000]
    patternInitializerListR2C2 -> patternInitializerListR3C2 [weight=100000000]
    patternInitializerListR1C2 -> patternInitializerListR2C2 [weight=100000000]
    patternInitializerListR0C2 -> patternInitializerListR1C2 [weight=100000000]
    rank = same {patternInitializerListR0C1 -> patternInitializerListR0C2}
    rank = same {patternInitializerListR0C0 -> patternInitializerListR0C1}
    node [style = invis]
    edge [style = invis]
    patternInitializerListR0C0 -> patternInitializerListR1C0 [weight=100000000]
    rank = same {patternInitializerListR1C0 -> patternInitializerListR1C1}
    patternInitializerListR1C0 -> patternInitializerListR2C0 [weight=100000000]
    rank = same {patternInitializerListR2C0 -> patternInitializerListR2C1}
    patternInitializerListR2C0 -> patternInitializerListR3C0 [weight=100000000]
    patternInitializerListR2C1 -> patternInitializerListR3C1 [weight=100000000]
    rank = same {patternInitializerListR3C0 -> patternInitializerListR3C1}
    rank = same {patternInitializerListR3C1 -> patternInitializerListR3C2}
    patternInitializerListR3C0 -> patternInitializerListR4C0 [weight=100000000]
    patternInitializerListR3C1 -> patternInitializerListR4C1 [weight=100000000]
    rank = same {patternInitializerListR4C0 -> patternInitializerListR4C1}
    rank = same {patternInitializerListR4C1 -> patternInitializerListR4C2}
  }
  subgraph clusterelseDirectiveClause {
    node [shape = box]
    label = <elseDirectiveClause = elseDirective [ statements ] .>
    labeljust = l
    elseDirectiveClauseR0C0 [label = <BNQ<br/>N elseDirectiveClause<br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR0C1 [label = <BNJ<br/>ALT <br/>fi ["#else"]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR1C1 [label = <BNK<br/>N elseDirective<br/>fi ["#else"]<br/>fo ["#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseDirectiveClauseR2C1 [label = <BNO<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR3C1 [label = <BNP<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR2C1 -> elseDirectiveClauseR3C1 [weight=100000000]
    elseDirectiveClauseR2C2 [label = <BNM<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR3C2 [label = <BNL<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR4C2 [label = <BNN<br/>END <br/>fi [""]<br/>fo ["#endif"]<br/>am []<br/>>]
    elseDirectiveClauseR3C2 -> elseDirectiveClauseR4C2 [weight=100000000]
    elseDirectiveClauseR2C2 -> elseDirectiveClauseR3C2 [weight=100000000]
    rank = same {elseDirectiveClauseR2C1 -> elseDirectiveClauseR2C2}
    elseDirectiveClauseR1C1 -> elseDirectiveClauseR2C1 [weight=100000000]
    elseDirectiveClauseR0C1 -> elseDirectiveClauseR1C1 [weight=100000000]
    rank = same {elseDirectiveClauseR0C0 -> elseDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {elseDirectiveClauseR0C1 -> elseDirectiveClauseR0C2}
    elseDirectiveClauseR0C0 -> elseDirectiveClauseR1C0 [weight=100000000]
    rank = same {elseDirectiveClauseR1C0 -> elseDirectiveClauseR1C1}
    elseDirectiveClauseR0C2 -> elseDirectiveClauseR1C2 [weight=100000000]
    rank = same {elseDirectiveClauseR1C1 -> elseDirectiveClauseR1C2}
    elseDirectiveClauseR1C0 -> elseDirectiveClauseR2C0 [weight=100000000]
    rank = same {elseDirectiveClauseR2C0 -> elseDirectiveClauseR2C1}
    elseDirectiveClauseR1C2 -> elseDirectiveClauseR2C2 [weight=100000000]
    elseDirectiveClauseR2C0 -> elseDirectiveClauseR3C0 [weight=100000000]
    rank = same {elseDirectiveClauseR3C0 -> elseDirectiveClauseR3C1}
    elseDirectiveClauseR3C0 -> elseDirectiveClauseR4C0 [weight=100000000]
    elseDirectiveClauseR3C1 -> elseDirectiveClauseR4C1 [weight=100000000]
    rank = same {elseDirectiveClauseR4C0 -> elseDirectiveClauseR4C1}
    rank = same {elseDirectiveClauseR4C1 -> elseDirectiveClauseR4C2}
  }
  subgraph clustercaptureList {
    node [shape = box]
    label = <captureList = "[" captureListItems "]" .>
    labeljust = l
    captureListR0C0 [label = <AGH<br/>N captureList<br/>fi ["["]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "in", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListR0C1 [label = <AGC<br/>ALT <br/>fi ["["]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "in", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListR1C1 [label = <AGD<br/>T "["<br/>fi ["["]<br/>fo ["]", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>am []<br/>>]
    captureListR2C1 [label = <AGE<br/>N captureListItems<br/>fi ["", "unowned", "unowned(safe)", "unowned(unsafe)", "weak"]<br/>fo ["]"]<br/>am []<br/>>]
    captureListR3C1 [label = <AGF<br/>T "]"<br/>fi ["]"]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "in", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListR4C1 [label = <AGG<br/>END <br/>fi [""]<br/>fo ["(", "escapedIdentifier", "implicitParameterName", "in", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    captureListR3C1 -> captureListR4C1 [weight=100000000]
    captureListR2C1 -> captureListR3C1 [weight=100000000]
    captureListR1C1 -> captureListR2C1 [weight=100000000]
    captureListR0C1 -> captureListR1C1 [weight=100000000]
    rank = same {captureListR0C0 -> captureListR0C1}
    node [style = invis]
    edge [style = invis]
    captureListR0C0 -> captureListR1C0 [weight=100000000]
    rank = same {captureListR1C0 -> captureListR1C1}
    captureListR1C0 -> captureListR2C0 [weight=100000000]
    rank = same {captureListR2C0 -> captureListR2C1}
    captureListR2C0 -> captureListR3C0 [weight=100000000]
    rank = same {captureListR3C0 -> captureListR3C1}
    captureListR3C0 -> captureListR4C0 [weight=100000000]
    rank = same {captureListR4C0 -> captureListR4C1}
  }
  subgraph clusterattributeArgumentClause {
    node [shape = box]
    label = <attributeArgumentClause = "(" [ balancedTokens ] ")" .>
    labeljust = l
    attributeArgumentClauseR0C0 [label = <EGE<br/>N attributeArgumentClause<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeArgumentClauseR0C1 [label = <EFW<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeArgumentClauseR1C1 [label = <EFX<br/>T "("<br/>fi ["("]<br/>fo ["(", ")", "[", "innerBalancedToken", "{"]<br/>am []<br/>>]
    attributeArgumentClauseR2C1 [label = <EGB<br/>OPT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo [")"]<br/>am []<br/>>]
    attributeArgumentClauseR3C1 [label = <EGC<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeArgumentClauseR4C1 [label = <EGD<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeArgumentClauseR3C1 -> attributeArgumentClauseR4C1 [weight=100000000]
    attributeArgumentClauseR2C1 -> attributeArgumentClauseR3C1 [weight=100000000]
    attributeArgumentClauseR2C2 [label = <EFZ<br/>ALT <br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo [")"]<br/>am []<br/>>]
    attributeArgumentClauseR3C2 [label = <EFY<br/>N balancedTokens<br/>fi ["", "(", "[", "innerBalancedToken", "{"]<br/>fo [")"]<br/>am []<br/>>]
    attributeArgumentClauseR4C2 [label = <EGA<br/>END <br/>fi [""]<br/>fo [")"]<br/>am []<br/>>]
    attributeArgumentClauseR3C2 -> attributeArgumentClauseR4C2 [weight=100000000]
    attributeArgumentClauseR2C2 -> attributeArgumentClauseR3C2 [weight=100000000]
    rank = same {attributeArgumentClauseR2C1 -> attributeArgumentClauseR2C2}
    attributeArgumentClauseR1C1 -> attributeArgumentClauseR2C1 [weight=100000000]
    attributeArgumentClauseR0C1 -> attributeArgumentClauseR1C1 [weight=100000000]
    rank = same {attributeArgumentClauseR0C0 -> attributeArgumentClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {attributeArgumentClauseR0C1 -> attributeArgumentClauseR0C2}
    attributeArgumentClauseR0C0 -> attributeArgumentClauseR1C0 [weight=100000000]
    rank = same {attributeArgumentClauseR1C0 -> attributeArgumentClauseR1C1}
    attributeArgumentClauseR0C2 -> attributeArgumentClauseR1C2 [weight=100000000]
    rank = same {attributeArgumentClauseR1C1 -> attributeArgumentClauseR1C2}
    attributeArgumentClauseR1C0 -> attributeArgumentClauseR2C0 [weight=100000000]
    rank = same {attributeArgumentClauseR2C0 -> attributeArgumentClauseR2C1}
    attributeArgumentClauseR1C2 -> attributeArgumentClauseR2C2 [weight=100000000]
    attributeArgumentClauseR2C0 -> attributeArgumentClauseR3C0 [weight=100000000]
    rank = same {attributeArgumentClauseR3C0 -> attributeArgumentClauseR3C1}
    attributeArgumentClauseR3C0 -> attributeArgumentClauseR4C0 [weight=100000000]
    rank = same {attributeArgumentClauseR4C0 -> attributeArgumentClauseR4C1}
  }
  subgraph clusternumericLiteral {
    node [shape = box]
    label = <numericLiteral = integerLiteral | floatingPointLiteral .>
    labeljust = l
    numericLiteralR0C0 [label = <BV<br/>N numericLiteral<br/>fi ["binaryLiteral", "decimalFloatingPointLiteral", "decimalLiteral", "hexadecimalFloatingPointLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR0C1 [label = <BP<br/>ALT <br/>fi ["binaryLiteral", "decimalLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR1C1 [label = <BQ<br/>N integerLiteral<br/>fi ["binaryLiteral", "decimalLiteral", "hexadecimalLiteral", "octalLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR2C1 [label = <BR<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR1C1 -> numericLiteralR2C1 [weight=100000000]
    numericLiteralR0C1 -> numericLiteralR1C1 [weight=100000000]
    numericLiteralR0C2 [label = <BS<br/>ALT <br/>fi ["decimalFloatingPointLiteral", "hexadecimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR1C2 [label = <BT<br/>N floatingPointLiteral<br/>fi ["decimalFloatingPointLiteral", "hexadecimalFloatingPointLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR2C2 [label = <BU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    numericLiteralR1C2 -> numericLiteralR2C2 [weight=100000000]
    numericLiteralR0C2 -> numericLiteralR1C2 [weight=100000000]
    rank = same {numericLiteralR0C1 -> numericLiteralR0C2}
    rank = same {numericLiteralR0C0 -> numericLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    numericLiteralR0C0 -> numericLiteralR1C0 [weight=100000000]
    rank = same {numericLiteralR1C0 -> numericLiteralR1C1}
    numericLiteralR1C0 -> numericLiteralR2C0 [weight=100000000]
    rank = same {numericLiteralR2C0 -> numericLiteralR2C1}
  }
  subgraph clusterprotocolName {
    node [shape = box]
    label = <protocolName = identifier .>
    labeljust = l
    protocolNameR0C0 [label = <DHT<br/>N protocolName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    protocolNameR0C1 [label = <DHQ<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    protocolNameR1C1 [label = <DHR<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    protocolNameR2C1 [label = <DHS<br/>END <br/>fi [""]<br/>fo [":", "where", "{"]<br/>am []<br/>>]
    protocolNameR1C1 -> protocolNameR2C1 [weight=100000000]
    protocolNameR0C1 -> protocolNameR1C1 [weight=100000000]
    rank = same {protocolNameR0C0 -> protocolNameR0C1}
    node [style = invis]
    edge [style = invis]
    protocolNameR0C0 -> protocolNameR1C0 [weight=100000000]
    rank = same {protocolNameR1C0 -> protocolNameR1C1}
    protocolNameR1C0 -> protocolNameR2C0 [weight=100000000]
    rank = same {protocolNameR2C0 -> protocolNameR2C1}
  }
  subgraph clustermacroHead {
    node [shape = box]
    label = <macroHead = [ attributes ] [ declarationModifiers ] "macro" .>
    labeljust = l
    macroHeadR0C0 [label = <DVA<br/>N macroHead<br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroHeadR0C1 [label = <DUP<br/>ALT <br/>fi ["", "@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroHeadR1C1 [label = <DUT<br/>OPT <br/>fi ["", "@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    macroHeadR2C1 [label = <DUX<br/>OPT <br/>fi ["", "class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["macro"]<br/>am []<br/>>]
    macroHeadR3C1 [label = <DUY<br/>T "macro"<br/>fi ["macro"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroHeadR4C1 [label = <DUZ<br/>END <br/>fi [""]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    macroHeadR3C1 -> macroHeadR4C1 [weight=100000000]
    macroHeadR2C1 -> macroHeadR3C1 [weight=100000000]
    macroHeadR2C2 [label = <DUV<br/>ALT <br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["macro"]<br/>am []<br/>>]
    macroHeadR3C2 [label = <DUU<br/>N declarationModifiers<br/>fi ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>fo ["macro"]<br/>am []<br/>>]
    macroHeadR4C2 [label = <DUW<br/>END <br/>fi [""]<br/>fo ["macro"]<br/>am []<br/>>]
    macroHeadR3C2 -> macroHeadR4C2 [weight=100000000]
    macroHeadR2C2 -> macroHeadR3C2 [weight=100000000]
    rank = same {macroHeadR2C1 -> macroHeadR2C2}
    macroHeadR1C1 -> macroHeadR2C1 [weight=100000000]
    macroHeadR1C3 [label = <DUR<br/>ALT <br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    macroHeadR2C3 [label = <DUQ<br/>N attributes<br/>fi ["@"]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    macroHeadR3C3 [label = <DUS<br/>END <br/>fi [""]<br/>fo ["class", "convenience", "dynamic", "fileprivate", "final", "infix", "internal", "lazy", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "postfix", "prefix", "private", "public", "required", "static", "unowned", "weak"]<br/>am []<br/>>]
    macroHeadR2C3 -> macroHeadR3C3 [weight=100000000]
    macroHeadR1C3 -> macroHeadR2C3 [weight=100000000]
    rank = same {macroHeadR1C1 -> macroHeadR1C3}
    macroHeadR0C1 -> macroHeadR1C1 [weight=100000000]
    rank = same {macroHeadR0C0 -> macroHeadR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {macroHeadR0C1 -> macroHeadR0C2}
    rank = same {macroHeadR0C2 -> macroHeadR0C3}
    macroHeadR0C0 -> macroHeadR1C0 [weight=100000000]
    rank = same {macroHeadR1C0 -> macroHeadR1C1}
    macroHeadR0C3 -> macroHeadR1C3 [weight=100000000]
    macroHeadR1C0 -> macroHeadR2C0 [weight=100000000]
    rank = same {macroHeadR2C0 -> macroHeadR2C1}
    macroHeadR2C0 -> macroHeadR3C0 [weight=100000000]
    rank = same {macroHeadR3C0 -> macroHeadR3C1}
    macroHeadR3C0 -> macroHeadR4C0 [weight=100000000]
    rank = same {macroHeadR4C0 -> macroHeadR4C1}
    macroHeadR3C3 -> macroHeadR4C3 [weight=100000000]
    rank = same {macroHeadR4C2 -> macroHeadR4C3}
  }
  subgraph clusterattribute {
    node [shape = box]
    label = <attribute = "@" attributeName [ attributeArgumentClause ] .>
    labeljust = l
    attributeR0C0 [label = <EFR<br/>N attribute<br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR0C1 [label = <EFJ<br/>ALT <br/>fi ["@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR1C1 [label = <EFK<br/>T "@"<br/>fi ["@"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    attributeR2C1 [label = <EFL<br/>N attributeName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR3C1 [label = <EFP<br/>OPT <br/>fi ["", "("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am ["("]<br/>>]
    attributeR4C1 [label = <EFQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR3C1 -> attributeR4C1 [weight=100000000]
    attributeR3C2 [label = <EFN<br/>ALT <br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR4C2 [label = <EFM<br/>N attributeArgumentClause<br/>fi ["("]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR5C2 [label = <EFO<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", "...", ":", ";", "=", "@", "Any", "Self", "[", "actor", "as", "associatedtype", "borrowing", "break", "case", "class", "consuming", "continue", "convenience", "default", "defer", "deinit", "didSet", "do", "dynamic", "else", "enum", "escapedIdentifier", "extension", "fallthrough", "fileprivate", "final", "for", "func", "get", "guard", "if", "implicitParameterName", "import", "in", "indirect", "infix", "init", "inout", "internal", "lazy", "let", "macro", "mutating", "nonisolated", "nonmutating", "open", "optional", "override", "package", "plainIdentifier", "postfix", "precedencegroup", "prefix", "private", "propertyWrapperProjection", "protocol", "public", "repeat", "required", "return", "set", "some", "static", "struct", "subscript", "switch", "throw", "try", "typealias", "unowned", "var", "weak", "where", "while", "willSet", "{", "}"]<br/>am []<br/>>]
    attributeR4C2 -> attributeR5C2 [weight=100000000]
    attributeR3C2 -> attributeR4C2 [weight=100000000]
    rank = same {attributeR3C1 -> attributeR3C2}
    attributeR2C1 -> attributeR3C1 [weight=100000000]
    attributeR1C1 -> attributeR2C1 [weight=100000000]
    attributeR0C1 -> attributeR1C1 [weight=100000000]
    rank = same {attributeR0C0 -> attributeR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {attributeR0C1 -> attributeR0C2}
    attributeR0C0 -> attributeR1C0 [weight=100000000]
    rank = same {attributeR1C0 -> attributeR1C1}
    attributeR0C2 -> attributeR1C2 [weight=100000000]
    rank = same {attributeR1C1 -> attributeR1C2}
    attributeR1C0 -> attributeR2C0 [weight=100000000]
    rank = same {attributeR2C0 -> attributeR2C1}
    attributeR1C2 -> attributeR2C2 [weight=100000000]
    rank = same {attributeR2C1 -> attributeR2C2}
    attributeR2C0 -> attributeR3C0 [weight=100000000]
    rank = same {attributeR3C0 -> attributeR3C1}
    attributeR2C2 -> attributeR3C2 [weight=100000000]
    attributeR3C0 -> attributeR4C0 [weight=100000000]
    rank = same {attributeR4C0 -> attributeR4C1}
    attributeR4C0 -> attributeR5C0 [weight=100000000]
    attributeR4C1 -> attributeR5C1 [weight=100000000]
    rank = same {attributeR5C0 -> attributeR5C1}
    rank = same {attributeR5C1 -> attributeR5C2}
  }
  subgraph clusterextensionMembers {
    node [shape = box]
    label = <extensionMembers = extensionMember [ extensionMembers ] .>
    labeljust = l
    extensionMembersR0C0 [label = <DRQ<br/>N extensionMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR0C1 [label = <DRJ<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR1C1 [label = <DRK<br/>N extensionMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    extensionMembersR2C1 [label = <DRO<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR3C1 [label = <DRP<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR2C1 -> extensionMembersR3C1 [weight=100000000]
    extensionMembersR2C2 [label = <DRM<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR3C2 [label = <DRL<br/>N extensionMembers<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR4C2 [label = <DRN<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    extensionMembersR3C2 -> extensionMembersR4C2 [weight=100000000]
    extensionMembersR2C2 -> extensionMembersR3C2 [weight=100000000]
    rank = same {extensionMembersR2C1 -> extensionMembersR2C2}
    extensionMembersR1C1 -> extensionMembersR2C1 [weight=100000000]
    extensionMembersR0C1 -> extensionMembersR1C1 [weight=100000000]
    rank = same {extensionMembersR0C0 -> extensionMembersR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {extensionMembersR0C1 -> extensionMembersR0C2}
    extensionMembersR0C0 -> extensionMembersR1C0 [weight=100000000]
    rank = same {extensionMembersR1C0 -> extensionMembersR1C1}
    extensionMembersR0C2 -> extensionMembersR1C2 [weight=100000000]
    rank = same {extensionMembersR1C1 -> extensionMembersR1C2}
    extensionMembersR1C0 -> extensionMembersR2C0 [weight=100000000]
    rank = same {extensionMembersR2C0 -> extensionMembersR2C1}
    extensionMembersR1C2 -> extensionMembersR2C2 [weight=100000000]
    extensionMembersR2C0 -> extensionMembersR3C0 [weight=100000000]
    rank = same {extensionMembersR3C0 -> extensionMembersR3C1}
    extensionMembersR3C0 -> extensionMembersR4C0 [weight=100000000]
    extensionMembersR3C1 -> extensionMembersR4C1 [weight=100000000]
    rank = same {extensionMembersR4C0 -> extensionMembersR4C1}
    rank = same {extensionMembersR4C1 -> extensionMembersR4C2}
  }
  subgraph clusterlabeledStatement {
    node [shape = box]
    label = <labeledStatement = statementLabel loopStatement | statementLabel ifStatement | statementLabel switchStatement | statementLabel doStatement .>
    labeljust = l
    labeledStatementR0C0 [label = <BGT<br/>N labeledStatement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    labeledStatementR0C1 [label = <BGP<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR1C1 [label = <BGQ<br/>N statementLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["for", "repeat", "while"]<br/>am []<br/>>]
    labeledStatementR2C1 [label = <BGR<br/>N loopStatement<br/>fi ["for", "repeat", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR3C1 [label = <BGS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR2C1 -> labeledStatementR3C1 [weight=100000000]
    labeledStatementR1C1 -> labeledStatementR2C1 [weight=100000000]
    labeledStatementR0C1 -> labeledStatementR1C1 [weight=100000000]
    labeledStatementR0C2 [label = <BGU<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR1C2 [label = <BGV<br/>N statementLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["if"]<br/>am []<br/>>]
    labeledStatementR2C2 [label = <BGW<br/>N ifStatement<br/>fi ["if"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR3C2 [label = <BGX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR2C2 -> labeledStatementR3C2 [weight=100000000]
    labeledStatementR1C2 -> labeledStatementR2C2 [weight=100000000]
    labeledStatementR0C2 -> labeledStatementR1C2 [weight=100000000]
    labeledStatementR0C3 [label = <BGY<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR1C3 [label = <BGZ<br/>N statementLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["switch"]<br/>am []<br/>>]
    labeledStatementR2C3 [label = <BHA<br/>N switchStatement<br/>fi ["switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR3C3 [label = <BHB<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR2C3 -> labeledStatementR3C3 [weight=100000000]
    labeledStatementR1C3 -> labeledStatementR2C3 [weight=100000000]
    labeledStatementR0C3 -> labeledStatementR1C3 [weight=100000000]
    labeledStatementR0C4 [label = <BHC<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR1C4 [label = <BHD<br/>N statementLabel<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["do"]<br/>am []<br/>>]
    labeledStatementR2C4 [label = <BHE<br/>N doStatement<br/>fi ["do"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR3C4 [label = <BHF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    labeledStatementR2C4 -> labeledStatementR3C4 [weight=100000000]
    labeledStatementR1C4 -> labeledStatementR2C4 [weight=100000000]
    labeledStatementR0C4 -> labeledStatementR1C4 [weight=100000000]
    rank = same {labeledStatementR0C3 -> labeledStatementR0C4}
    rank = same {labeledStatementR0C2 -> labeledStatementR0C3}
    rank = same {labeledStatementR0C1 -> labeledStatementR0C2}
    rank = same {labeledStatementR0C0 -> labeledStatementR0C1}
    node [style = invis]
    edge [style = invis]
    labeledStatementR0C0 -> labeledStatementR1C0 [weight=100000000]
    rank = same {labeledStatementR1C0 -> labeledStatementR1C1}
    labeledStatementR1C0 -> labeledStatementR2C0 [weight=100000000]
    rank = same {labeledStatementR2C0 -> labeledStatementR2C1}
    labeledStatementR2C0 -> labeledStatementR3C0 [weight=100000000]
    rank = same {labeledStatementR3C0 -> labeledStatementR3C1}
  }
  subgraph clusterplatformVersion {
    node [shape = box]
    label = <platformVersion = "decimalDigits" | "decimalDigits" "." "decimalDigits" | "decimalDigits" "." "decimalDigits" "." "decimalDigits" .>
    labeljust = l
    platformVersionR0C0 [label = <BXS<br/>N platformVersion<br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am ["decimalDigits"]<br/>>]
    platformVersionR0C1 [label = <BXP<br/>ALT <br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR1C1 [label = <BXQ<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR2C1 [label = <BXR<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR1C1 -> platformVersionR2C1 [weight=100000000]
    platformVersionR0C1 -> platformVersionR1C1 [weight=100000000]
    platformVersionR0C2 [label = <BXT<br/>ALT <br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR1C2 [label = <BXU<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo ["."]<br/>am []<br/>>]
    platformVersionR2C2 [label = <BXV<br/>T "."<br/>fi ["."]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformVersionR3C2 [label = <BXW<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR4C2 [label = <BXX<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR3C2 -> platformVersionR4C2 [weight=100000000]
    platformVersionR2C2 -> platformVersionR3C2 [weight=100000000]
    platformVersionR1C2 -> platformVersionR2C2 [weight=100000000]
    platformVersionR0C2 -> platformVersionR1C2 [weight=100000000]
    platformVersionR0C3 [label = <BXY<br/>ALT <br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR1C3 [label = <BXZ<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo ["."]<br/>am []<br/>>]
    platformVersionR2C3 [label = <BYA<br/>T "."<br/>fi ["."]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformVersionR3C3 [label = <BYB<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo ["."]<br/>am []<br/>>]
    platformVersionR4C3 [label = <BYC<br/>T "."<br/>fi ["."]<br/>fo ["decimalDigits"]<br/>am []<br/>>]
    platformVersionR5C3 [label = <BYD<br/>T "decimalDigits"<br/>fi ["decimalDigits"]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR6C3 [label = <BYE<br/>END <br/>fi [""]<br/>fo [")", ","]<br/>am []<br/>>]
    platformVersionR5C3 -> platformVersionR6C3 [weight=100000000]
    platformVersionR4C3 -> platformVersionR5C3 [weight=100000000]
    platformVersionR3C3 -> platformVersionR4C3 [weight=100000000]
    platformVersionR2C3 -> platformVersionR3C3 [weight=100000000]
    platformVersionR1C3 -> platformVersionR2C3 [weight=100000000]
    platformVersionR0C3 -> platformVersionR1C3 [weight=100000000]
    rank = same {platformVersionR0C2 -> platformVersionR0C3}
    rank = same {platformVersionR0C1 -> platformVersionR0C2}
    rank = same {platformVersionR0C0 -> platformVersionR0C1}
    node [style = invis]
    edge [style = invis]
    platformVersionR0C0 -> platformVersionR1C0 [weight=100000000]
    rank = same {platformVersionR1C0 -> platformVersionR1C1}
    platformVersionR1C0 -> platformVersionR2C0 [weight=100000000]
    rank = same {platformVersionR2C0 -> platformVersionR2C1}
    platformVersionR2C0 -> platformVersionR3C0 [weight=100000000]
    platformVersionR2C1 -> platformVersionR3C1 [weight=100000000]
    rank = same {platformVersionR3C0 -> platformVersionR3C1}
    rank = same {platformVersionR3C1 -> platformVersionR3C2}
    platformVersionR3C0 -> platformVersionR4C0 [weight=100000000]
    platformVersionR3C1 -> platformVersionR4C1 [weight=100000000]
    rank = same {platformVersionR4C0 -> platformVersionR4C1}
    rank = same {platformVersionR4C1 -> platformVersionR4C2}
    platformVersionR4C0 -> platformVersionR5C0 [weight=100000000]
    platformVersionR4C1 -> platformVersionR5C1 [weight=100000000]
    rank = same {platformVersionR5C0 -> platformVersionR5C1}
    platformVersionR4C2 -> platformVersionR5C2 [weight=100000000]
    rank = same {platformVersionR5C1 -> platformVersionR5C2}
    rank = same {platformVersionR5C2 -> platformVersionR5C3}
    platformVersionR5C0 -> platformVersionR6C0 [weight=100000000]
    platformVersionR5C1 -> platformVersionR6C1 [weight=100000000]
    rank = same {platformVersionR6C0 -> platformVersionR6C1}
    platformVersionR5C2 -> platformVersionR6C2 [weight=100000000]
    rank = same {platformVersionR6C1 -> platformVersionR6C2}
    rank = same {platformVersionR6C2 -> platformVersionR6C3}
  }
  subgraph clusterwhereExpression {
    node [shape = box]
    label = <whereExpression = expression .>
    labeljust = l
    whereExpressionR0C0 [label = <BET<br/>N whereExpression<br/>fi ["", "try"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereExpressionR0C1 [label = <BEQ<br/>ALT <br/>fi ["", "try"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereExpressionR1C1 [label = <BER<br/>N expression<br/>fi ["", "try"]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereExpressionR2C1 [label = <BES<br/>END <br/>fi [""]<br/>fo [",", ":", "{"]<br/>am []<br/>>]
    whereExpressionR1C1 -> whereExpressionR2C1 [weight=100000000]
    whereExpressionR0C1 -> whereExpressionR1C1 [weight=100000000]
    rank = same {whereExpressionR0C0 -> whereExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    whereExpressionR0C0 -> whereExpressionR1C0 [weight=100000000]
    rank = same {whereExpressionR1C0 -> whereExpressionR1C1}
    whereExpressionR1C0 -> whereExpressionR2C0 [weight=100000000]
    rank = same {whereExpressionR2C0 -> whereExpressionR2C1}
  }
  subgraph clustersetterKeywordClause {
    node [shape = box]
    label = <setterKeywordClause = [ attributes ] [ mutationModifier ] "set" .>
    labeljust = l
    setterKeywordClauseR0C0 [label = <CJI<br/>N setterKeywordClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    setterKeywordClauseR0C1 [label = <CIX<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    setterKeywordClauseR1C1 [label = <CJB<br/>OPT <br/>fi ["", "@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterKeywordClauseR2C1 [label = <CJF<br/>OPT <br/>fi ["", "mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterKeywordClauseR3C1 [label = <CJG<br/>T "set"<br/>fi ["set"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    setterKeywordClauseR4C1 [label = <CJH<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    setterKeywordClauseR3C1 -> setterKeywordClauseR4C1 [weight=100000000]
    setterKeywordClauseR2C1 -> setterKeywordClauseR3C1 [weight=100000000]
    setterKeywordClauseR2C2 [label = <CJD<br/>ALT <br/>fi ["mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterKeywordClauseR3C2 [label = <CJC<br/>N mutationModifier<br/>fi ["mutating", "nonmutating"]<br/>fo ["set"]<br/>am []<br/>>]
    setterKeywordClauseR4C2 [label = <CJE<br/>END <br/>fi [""]<br/>fo ["set"]<br/>am []<br/>>]
    setterKeywordClauseR3C2 -> setterKeywordClauseR4C2 [weight=100000000]
    setterKeywordClauseR2C2 -> setterKeywordClauseR3C2 [weight=100000000]
    rank = same {setterKeywordClauseR2C1 -> setterKeywordClauseR2C2}
    setterKeywordClauseR1C1 -> setterKeywordClauseR2C1 [weight=100000000]
    setterKeywordClauseR1C3 [label = <CIZ<br/>ALT <br/>fi ["@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterKeywordClauseR2C3 [label = <CIY<br/>N attributes<br/>fi ["@"]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterKeywordClauseR3C3 [label = <CJA<br/>END <br/>fi [""]<br/>fo ["mutating", "nonmutating", "set"]<br/>am []<br/>>]
    setterKeywordClauseR2C3 -> setterKeywordClauseR3C3 [weight=100000000]
    setterKeywordClauseR1C3 -> setterKeywordClauseR2C3 [weight=100000000]
    rank = same {setterKeywordClauseR1C1 -> setterKeywordClauseR1C3}
    setterKeywordClauseR0C1 -> setterKeywordClauseR1C1 [weight=100000000]
    rank = same {setterKeywordClauseR0C0 -> setterKeywordClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {setterKeywordClauseR0C1 -> setterKeywordClauseR0C2}
    rank = same {setterKeywordClauseR0C2 -> setterKeywordClauseR0C3}
    setterKeywordClauseR0C0 -> setterKeywordClauseR1C0 [weight=100000000]
    rank = same {setterKeywordClauseR1C0 -> setterKeywordClauseR1C1}
    setterKeywordClauseR0C3 -> setterKeywordClauseR1C3 [weight=100000000]
    setterKeywordClauseR1C0 -> setterKeywordClauseR2C0 [weight=100000000]
    rank = same {setterKeywordClauseR2C0 -> setterKeywordClauseR2C1}
    setterKeywordClauseR2C0 -> setterKeywordClauseR3C0 [weight=100000000]
    rank = same {setterKeywordClauseR3C0 -> setterKeywordClauseR3C1}
    setterKeywordClauseR3C0 -> setterKeywordClauseR4C0 [weight=100000000]
    rank = same {setterKeywordClauseR4C0 -> setterKeywordClauseR4C1}
    setterKeywordClauseR3C3 -> setterKeywordClauseR4C3 [weight=100000000]
    rank = same {setterKeywordClauseR4C2 -> setterKeywordClauseR4C3}
  }
  subgraph clusterlocalParameterName {
    node [shape = box]
    label = <localParameterName = identifier .>
    labeljust = l
    localParameterNameR0C0 [label = <CRH<br/>N localParameterName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    localParameterNameR0C1 [label = <CRE<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    localParameterNameR1C1 [label = <CRF<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [":"]<br/>am []<br/>>]
    localParameterNameR2C1 [label = <CRG<br/>END <br/>fi [""]<br/>fo [":"]<br/>am []<br/>>]
    localParameterNameR1C1 -> localParameterNameR2C1 [weight=100000000]
    localParameterNameR0C1 -> localParameterNameR1C1 [weight=100000000]
    rank = same {localParameterNameR0C0 -> localParameterNameR0C1}
    node [style = invis]
    edge [style = invis]
    localParameterNameR0C0 -> localParameterNameR1C0 [weight=100000000]
    rank = same {localParameterNameR1C0 -> localParameterNameR1C1}
    localParameterNameR1C0 -> localParameterNameR2C0 [weight=100000000]
    rank = same {localParameterNameR2C0 -> localParameterNameR2C1}
  }
  subgraph clustergenericArgumentClause {
    node [shape = box]
    label = <genericArgumentClause = "&lt;" genericArgumentList "&gt;" .>
    labeljust = l
    genericArgumentClauseR0C0 [label = <EQG<br/>N genericArgumentClause<br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    genericArgumentClauseR0C1 [label = <EQB<br/>ALT <br/>fi ["&lt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    genericArgumentClauseR1C1 [label = <EQC<br/>T "&lt;"<br/>fi ["&lt;"]<br/>fo ["(", "&gt;", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    genericArgumentClauseR2C1 [label = <EQD<br/>N genericArgumentList<br/>fi ["", "(", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>fo ["&gt;"]<br/>am []<br/>>]
    genericArgumentClauseR3C1 [label = <EQE<br/>T "&gt;"<br/>fi ["&gt;"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    genericArgumentClauseR4C1 [label = <EQF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "&amp;", "(", ")", ",", ".", "...", ":", ";", "=", "==", "&gt;", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    genericArgumentClauseR3C1 -> genericArgumentClauseR4C1 [weight=100000000]
    genericArgumentClauseR2C1 -> genericArgumentClauseR3C1 [weight=100000000]
    genericArgumentClauseR1C1 -> genericArgumentClauseR2C1 [weight=100000000]
    genericArgumentClauseR0C1 -> genericArgumentClauseR1C1 [weight=100000000]
    rank = same {genericArgumentClauseR0C0 -> genericArgumentClauseR0C1}
    node [style = invis]
    edge [style = invis]
    genericArgumentClauseR0C0 -> genericArgumentClauseR1C0 [weight=100000000]
    rank = same {genericArgumentClauseR1C0 -> genericArgumentClauseR1C1}
    genericArgumentClauseR1C0 -> genericArgumentClauseR2C0 [weight=100000000]
    rank = same {genericArgumentClauseR2C0 -> genericArgumentClauseR2C1}
    genericArgumentClauseR2C0 -> genericArgumentClauseR3C0 [weight=100000000]
    rank = same {genericArgumentClauseR3C0 -> genericArgumentClauseR3C1}
    genericArgumentClauseR3C0 -> genericArgumentClauseR4C0 [weight=100000000]
    rank = same {genericArgumentClauseR4C0 -> genericArgumentClauseR4C1}
  }
  subgraph clustermacroSignature {
    node [shape = box]
    label = <macroSignature = parameterClause [ macroFunctionSignatureResult ] .>
    labeljust = l
    macroSignatureR0C0 [label = <DVI<br/>N macroSignature<br/>fi ["("]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR0C1 [label = <DVB<br/>ALT <br/>fi ["("]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR1C1 [label = <DVC<br/>N parameterClause<br/>fi ["("]<br/>fo ["=", "&gt;", "where"]<br/>am []<br/>>]
    macroSignatureR2C1 [label = <DVG<br/>OPT <br/>fi ["", "&gt;"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR3C1 [label = <DVH<br/>END <br/>fi [""]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR2C1 -> macroSignatureR3C1 [weight=100000000]
    macroSignatureR2C2 [label = <DVE<br/>ALT <br/>fi ["&gt;"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR3C2 [label = <DVD<br/>N macroFunctionSignatureResult<br/>fi ["&gt;"]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR4C2 [label = <DVF<br/>END <br/>fi [""]<br/>fo ["=", "where"]<br/>am []<br/>>]
    macroSignatureR3C2 -> macroSignatureR4C2 [weight=100000000]
    macroSignatureR2C2 -> macroSignatureR3C2 [weight=100000000]
    rank = same {macroSignatureR2C1 -> macroSignatureR2C2}
    macroSignatureR1C1 -> macroSignatureR2C1 [weight=100000000]
    macroSignatureR0C1 -> macroSignatureR1C1 [weight=100000000]
    rank = same {macroSignatureR0C0 -> macroSignatureR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {macroSignatureR0C1 -> macroSignatureR0C2}
    macroSignatureR0C0 -> macroSignatureR1C0 [weight=100000000]
    rank = same {macroSignatureR1C0 -> macroSignatureR1C1}
    macroSignatureR0C2 -> macroSignatureR1C2 [weight=100000000]
    rank = same {macroSignatureR1C1 -> macroSignatureR1C2}
    macroSignatureR1C0 -> macroSignatureR2C0 [weight=100000000]
    rank = same {macroSignatureR2C0 -> macroSignatureR2C1}
    macroSignatureR1C2 -> macroSignatureR2C2 [weight=100000000]
    macroSignatureR2C0 -> macroSignatureR3C0 [weight=100000000]
    rank = same {macroSignatureR3C0 -> macroSignatureR3C1}
    macroSignatureR3C0 -> macroSignatureR4C0 [weight=100000000]
    macroSignatureR3C1 -> macroSignatureR4C1 [weight=100000000]
    rank = same {macroSignatureR4C0 -> macroSignatureR4C1}
    rank = same {macroSignatureR4C1 -> macroSignatureR4C2}
  }
  subgraph clusterfunctionName {
    node [shape = box]
    label = <functionName = identifier | Operator .>
    labeljust = l
    functionNameR0C0 [label = <CNN<br/>N functionName<br/>fi ["dotOperator", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "plainOperator", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR0C1 [label = <CNH<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR1C1 [label = <CNI<br/>N identifier<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR2C1 [label = <CNJ<br/>END <br/>fi [""]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR1C1 -> functionNameR2C1 [weight=100000000]
    functionNameR0C1 -> functionNameR1C1 [weight=100000000]
    functionNameR0C2 [label = <CNK<br/>ALT <br/>fi ["dotOperator", "plainOperator"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR1C2 [label = <CNL<br/>N Operator<br/>fi ["dotOperator", "plainOperator"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR2C2 [label = <CNM<br/>END <br/>fi [""]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    functionNameR1C2 -> functionNameR2C2 [weight=100000000]
    functionNameR0C2 -> functionNameR1C2 [weight=100000000]
    rank = same {functionNameR0C1 -> functionNameR0C2}
    rank = same {functionNameR0C0 -> functionNameR0C1}
    node [style = invis]
    edge [style = invis]
    functionNameR0C0 -> functionNameR1C0 [weight=100000000]
    rank = same {functionNameR1C0 -> functionNameR1C1}
    functionNameR1C0 -> functionNameR2C0 [weight=100000000]
    rank = same {functionNameR2C0 -> functionNameR2C1}
  }
  subgraph clusterprotocolMember {
    node [shape = box]
    label = <protocolMember = protocolMemberDeclaration | compilerControlStatement .>
    labeljust = l
    protocolMemberR0C0 [label = <DIR<br/>N protocolMember<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@"]<br/>>]
    protocolMemberR0C1 [label = <DIL<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberR1C1 [label = <DIM<br/>N protocolMemberDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolMemberR2C1 [label = <DIN<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberR1C1 -> protocolMemberR2C1 [weight=100000000]
    protocolMemberR0C1 -> protocolMemberR1C1 [weight=100000000]
    protocolMemberR0C2 [label = <DIO<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberR1C2 [label = <DIP<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberR2C2 [label = <DIQ<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolMemberR1C2 -> protocolMemberR2C2 [weight=100000000]
    protocolMemberR0C2 -> protocolMemberR1C2 [weight=100000000]
    rank = same {protocolMemberR0C1 -> protocolMemberR0C2}
    rank = same {protocolMemberR0C0 -> protocolMemberR0C1}
    node [style = invis]
    edge [style = invis]
    protocolMemberR0C0 -> protocolMemberR1C0 [weight=100000000]
    rank = same {protocolMemberR1C0 -> protocolMemberR1C1}
    protocolMemberR1C0 -> protocolMemberR2C0 [weight=100000000]
    rank = same {protocolMemberR2C0 -> protocolMemberR2C1}
  }
  subgraph clusterplaygroundLiteral {
    node [shape = box]
    label = <playgroundLiteral = "#colorLiteral" "(" "red" ":" expression "," "green" ":" expression "," "blue" ":" expression "," "alpha" ":" expression ")" | "#fileLiteral" "(" "resourceName" ":" expression ")" | "#imageLiteral" "(" "resourceName" ":" expression ")" .>
    labeljust = l
    playgroundLiteralR0C0 [label = <XZ<br/>N playgroundLiteral<br/>fi ["#colorLiteral", "#fileLiteral", "#imageLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR0C1 [label = <XF<br/>ALT <br/>fi ["#colorLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR1C1 [label = <XG<br/>T "#colorLiteral"<br/>fi ["#colorLiteral"]<br/>fo ["("]<br/>am []<br/>>]
    playgroundLiteralR2C1 [label = <XH<br/>T "("<br/>fi ["("]<br/>fo ["red"]<br/>am []<br/>>]
    playgroundLiteralR3C1 [label = <XI<br/>T "red"<br/>fi ["red"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR4C1 [label = <XJ<br/>T ":"<br/>fi [":"]<br/>fo [",", "try"]<br/>am []<br/>>]
    playgroundLiteralR5C1 [label = <XK<br/>N expression<br/>fi ["", "try"]<br/>fo [","]<br/>am []<br/>>]
    playgroundLiteralR6C1 [label = <XL<br/>T ","<br/>fi [","]<br/>fo ["green"]<br/>am []<br/>>]
    playgroundLiteralR7C1 [label = <XM<br/>T "green"<br/>fi ["green"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR8C1 [label = <XN<br/>T ":"<br/>fi [":"]<br/>fo [",", "try"]<br/>am []<br/>>]
    playgroundLiteralR9C1 [label = <XO<br/>N expression<br/>fi ["", "try"]<br/>fo [","]<br/>am []<br/>>]
    playgroundLiteralR10C1 [label = <XP<br/>T ","<br/>fi [","]<br/>fo ["blue"]<br/>am []<br/>>]
    playgroundLiteralR11C1 [label = <XQ<br/>T "blue"<br/>fi ["blue"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR12C1 [label = <XR<br/>T ":"<br/>fi [":"]<br/>fo [",", "try"]<br/>am []<br/>>]
    playgroundLiteralR13C1 [label = <XS<br/>N expression<br/>fi ["", "try"]<br/>fo [","]<br/>am []<br/>>]
    playgroundLiteralR14C1 [label = <XT<br/>T ","<br/>fi [","]<br/>fo ["alpha"]<br/>am []<br/>>]
    playgroundLiteralR15C1 [label = <XU<br/>T "alpha"<br/>fi ["alpha"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR16C1 [label = <XV<br/>T ":"<br/>fi [":"]<br/>fo [")", "try"]<br/>am []<br/>>]
    playgroundLiteralR17C1 [label = <XW<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    playgroundLiteralR18C1 [label = <XX<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR19C1 [label = <XY<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR18C1 -> playgroundLiteralR19C1 [weight=100000000]
    playgroundLiteralR17C1 -> playgroundLiteralR18C1 [weight=100000000]
    playgroundLiteralR16C1 -> playgroundLiteralR17C1 [weight=100000000]
    playgroundLiteralR15C1 -> playgroundLiteralR16C1 [weight=100000000]
    playgroundLiteralR14C1 -> playgroundLiteralR15C1 [weight=100000000]
    playgroundLiteralR13C1 -> playgroundLiteralR14C1 [weight=100000000]
    playgroundLiteralR12C1 -> playgroundLiteralR13C1 [weight=100000000]
    playgroundLiteralR11C1 -> playgroundLiteralR12C1 [weight=100000000]
    playgroundLiteralR10C1 -> playgroundLiteralR11C1 [weight=100000000]
    playgroundLiteralR9C1 -> playgroundLiteralR10C1 [weight=100000000]
    playgroundLiteralR8C1 -> playgroundLiteralR9C1 [weight=100000000]
    playgroundLiteralR7C1 -> playgroundLiteralR8C1 [weight=100000000]
    playgroundLiteralR6C1 -> playgroundLiteralR7C1 [weight=100000000]
    playgroundLiteralR5C1 -> playgroundLiteralR6C1 [weight=100000000]
    playgroundLiteralR4C1 -> playgroundLiteralR5C1 [weight=100000000]
    playgroundLiteralR3C1 -> playgroundLiteralR4C1 [weight=100000000]
    playgroundLiteralR2C1 -> playgroundLiteralR3C1 [weight=100000000]
    playgroundLiteralR1C1 -> playgroundLiteralR2C1 [weight=100000000]
    playgroundLiteralR0C1 -> playgroundLiteralR1C1 [weight=100000000]
    playgroundLiteralR0C2 [label = <YA<br/>ALT <br/>fi ["#fileLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR1C2 [label = <YB<br/>T "#fileLiteral"<br/>fi ["#fileLiteral"]<br/>fo ["("]<br/>am []<br/>>]
    playgroundLiteralR2C2 [label = <YC<br/>T "("<br/>fi ["("]<br/>fo ["resourceName"]<br/>am []<br/>>]
    playgroundLiteralR3C2 [label = <YD<br/>T "resourceName"<br/>fi ["resourceName"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR4C2 [label = <YE<br/>T ":"<br/>fi [":"]<br/>fo [")", "try"]<br/>am []<br/>>]
    playgroundLiteralR5C2 [label = <YF<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    playgroundLiteralR6C2 [label = <YG<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR7C2 [label = <YH<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR6C2 -> playgroundLiteralR7C2 [weight=100000000]
    playgroundLiteralR5C2 -> playgroundLiteralR6C2 [weight=100000000]
    playgroundLiteralR4C2 -> playgroundLiteralR5C2 [weight=100000000]
    playgroundLiteralR3C2 -> playgroundLiteralR4C2 [weight=100000000]
    playgroundLiteralR2C2 -> playgroundLiteralR3C2 [weight=100000000]
    playgroundLiteralR1C2 -> playgroundLiteralR2C2 [weight=100000000]
    playgroundLiteralR0C2 -> playgroundLiteralR1C2 [weight=100000000]
    playgroundLiteralR0C3 [label = <YI<br/>ALT <br/>fi ["#imageLiteral"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR1C3 [label = <YJ<br/>T "#imageLiteral"<br/>fi ["#imageLiteral"]<br/>fo ["("]<br/>am []<br/>>]
    playgroundLiteralR2C3 [label = <YK<br/>T "("<br/>fi ["("]<br/>fo ["resourceName"]<br/>am []<br/>>]
    playgroundLiteralR3C3 [label = <YL<br/>T "resourceName"<br/>fi ["resourceName"]<br/>fo [":"]<br/>am []<br/>>]
    playgroundLiteralR4C3 [label = <YM<br/>T ":"<br/>fi [":"]<br/>fo [")", "try"]<br/>am []<br/>>]
    playgroundLiteralR5C3 [label = <YN<br/>N expression<br/>fi ["", "try"]<br/>fo [")"]<br/>am []<br/>>]
    playgroundLiteralR6C3 [label = <YO<br/>T ")"<br/>fi [")"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR7C3 [label = <YP<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    playgroundLiteralR6C3 -> playgroundLiteralR7C3 [weight=100000000]
    playgroundLiteralR5C3 -> playgroundLiteralR6C3 [weight=100000000]
    playgroundLiteralR4C3 -> playgroundLiteralR5C3 [weight=100000000]
    playgroundLiteralR3C3 -> playgroundLiteralR4C3 [weight=100000000]
    playgroundLiteralR2C3 -> playgroundLiteralR3C3 [weight=100000000]
    playgroundLiteralR1C3 -> playgroundLiteralR2C3 [weight=100000000]
    playgroundLiteralR0C3 -> playgroundLiteralR1C3 [weight=100000000]
    rank = same {playgroundLiteralR0C2 -> playgroundLiteralR0C3}
    rank = same {playgroundLiteralR0C1 -> playgroundLiteralR0C2}
    rank = same {playgroundLiteralR0C0 -> playgroundLiteralR0C1}
    node [style = invis]
    edge [style = invis]
    playgroundLiteralR0C0 -> playgroundLiteralR1C0 [weight=100000000]
    rank = same {playgroundLiteralR1C0 -> playgroundLiteralR1C1}
    playgroundLiteralR1C0 -> playgroundLiteralR2C0 [weight=100000000]
    rank = same {playgroundLiteralR2C0 -> playgroundLiteralR2C1}
    playgroundLiteralR2C0 -> playgroundLiteralR3C0 [weight=100000000]
    rank = same {playgroundLiteralR3C0 -> playgroundLiteralR3C1}
    playgroundLiteralR3C0 -> playgroundLiteralR4C0 [weight=100000000]
    rank = same {playgroundLiteralR4C0 -> playgroundLiteralR4C1}
    playgroundLiteralR4C0 -> playgroundLiteralR5C0 [weight=100000000]
    rank = same {playgroundLiteralR5C0 -> playgroundLiteralR5C1}
    playgroundLiteralR5C0 -> playgroundLiteralR6C0 [weight=100000000]
    rank = same {playgroundLiteralR6C0 -> playgroundLiteralR6C1}
    playgroundLiteralR6C0 -> playgroundLiteralR7C0 [weight=100000000]
    rank = same {playgroundLiteralR7C0 -> playgroundLiteralR7C1}
    playgroundLiteralR7C0 -> playgroundLiteralR8C0 [weight=100000000]
    rank = same {playgroundLiteralR8C0 -> playgroundLiteralR8C1}
    playgroundLiteralR7C2 -> playgroundLiteralR8C2 [weight=100000000]
    rank = same {playgroundLiteralR8C1 -> playgroundLiteralR8C2}
    playgroundLiteralR7C3 -> playgroundLiteralR8C3 [weight=100000000]
    rank = same {playgroundLiteralR8C2 -> playgroundLiteralR8C3}
    playgroundLiteralR8C0 -> playgroundLiteralR9C0 [weight=100000000]
    rank = same {playgroundLiteralR9C0 -> playgroundLiteralR9C1}
    playgroundLiteralR8C2 -> playgroundLiteralR9C2 [weight=100000000]
    rank = same {playgroundLiteralR9C1 -> playgroundLiteralR9C2}
    playgroundLiteralR8C3 -> playgroundLiteralR9C3 [weight=100000000]
    rank = same {playgroundLiteralR9C2 -> playgroundLiteralR9C3}
    playgroundLiteralR9C0 -> playgroundLiteralR10C0 [weight=100000000]
    rank = same {playgroundLiteralR10C0 -> playgroundLiteralR10C1}
    playgroundLiteralR9C2 -> playgroundLiteralR10C2 [weight=100000000]
    rank = same {playgroundLiteralR10C1 -> playgroundLiteralR10C2}
    playgroundLiteralR9C3 -> playgroundLiteralR10C3 [weight=100000000]
    rank = same {playgroundLiteralR10C2 -> playgroundLiteralR10C3}
    playgroundLiteralR10C0 -> playgroundLiteralR11C0 [weight=100000000]
    rank = same {playgroundLiteralR11C0 -> playgroundLiteralR11C1}
    playgroundLiteralR10C2 -> playgroundLiteralR11C2 [weight=100000000]
    rank = same {playgroundLiteralR11C1 -> playgroundLiteralR11C2}
    playgroundLiteralR10C3 -> playgroundLiteralR11C3 [weight=100000000]
    rank = same {playgroundLiteralR11C2 -> playgroundLiteralR11C3}
    playgroundLiteralR11C0 -> playgroundLiteralR12C0 [weight=100000000]
    rank = same {playgroundLiteralR12C0 -> playgroundLiteralR12C1}
    playgroundLiteralR11C2 -> playgroundLiteralR12C2 [weight=100000000]
    rank = same {playgroundLiteralR12C1 -> playgroundLiteralR12C2}
    playgroundLiteralR11C3 -> playgroundLiteralR12C3 [weight=100000000]
    rank = same {playgroundLiteralR12C2 -> playgroundLiteralR12C3}
    playgroundLiteralR12C0 -> playgroundLiteralR13C0 [weight=100000000]
    rank = same {playgroundLiteralR13C0 -> playgroundLiteralR13C1}
    playgroundLiteralR12C2 -> playgroundLiteralR13C2 [weight=100000000]
    rank = same {playgroundLiteralR13C1 -> playgroundLiteralR13C2}
    playgroundLiteralR12C3 -> playgroundLiteralR13C3 [weight=100000000]
    rank = same {playgroundLiteralR13C2 -> playgroundLiteralR13C3}
    playgroundLiteralR13C0 -> playgroundLiteralR14C0 [weight=100000000]
    rank = same {playgroundLiteralR14C0 -> playgroundLiteralR14C1}
    playgroundLiteralR13C2 -> playgroundLiteralR14C2 [weight=100000000]
    rank = same {playgroundLiteralR14C1 -> playgroundLiteralR14C2}
    playgroundLiteralR13C3 -> playgroundLiteralR14C3 [weight=100000000]
    rank = same {playgroundLiteralR14C2 -> playgroundLiteralR14C3}
    playgroundLiteralR14C0 -> playgroundLiteralR15C0 [weight=100000000]
    rank = same {playgroundLiteralR15C0 -> playgroundLiteralR15C1}
    playgroundLiteralR14C2 -> playgroundLiteralR15C2 [weight=100000000]
    rank = same {playgroundLiteralR15C1 -> playgroundLiteralR15C2}
    playgroundLiteralR14C3 -> playgroundLiteralR15C3 [weight=100000000]
    rank = same {playgroundLiteralR15C2 -> playgroundLiteralR15C3}
    playgroundLiteralR15C0 -> playgroundLiteralR16C0 [weight=100000000]
    rank = same {playgroundLiteralR16C0 -> playgroundLiteralR16C1}
    playgroundLiteralR15C2 -> playgroundLiteralR16C2 [weight=100000000]
    rank = same {playgroundLiteralR16C1 -> playgroundLiteralR16C2}
    playgroundLiteralR15C3 -> playgroundLiteralR16C3 [weight=100000000]
    rank = same {playgroundLiteralR16C2 -> playgroundLiteralR16C3}
    playgroundLiteralR16C0 -> playgroundLiteralR17C0 [weight=100000000]
    rank = same {playgroundLiteralR17C0 -> playgroundLiteralR17C1}
    playgroundLiteralR16C2 -> playgroundLiteralR17C2 [weight=100000000]
    rank = same {playgroundLiteralR17C1 -> playgroundLiteralR17C2}
    playgroundLiteralR16C3 -> playgroundLiteralR17C3 [weight=100000000]
    rank = same {playgroundLiteralR17C2 -> playgroundLiteralR17C3}
    playgroundLiteralR17C0 -> playgroundLiteralR18C0 [weight=100000000]
    rank = same {playgroundLiteralR18C0 -> playgroundLiteralR18C1}
    playgroundLiteralR17C2 -> playgroundLiteralR18C2 [weight=100000000]
    rank = same {playgroundLiteralR18C1 -> playgroundLiteralR18C2}
    playgroundLiteralR17C3 -> playgroundLiteralR18C3 [weight=100000000]
    rank = same {playgroundLiteralR18C2 -> playgroundLiteralR18C3}
    playgroundLiteralR18C0 -> playgroundLiteralR19C0 [weight=100000000]
    rank = same {playgroundLiteralR19C0 -> playgroundLiteralR19C1}
    playgroundLiteralR18C2 -> playgroundLiteralR19C2 [weight=100000000]
    rank = same {playgroundLiteralR19C1 -> playgroundLiteralR19C2}
    playgroundLiteralR18C3 -> playgroundLiteralR19C3 [weight=100000000]
    rank = same {playgroundLiteralR19C2 -> playgroundLiteralR19C3}
  }
  subgraph clusterselfInitializerExpression {
    node [shape = box]
    label = <selfInitializerExpression = "self" "." "init" .>
    labeljust = l
    selfInitializerExpressionR0C0 [label = <ZV<br/>N selfInitializerExpression<br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfInitializerExpressionR0C1 [label = <ZQ<br/>ALT <br/>fi ["self"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfInitializerExpressionR1C1 [label = <ZR<br/>T "self"<br/>fi ["self"]<br/>fo ["."]<br/>am []<br/>>]
    selfInitializerExpressionR2C1 [label = <ZS<br/>T "."<br/>fi ["."]<br/>fo ["init"]<br/>am []<br/>>]
    selfInitializerExpressionR3C1 [label = <ZT<br/>T "init"<br/>fi ["init"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfInitializerExpressionR4C1 [label = <ZU<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    selfInitializerExpressionR3C1 -> selfInitializerExpressionR4C1 [weight=100000000]
    selfInitializerExpressionR2C1 -> selfInitializerExpressionR3C1 [weight=100000000]
    selfInitializerExpressionR1C1 -> selfInitializerExpressionR2C1 [weight=100000000]
    selfInitializerExpressionR0C1 -> selfInitializerExpressionR1C1 [weight=100000000]
    rank = same {selfInitializerExpressionR0C0 -> selfInitializerExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    selfInitializerExpressionR0C0 -> selfInitializerExpressionR1C0 [weight=100000000]
    rank = same {selfInitializerExpressionR1C0 -> selfInitializerExpressionR1C1}
    selfInitializerExpressionR1C0 -> selfInitializerExpressionR2C0 [weight=100000000]
    rank = same {selfInitializerExpressionR2C0 -> selfInitializerExpressionR2C1}
    selfInitializerExpressionR2C0 -> selfInitializerExpressionR3C0 [weight=100000000]
    rank = same {selfInitializerExpressionR3C0 -> selfInitializerExpressionR3C1}
    selfInitializerExpressionR3C0 -> selfInitializerExpressionR4C0 [weight=100000000]
    rank = same {selfInitializerExpressionR4C0 -> selfInitializerExpressionR4C1}
  }
  subgraph clusterdiagnosticStatement {
    node [shape = box]
    label = <diagnosticStatement = "#warning" "(" stringLiteral ")" | "#error" "(" stringLiteral ")" .>
    labeljust = l
    diagnosticStatementR0C0 [label = <BUZ<br/>N diagnosticStatement<br/>fi ["#error", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR0C1 [label = <BUN<br/>ALT <br/>fi ["#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR1C1 [label = <BUO<br/>T "#warning"<br/>fi ["#warning"]<br/>fo ["("]<br/>am []<br/>>]
    diagnosticStatementR2C1 [label = <BUP<br/>T "("<br/>fi ["("]<br/>fo ["interpolatedStringLiteral", "staticStringLiteral"]<br/>am []<br/>>]
    diagnosticStatementR3C1 [label = <BUQ<br/>N stringLiteral<br/>fi ["interpolatedStringLiteral", "staticStringLiteral"]<br/>fo [")"]<br/>am []<br/>>]
    diagnosticStatementR4C1 [label = <BUR<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR5C1 [label = <BUS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR4C1 -> diagnosticStatementR5C1 [weight=100000000]
    diagnosticStatementR3C1 -> diagnosticStatementR4C1 [weight=100000000]
    diagnosticStatementR2C1 -> diagnosticStatementR3C1 [weight=100000000]
    diagnosticStatementR1C1 -> diagnosticStatementR2C1 [weight=100000000]
    diagnosticStatementR0C1 -> diagnosticStatementR1C1 [weight=100000000]
    diagnosticStatementR0C2 [label = <BUT<br/>ALT <br/>fi ["#error"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR1C2 [label = <BUU<br/>T "#error"<br/>fi ["#error"]<br/>fo ["("]<br/>am []<br/>>]
    diagnosticStatementR2C2 [label = <BUV<br/>T "("<br/>fi ["("]<br/>fo ["interpolatedStringLiteral", "staticStringLiteral"]<br/>am []<br/>>]
    diagnosticStatementR3C2 [label = <BUW<br/>N stringLiteral<br/>fi ["interpolatedStringLiteral", "staticStringLiteral"]<br/>fo [")"]<br/>am []<br/>>]
    diagnosticStatementR4C2 [label = <BUX<br/>T ")"<br/>fi [")"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR5C2 [label = <BUY<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    diagnosticStatementR4C2 -> diagnosticStatementR5C2 [weight=100000000]
    diagnosticStatementR3C2 -> diagnosticStatementR4C2 [weight=100000000]
    diagnosticStatementR2C2 -> diagnosticStatementR3C2 [weight=100000000]
    diagnosticStatementR1C2 -> diagnosticStatementR2C2 [weight=100000000]
    diagnosticStatementR0C2 -> diagnosticStatementR1C2 [weight=100000000]
    rank = same {diagnosticStatementR0C1 -> diagnosticStatementR0C2}
    rank = same {diagnosticStatementR0C0 -> diagnosticStatementR0C1}
    node [style = invis]
    edge [style = invis]
    diagnosticStatementR0C0 -> diagnosticStatementR1C0 [weight=100000000]
    rank = same {diagnosticStatementR1C0 -> diagnosticStatementR1C1}
    diagnosticStatementR1C0 -> diagnosticStatementR2C0 [weight=100000000]
    rank = same {diagnosticStatementR2C0 -> diagnosticStatementR2C1}
    diagnosticStatementR2C0 -> diagnosticStatementR3C0 [weight=100000000]
    rank = same {diagnosticStatementR3C0 -> diagnosticStatementR3C1}
    diagnosticStatementR3C0 -> diagnosticStatementR4C0 [weight=100000000]
    rank = same {diagnosticStatementR4C0 -> diagnosticStatementR4C1}
    diagnosticStatementR4C0 -> diagnosticStatementR5C0 [weight=100000000]
    rank = same {diagnosticStatementR5C0 -> diagnosticStatementR5C1}
  }
  subgraph clusterprotocolAssociatedTypeDeclaration {
    node [shape = box]
    label = <protocolAssociatedTypeDeclaration = [ attributes ] [ accessLevelModifier ] "associatedtype" typealiasName [ typeInheritanceClause ] [ typealiasAssignment ] [ genericWhereClause ] .>
    labeljust = l
    protocolAssociatedTypeDeclarationR0C0 [label = <DMS<br/>N protocolAssociatedTypeDeclaration<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolAssociatedTypeDeclarationR0C1 [label = <DLU<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am ["@"]<br/>>]
    protocolAssociatedTypeDeclarationR1C1 [label = <DLY<br/>OPT <br/>fi ["", "@"]<br/>fo ["associatedtype", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR2C1 [label = <DMC<br/>OPT <br/>fi ["", "fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["associatedtype"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR3C1 [label = <DMD<br/>T "associatedtype"<br/>fi ["associatedtype"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR4C1 [label = <DME<br/>N typealiasName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", ":", "=", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR5C1 [label = <DMI<br/>OPT <br/>fi ["", ":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR6C1 [label = <DMM<br/>OPT <br/>fi ["", "="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR7C1 [label = <DMQ<br/>OPT <br/>fi ["", "where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR8C1 [label = <DMR<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR7C1 -> protocolAssociatedTypeDeclarationR8C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR7C2 [label = <DMO<br/>ALT <br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR8C2 [label = <DMN<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR9C2 [label = <DMP<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR8C2 -> protocolAssociatedTypeDeclarationR9C2 [weight=100000000]
    protocolAssociatedTypeDeclarationR7C2 -> protocolAssociatedTypeDeclarationR8C2 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR7C1 -> protocolAssociatedTypeDeclarationR7C2}
    protocolAssociatedTypeDeclarationR6C1 -> protocolAssociatedTypeDeclarationR7C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR6C3 [label = <DMK<br/>ALT <br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR7C3 [label = <DMJ<br/>N typealiasAssignment<br/>fi ["="]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR8C3 [label = <DML<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR7C3 -> protocolAssociatedTypeDeclarationR8C3 [weight=100000000]
    protocolAssociatedTypeDeclarationR6C3 -> protocolAssociatedTypeDeclarationR7C3 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR6C1 -> protocolAssociatedTypeDeclarationR6C3}
    protocolAssociatedTypeDeclarationR5C1 -> protocolAssociatedTypeDeclarationR6C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR5C4 [label = <DMG<br/>ALT <br/>fi [":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR6C4 [label = <DMF<br/>N typeInheritanceClause<br/>fi [":"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR7C4 [label = <DMH<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "=", "@", "where", "}"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR6C4 -> protocolAssociatedTypeDeclarationR7C4 [weight=100000000]
    protocolAssociatedTypeDeclarationR5C4 -> protocolAssociatedTypeDeclarationR6C4 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR5C1 -> protocolAssociatedTypeDeclarationR5C4}
    protocolAssociatedTypeDeclarationR4C1 -> protocolAssociatedTypeDeclarationR5C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR3C1 -> protocolAssociatedTypeDeclarationR4C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR2C1 -> protocolAssociatedTypeDeclarationR3C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR2C5 [label = <DMA<br/>ALT <br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["associatedtype"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR3C5 [label = <DLZ<br/>N accessLevelModifier<br/>fi ["fileprivate", "internal", "open", "package", "private", "public"]<br/>fo ["associatedtype"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR4C5 [label = <DMB<br/>END <br/>fi [""]<br/>fo ["associatedtype"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR3C5 -> protocolAssociatedTypeDeclarationR4C5 [weight=100000000]
    protocolAssociatedTypeDeclarationR2C5 -> protocolAssociatedTypeDeclarationR3C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR2C1 -> protocolAssociatedTypeDeclarationR2C5}
    protocolAssociatedTypeDeclarationR1C1 -> protocolAssociatedTypeDeclarationR2C1 [weight=100000000]
    protocolAssociatedTypeDeclarationR1C6 [label = <DLW<br/>ALT <br/>fi ["@"]<br/>fo ["associatedtype", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR2C6 [label = <DLV<br/>N attributes<br/>fi ["@"]<br/>fo ["associatedtype", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR3C6 [label = <DLX<br/>END <br/>fi [""]<br/>fo ["associatedtype", "fileprivate", "internal", "open", "package", "private", "public"]<br/>am []<br/>>]
    protocolAssociatedTypeDeclarationR2C6 -> protocolAssociatedTypeDeclarationR3C6 [weight=100000000]
    protocolAssociatedTypeDeclarationR1C6 -> protocolAssociatedTypeDeclarationR2C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR1C1 -> protocolAssociatedTypeDeclarationR1C6}
    protocolAssociatedTypeDeclarationR0C1 -> protocolAssociatedTypeDeclarationR1C1 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR0C0 -> protocolAssociatedTypeDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {protocolAssociatedTypeDeclarationR0C1 -> protocolAssociatedTypeDeclarationR0C2}
    rank = same {protocolAssociatedTypeDeclarationR0C2 -> protocolAssociatedTypeDeclarationR0C3}
    rank = same {protocolAssociatedTypeDeclarationR0C3 -> protocolAssociatedTypeDeclarationR0C4}
    rank = same {protocolAssociatedTypeDeclarationR0C4 -> protocolAssociatedTypeDeclarationR0C5}
    rank = same {protocolAssociatedTypeDeclarationR0C5 -> protocolAssociatedTypeDeclarationR0C6}
    protocolAssociatedTypeDeclarationR0C0 -> protocolAssociatedTypeDeclarationR1C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR1C0 -> protocolAssociatedTypeDeclarationR1C1}
    protocolAssociatedTypeDeclarationR0C6 -> protocolAssociatedTypeDeclarationR1C6 [weight=100000000]
    protocolAssociatedTypeDeclarationR1C0 -> protocolAssociatedTypeDeclarationR2C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR2C0 -> protocolAssociatedTypeDeclarationR2C1}
    protocolAssociatedTypeDeclarationR2C0 -> protocolAssociatedTypeDeclarationR3C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR3C0 -> protocolAssociatedTypeDeclarationR3C1}
    rank = same {protocolAssociatedTypeDeclarationR3C1 -> protocolAssociatedTypeDeclarationR3C2}
    rank = same {protocolAssociatedTypeDeclarationR3C2 -> protocolAssociatedTypeDeclarationR3C3}
    rank = same {protocolAssociatedTypeDeclarationR3C3 -> protocolAssociatedTypeDeclarationR3C4}
    rank = same {protocolAssociatedTypeDeclarationR3C4 -> protocolAssociatedTypeDeclarationR3C5}
    protocolAssociatedTypeDeclarationR3C0 -> protocolAssociatedTypeDeclarationR4C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR4C0 -> protocolAssociatedTypeDeclarationR4C1}
    protocolAssociatedTypeDeclarationR3C2 -> protocolAssociatedTypeDeclarationR4C2 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR4C1 -> protocolAssociatedTypeDeclarationR4C2}
    protocolAssociatedTypeDeclarationR3C3 -> protocolAssociatedTypeDeclarationR4C3 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR4C2 -> protocolAssociatedTypeDeclarationR4C3}
    protocolAssociatedTypeDeclarationR3C4 -> protocolAssociatedTypeDeclarationR4C4 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR4C3 -> protocolAssociatedTypeDeclarationR4C4}
    rank = same {protocolAssociatedTypeDeclarationR4C4 -> protocolAssociatedTypeDeclarationR4C5}
    protocolAssociatedTypeDeclarationR3C6 -> protocolAssociatedTypeDeclarationR4C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR4C5 -> protocolAssociatedTypeDeclarationR4C6}
    protocolAssociatedTypeDeclarationR4C0 -> protocolAssociatedTypeDeclarationR5C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR5C0 -> protocolAssociatedTypeDeclarationR5C1}
    protocolAssociatedTypeDeclarationR4C4 -> protocolAssociatedTypeDeclarationR5C4 [weight=100000000]
    protocolAssociatedTypeDeclarationR4C5 -> protocolAssociatedTypeDeclarationR5C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR5C4 -> protocolAssociatedTypeDeclarationR5C5}
    protocolAssociatedTypeDeclarationR4C6 -> protocolAssociatedTypeDeclarationR5C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR5C5 -> protocolAssociatedTypeDeclarationR5C6}
    protocolAssociatedTypeDeclarationR5C0 -> protocolAssociatedTypeDeclarationR6C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR6C0 -> protocolAssociatedTypeDeclarationR6C1}
    protocolAssociatedTypeDeclarationR5C5 -> protocolAssociatedTypeDeclarationR6C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR6C4 -> protocolAssociatedTypeDeclarationR6C5}
    protocolAssociatedTypeDeclarationR5C6 -> protocolAssociatedTypeDeclarationR6C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR6C5 -> protocolAssociatedTypeDeclarationR6C6}
    protocolAssociatedTypeDeclarationR6C0 -> protocolAssociatedTypeDeclarationR7C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR7C0 -> protocolAssociatedTypeDeclarationR7C1}
    protocolAssociatedTypeDeclarationR6C5 -> protocolAssociatedTypeDeclarationR7C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR7C4 -> protocolAssociatedTypeDeclarationR7C5}
    protocolAssociatedTypeDeclarationR6C6 -> protocolAssociatedTypeDeclarationR7C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR7C5 -> protocolAssociatedTypeDeclarationR7C6}
    protocolAssociatedTypeDeclarationR7C0 -> protocolAssociatedTypeDeclarationR8C0 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR8C0 -> protocolAssociatedTypeDeclarationR8C1}
    protocolAssociatedTypeDeclarationR7C4 -> protocolAssociatedTypeDeclarationR8C4 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR8C3 -> protocolAssociatedTypeDeclarationR8C4}
    protocolAssociatedTypeDeclarationR7C5 -> protocolAssociatedTypeDeclarationR8C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR8C4 -> protocolAssociatedTypeDeclarationR8C5}
    protocolAssociatedTypeDeclarationR7C6 -> protocolAssociatedTypeDeclarationR8C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR8C5 -> protocolAssociatedTypeDeclarationR8C6}
    protocolAssociatedTypeDeclarationR8C0 -> protocolAssociatedTypeDeclarationR9C0 [weight=100000000]
    protocolAssociatedTypeDeclarationR8C1 -> protocolAssociatedTypeDeclarationR9C1 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR9C0 -> protocolAssociatedTypeDeclarationR9C1}
    rank = same {protocolAssociatedTypeDeclarationR9C1 -> protocolAssociatedTypeDeclarationR9C2}
    protocolAssociatedTypeDeclarationR8C3 -> protocolAssociatedTypeDeclarationR9C3 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR9C2 -> protocolAssociatedTypeDeclarationR9C3}
    protocolAssociatedTypeDeclarationR8C4 -> protocolAssociatedTypeDeclarationR9C4 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR9C3 -> protocolAssociatedTypeDeclarationR9C4}
    protocolAssociatedTypeDeclarationR8C5 -> protocolAssociatedTypeDeclarationR9C5 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR9C4 -> protocolAssociatedTypeDeclarationR9C5}
    protocolAssociatedTypeDeclarationR8C6 -> protocolAssociatedTypeDeclarationR9C6 [weight=100000000]
    rank = same {protocolAssociatedTypeDeclarationR9C5 -> protocolAssociatedTypeDeclarationR9C6}
  }
  subgraph clusterinitializerDeclaration {
    node [shape = box]
    label = <initializerDeclaration = initializerHead [ genericParameterClause ] parameterClause [ "async" ] [ throwsClause ] [ genericWhereClause ] initializerBody | initializerHead [ genericParameterClause ] parameterClause [ "async" ] "rethrows" [ genericWhereClause ] initializerBody .>
    labeljust = l
    initializerDeclarationR0C0 [label = <DNO<br/>N initializerDeclaration<br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    initializerDeclarationR0C1 [label = <DMT<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    initializerDeclarationR1C1 [label = <DMU<br/>N initializerHead<br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerDeclarationR2C1 [label = <DMY<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C1 [label = <DMZ<br/>N parameterClause<br/>fi ["("]<br/>fo ["async", "throws", "where", "{"]<br/>am []<br/>>]
    initializerDeclarationR4C1 [label = <DND<br/>OPT <br/>fi ["", "async"]<br/>fo ["throws", "where", "{"]<br/>am []<br/>>]
    initializerDeclarationR5C1 [label = <DNH<br/>OPT <br/>fi ["", "throws"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    initializerDeclarationR6C1 [label = <DNL<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C1 [label = <DNM<br/>N initializerBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerDeclarationR8C1 [label = <DNN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerDeclarationR7C1 -> initializerDeclarationR8C1 [weight=100000000]
    initializerDeclarationR6C1 -> initializerDeclarationR7C1 [weight=100000000]
    initializerDeclarationR6C2 [label = <DNJ<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C2 [label = <DNI<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR8C2 [label = <DNK<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C2 -> initializerDeclarationR8C2 [weight=100000000]
    initializerDeclarationR6C2 -> initializerDeclarationR7C2 [weight=100000000]
    rank = same {initializerDeclarationR6C1 -> initializerDeclarationR6C2}
    initializerDeclarationR5C1 -> initializerDeclarationR6C1 [weight=100000000]
    initializerDeclarationR5C3 [label = <DNF<br/>ALT <br/>fi ["throws"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    initializerDeclarationR6C3 [label = <DNE<br/>N throwsClause<br/>fi ["throws"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    initializerDeclarationR7C3 [label = <DNG<br/>END <br/>fi [""]<br/>fo ["where", "{"]<br/>am []<br/>>]
    initializerDeclarationR6C3 -> initializerDeclarationR7C3 [weight=100000000]
    initializerDeclarationR5C3 -> initializerDeclarationR6C3 [weight=100000000]
    rank = same {initializerDeclarationR5C1 -> initializerDeclarationR5C3}
    initializerDeclarationR4C1 -> initializerDeclarationR5C1 [weight=100000000]
    initializerDeclarationR4C4 [label = <DNB<br/>ALT <br/>fi ["async"]<br/>fo ["throws", "where", "{"]<br/>am []<br/>>]
    initializerDeclarationR5C4 [label = <DNA<br/>T "async"<br/>fi ["async"]<br/>fo ["throws", "where", "{"]<br/>am []<br/>>]
    initializerDeclarationR6C4 [label = <DNC<br/>END <br/>fi [""]<br/>fo ["throws", "where", "{"]<br/>am []<br/>>]
    initializerDeclarationR5C4 -> initializerDeclarationR6C4 [weight=100000000]
    initializerDeclarationR4C4 -> initializerDeclarationR5C4 [weight=100000000]
    rank = same {initializerDeclarationR4C1 -> initializerDeclarationR4C4}
    initializerDeclarationR3C1 -> initializerDeclarationR4C1 [weight=100000000]
    initializerDeclarationR2C1 -> initializerDeclarationR3C1 [weight=100000000]
    initializerDeclarationR2C5 [label = <DMW<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C5 [label = <DMV<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR4C5 [label = <DMX<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C5 -> initializerDeclarationR4C5 [weight=100000000]
    initializerDeclarationR2C5 -> initializerDeclarationR3C5 [weight=100000000]
    rank = same {initializerDeclarationR2C1 -> initializerDeclarationR2C5}
    initializerDeclarationR1C1 -> initializerDeclarationR2C1 [weight=100000000]
    initializerDeclarationR0C1 -> initializerDeclarationR1C1 [weight=100000000]
    initializerDeclarationR0C6 [label = <DNP<br/>ALT <br/>fi ["", "@"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@"]<br/>>]
    initializerDeclarationR1C6 [label = <DNQ<br/>N initializerHead<br/>fi ["", "@"]<br/>fo ["(", "&lt;"]<br/>am []<br/>>]
    initializerDeclarationR2C6 [label = <DNU<br/>OPT <br/>fi ["", "&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C6 [label = <DNV<br/>N parameterClause<br/>fi ["("]<br/>fo ["async", "rethrows"]<br/>am []<br/>>]
    initializerDeclarationR4C6 [label = <DNZ<br/>OPT <br/>fi ["", "async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    initializerDeclarationR5C6 [label = <DOA<br/>T "rethrows"<br/>fi ["rethrows"]<br/>fo ["where", "{"]<br/>am []<br/>>]
    initializerDeclarationR6C6 [label = <DOE<br/>OPT <br/>fi ["", "where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C6 [label = <DOF<br/>N initializerBody<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerDeclarationR8C6 [label = <DOG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    initializerDeclarationR7C6 -> initializerDeclarationR8C6 [weight=100000000]
    initializerDeclarationR6C6 -> initializerDeclarationR7C6 [weight=100000000]
    initializerDeclarationR6C7 [label = <DOC<br/>ALT <br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C7 [label = <DOB<br/>N genericWhereClause<br/>fi ["where"]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR8C7 [label = <DOD<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    initializerDeclarationR7C7 -> initializerDeclarationR8C7 [weight=100000000]
    initializerDeclarationR6C7 -> initializerDeclarationR7C7 [weight=100000000]
    rank = same {initializerDeclarationR6C6 -> initializerDeclarationR6C7}
    initializerDeclarationR5C6 -> initializerDeclarationR6C6 [weight=100000000]
    initializerDeclarationR4C6 -> initializerDeclarationR5C6 [weight=100000000]
    initializerDeclarationR4C8 [label = <DNX<br/>ALT <br/>fi ["async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    initializerDeclarationR5C8 [label = <DNW<br/>T "async"<br/>fi ["async"]<br/>fo ["rethrows"]<br/>am []<br/>>]
    initializerDeclarationR6C8 [label = <DNY<br/>END <br/>fi [""]<br/>fo ["rethrows"]<br/>am []<br/>>]
    initializerDeclarationR5C8 -> initializerDeclarationR6C8 [weight=100000000]
    initializerDeclarationR4C8 -> initializerDeclarationR5C8 [weight=100000000]
    rank = same {initializerDeclarationR4C6 -> initializerDeclarationR4C8}
    initializerDeclarationR3C6 -> initializerDeclarationR4C6 [weight=100000000]
    initializerDeclarationR2C6 -> initializerDeclarationR3C6 [weight=100000000]
    initializerDeclarationR2C9 [label = <DNS<br/>ALT <br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C9 [label = <DNR<br/>N genericParameterClause<br/>fi ["&lt;"]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR4C9 [label = <DNT<br/>END <br/>fi [""]<br/>fo ["("]<br/>am []<br/>>]
    initializerDeclarationR3C9 -> initializerDeclarationR4C9 [weight=100000000]
    initializerDeclarationR2C9 -> initializerDeclarationR3C9 [weight=100000000]
    rank = same {initializerDeclarationR2C6 -> initializerDeclarationR2C9}
    initializerDeclarationR1C6 -> initializerDeclarationR2C6 [weight=100000000]
    initializerDeclarationR0C6 -> initializerDeclarationR1C6 [weight=100000000]
    rank = same {initializerDeclarationR0C1 -> initializerDeclarationR0C6}
    rank = same {initializerDeclarationR0C0 -> initializerDeclarationR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {initializerDeclarationR0C6 -> initializerDeclarationR0C7}
    rank = same {initializerDeclarationR0C7 -> initializerDeclarationR0C8}
    rank = same {initializerDeclarationR0C8 -> initializerDeclarationR0C9}
    initializerDeclarationR0C0 -> initializerDeclarationR1C0 [weight=100000000]
    rank = same {initializerDeclarationR1C0 -> initializerDeclarationR1C1}
    rank = same {initializerDeclarationR1C1 -> initializerDeclarationR1C2}
    rank = same {initializerDeclarationR1C2 -> initializerDeclarationR1C3}
    rank = same {initializerDeclarationR1C3 -> initializerDeclarationR1C4}
    rank = same {initializerDeclarationR1C4 -> initializerDeclarationR1C5}
    rank = same {initializerDeclarationR1C5 -> initializerDeclarationR1C6}
    initializerDeclarationR0C7 -> initializerDeclarationR1C7 [weight=100000000]
    rank = same {initializerDeclarationR1C6 -> initializerDeclarationR1C7}
    initializerDeclarationR0C8 -> initializerDeclarationR1C8 [weight=100000000]
    rank = same {initializerDeclarationR1C7 -> initializerDeclarationR1C8}
    initializerDeclarationR0C9 -> initializerDeclarationR1C9 [weight=100000000]
    rank = same {initializerDeclarationR1C8 -> initializerDeclarationR1C9}
    initializerDeclarationR1C0 -> initializerDeclarationR2C0 [weight=100000000]
    rank = same {initializerDeclarationR2C0 -> initializerDeclarationR2C1}
    initializerDeclarationR1C5 -> initializerDeclarationR2C5 [weight=100000000]
    initializerDeclarationR1C9 -> initializerDeclarationR2C9 [weight=100000000]
    initializerDeclarationR2C0 -> initializerDeclarationR3C0 [weight=100000000]
    rank = same {initializerDeclarationR3C0 -> initializerDeclarationR3C1}
    rank = same {initializerDeclarationR3C1 -> initializerDeclarationR3C2}
    rank = same {initializerDeclarationR3C2 -> initializerDeclarationR3C3}
    rank = same {initializerDeclarationR3C3 -> initializerDeclarationR3C4}
    rank = same {initializerDeclarationR3C4 -> initializerDeclarationR3C5}
    rank = same {initializerDeclarationR3C6 -> initializerDeclarationR3C7}
    rank = same {initializerDeclarationR3C7 -> initializerDeclarationR3C8}
    rank = same {initializerDeclarationR3C8 -> initializerDeclarationR3C9}
    initializerDeclarationR3C0 -> initializerDeclarationR4C0 [weight=100000000]
    rank = same {initializerDeclarationR4C0 -> initializerDeclarationR4C1}
    initializerDeclarationR3C4 -> initializerDeclarationR4C4 [weight=100000000]
    initializerDeclarationR3C8 -> initializerDeclarationR4C8 [weight=100000000]
    initializerDeclarationR4C0 -> initializerDeclarationR5C0 [weight=100000000]
    rank = same {initializerDeclarationR5C0 -> initializerDeclarationR5C1}
    initializerDeclarationR4C5 -> initializerDeclarationR5C5 [weight=100000000]
    rank = same {initializerDeclarationR5C4 -> initializerDeclarationR5C5}
    rank = same {initializerDeclarationR5C5 -> initializerDeclarationR5C6}
    rank = same {initializerDeclarationR5C6 -> initializerDeclarationR5C7}
    rank = same {initializerDeclarationR5C7 -> initializerDeclarationR5C8}
    initializerDeclarationR4C9 -> initializerDeclarationR5C9 [weight=100000000]
    rank = same {initializerDeclarationR5C8 -> initializerDeclarationR5C9}
    initializerDeclarationR5C0 -> initializerDeclarationR6C0 [weight=100000000]
    rank = same {initializerDeclarationR6C0 -> initializerDeclarationR6C1}
    initializerDeclarationR5C5 -> initializerDeclarationR6C5 [weight=100000000]
    rank = same {initializerDeclarationR6C4 -> initializerDeclarationR6C5}
    rank = same {initializerDeclarationR6C5 -> initializerDeclarationR6C6}
    initializerDeclarationR5C7 -> initializerDeclarationR6C7 [weight=100000000]
    initializerDeclarationR5C9 -> initializerDeclarationR6C9 [weight=100000000]
    rank = same {initializerDeclarationR6C8 -> initializerDeclarationR6C9}
    initializerDeclarationR6C0 -> initializerDeclarationR7C0 [weight=100000000]
    rank = same {initializerDeclarationR7C0 -> initializerDeclarationR7C1}
    initializerDeclarationR6C4 -> initializerDeclarationR7C4 [weight=100000000]
    rank = same {initializerDeclarationR7C3 -> initializerDeclarationR7C4}
    initializerDeclarationR6C5 -> initializerDeclarationR7C5 [weight=100000000]
    rank = same {initializerDeclarationR7C4 -> initializerDeclarationR7C5}
    rank = same {initializerDeclarationR7C5 -> initializerDeclarationR7C6}
    initializerDeclarationR6C8 -> initializerDeclarationR7C8 [weight=100000000]
    rank = same {initializerDeclarationR7C7 -> initializerDeclarationR7C8}
    initializerDeclarationR6C9 -> initializerDeclarationR7C9 [weight=100000000]
    rank = same {initializerDeclarationR7C8 -> initializerDeclarationR7C9}
    initializerDeclarationR7C0 -> initializerDeclarationR8C0 [weight=100000000]
    rank = same {initializerDeclarationR8C0 -> initializerDeclarationR8C1}
    initializerDeclarationR7C3 -> initializerDeclarationR8C3 [weight=100000000]
    rank = same {initializerDeclarationR8C2 -> initializerDeclarationR8C3}
    initializerDeclarationR7C4 -> initializerDeclarationR8C4 [weight=100000000]
    rank = same {initializerDeclarationR8C3 -> initializerDeclarationR8C4}
    initializerDeclarationR7C5 -> initializerDeclarationR8C5 [weight=100000000]
    rank = same {initializerDeclarationR8C4 -> initializerDeclarationR8C5}
    rank = same {initializerDeclarationR8C5 -> initializerDeclarationR8C6}
    initializerDeclarationR7C8 -> initializerDeclarationR8C8 [weight=100000000]
    rank = same {initializerDeclarationR8C7 -> initializerDeclarationR8C8}
    initializerDeclarationR7C9 -> initializerDeclarationR8C9 [weight=100000000]
    rank = same {initializerDeclarationR8C8 -> initializerDeclarationR8C9}
  }
  subgraph clusterstatement {
    node [shape = box]
    label = <statement = expression [ ";" ] | declaration [ ";" ] | loopStatement [ ";" ] | branchStatement [ ";" ] | labeledStatement [ ";" ] | controlTransferStatement [ ";" ] | deferStatement [ ";" ] | doStatement [ ";" ] | compilerControlStatement .>
    labeljust = l
    statementR0C0 [label = <AUX<br/>N statement<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>>]
    statementR0C1 [label = <AUQ<br/>ALT <br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    statementR1C1 [label = <AUR<br/>N expression<br/>fi ["", "try"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["try"]<br/>>]
    statementR2C1 [label = <AUV<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C1 [label = <AUW<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C1 -> statementR3C1 [weight=100000000]
    statementR2C2 [label = <AUT<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C2 [label = <AUS<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C2 [label = <AUU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C2 -> statementR4C2 [weight=100000000]
    statementR2C2 -> statementR3C2 [weight=100000000]
    rank = same {statementR2C1 -> statementR2C2}
    statementR1C1 -> statementR2C1 [weight=100000000]
    statementR0C1 -> statementR1C1 [weight=100000000]
    statementR0C3 [label = <AUY<br/>ALT <br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    statementR1C3 [label = <AUZ<br/>N declaration<br/>fi ["", "@", "infix", "postfix", "precedencegroup", "prefix"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["@", "infix", "postfix", "precedencegroup", "prefix"]<br/>>]
    statementR2C3 [label = <AVD<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C3 [label = <AVE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C3 -> statementR3C3 [weight=100000000]
    statementR2C4 [label = <AVB<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C4 [label = <AVA<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C4 [label = <AVC<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C4 -> statementR4C4 [weight=100000000]
    statementR2C4 -> statementR3C4 [weight=100000000]
    rank = same {statementR2C3 -> statementR2C4}
    statementR1C3 -> statementR2C3 [weight=100000000]
    statementR0C3 -> statementR1C3 [weight=100000000]
    statementR0C5 [label = <AVF<br/>ALT <br/>fi ["for", "repeat", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C5 [label = <AVG<br/>N loopStatement<br/>fi ["for", "repeat", "while"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C5 [label = <AVK<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C5 [label = <AVL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C5 -> statementR3C5 [weight=100000000]
    statementR2C6 [label = <AVI<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C6 [label = <AVH<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C6 [label = <AVJ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C6 -> statementR4C6 [weight=100000000]
    statementR2C6 -> statementR3C6 [weight=100000000]
    rank = same {statementR2C5 -> statementR2C6}
    statementR1C5 -> statementR2C5 [weight=100000000]
    statementR0C5 -> statementR1C5 [weight=100000000]
    statementR0C7 [label = <AVM<br/>ALT <br/>fi ["guard", "if", "switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C7 [label = <AVN<br/>N branchStatement<br/>fi ["guard", "if", "switch"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C7 [label = <AVR<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C7 [label = <AVS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C7 -> statementR3C7 [weight=100000000]
    statementR2C8 [label = <AVP<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C8 [label = <AVO<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C8 [label = <AVQ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C8 -> statementR4C8 [weight=100000000]
    statementR2C8 -> statementR3C8 [weight=100000000]
    rank = same {statementR2C7 -> statementR2C8}
    statementR1C7 -> statementR2C7 [weight=100000000]
    statementR0C7 -> statementR1C7 [weight=100000000]
    statementR0C9 [label = <AVT<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C9 [label = <AVU<br/>N labeledStatement<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C9 [label = <AVY<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C9 [label = <AVZ<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C9 -> statementR3C9 [weight=100000000]
    statementR2C10 [label = <AVW<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C10 [label = <AVV<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C10 [label = <AVX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C10 -> statementR4C10 [weight=100000000]
    statementR2C10 -> statementR3C10 [weight=100000000]
    rank = same {statementR2C9 -> statementR2C10}
    statementR1C9 -> statementR2C9 [weight=100000000]
    statementR0C9 -> statementR1C9 [weight=100000000]
    statementR0C11 [label = <AWA<br/>ALT <br/>fi ["break", "continue", "fallthrough", "return", "throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C11 [label = <AWB<br/>N controlTransferStatement<br/>fi ["break", "continue", "fallthrough", "return", "throw"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C11 [label = <AWF<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C11 [label = <AWG<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C11 -> statementR3C11 [weight=100000000]
    statementR2C12 [label = <AWD<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C12 [label = <AWC<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C12 [label = <AWE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C12 -> statementR4C12 [weight=100000000]
    statementR2C12 -> statementR3C12 [weight=100000000]
    rank = same {statementR2C11 -> statementR2C12}
    statementR1C11 -> statementR2C11 [weight=100000000]
    statementR0C11 -> statementR1C11 [weight=100000000]
    statementR0C13 [label = <AWH<br/>ALT <br/>fi ["defer"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C13 [label = <AWI<br/>N deferStatement<br/>fi ["defer"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C13 [label = <AWM<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C13 [label = <AWN<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C13 -> statementR3C13 [weight=100000000]
    statementR2C14 [label = <AWK<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C14 [label = <AWJ<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C14 [label = <AWL<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C14 -> statementR4C14 [weight=100000000]
    statementR2C14 -> statementR3C14 [weight=100000000]
    rank = same {statementR2C13 -> statementR2C14}
    statementR1C13 -> statementR2C13 [weight=100000000]
    statementR0C13 -> statementR1C13 [weight=100000000]
    statementR0C15 [label = <AWO<br/>ALT <br/>fi ["do"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C15 [label = <AWP<br/>N doStatement<br/>fi ["do"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C15 [label = <AWT<br/>OPT <br/>fi ["", ";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C15 [label = <AWU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C15 -> statementR3C15 [weight=100000000]
    statementR2C16 [label = <AWR<br/>ALT <br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C16 [label = <AWQ<br/>T ";"<br/>fi [";"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR4C16 [label = <AWS<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR3C16 -> statementR4C16 [weight=100000000]
    statementR2C16 -> statementR3C16 [weight=100000000]
    rank = same {statementR2C15 -> statementR2C16}
    statementR1C15 -> statementR2C15 [weight=100000000]
    statementR0C15 -> statementR1C15 [weight=100000000]
    statementR0C17 [label = <AWV<br/>ALT <br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C17 [label = <AWW<br/>N compilerControlStatement<br/>fi ["#error", "#if", "#sourceLocation", "#warning"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR2C17 [label = <AWX<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    statementR1C17 -> statementR2C17 [weight=100000000]
    statementR0C17 -> statementR1C17 [weight=100000000]
    rank = same {statementR0C15 -> statementR0C17}
    rank = same {statementR0C13 -> statementR0C15}
    rank = same {statementR0C11 -> statementR0C13}
    rank = same {statementR0C9 -> statementR0C11}
    rank = same {statementR0C7 -> statementR0C9}
    rank = same {statementR0C5 -> statementR0C7}
    rank = same {statementR0C3 -> statementR0C5}
    rank = same {statementR0C1 -> statementR0C3}
    rank = same {statementR0C0 -> statementR0C1}
    node [style = invis]
    edge [style = invis]
    statementR0C0 -> statementR1C0 [weight=100000000]
    rank = same {statementR1C0 -> statementR1C1}
    rank = same {statementR1C1 -> statementR1C2}
    rank = same {statementR1C2 -> statementR1C3}
    rank = same {statementR1C3 -> statementR1C4}
    rank = same {statementR1C4 -> statementR1C5}
    rank = same {statementR1C5 -> statementR1C6}
    rank = same {statementR1C6 -> statementR1C7}
    rank = same {statementR1C7 -> statementR1C8}
    rank = same {statementR1C8 -> statementR1C9}
    rank = same {statementR1C9 -> statementR1C10}
    rank = same {statementR1C10 -> statementR1C11}
    rank = same {statementR1C11 -> statementR1C12}
    rank = same {statementR1C12 -> statementR1C13}
    rank = same {statementR1C13 -> statementR1C14}
    rank = same {statementR1C14 -> statementR1C15}
    rank = same {statementR1C15 -> statementR1C16}
    rank = same {statementR1C16 -> statementR1C17}
    statementR1C0 -> statementR2C0 [weight=100000000]
    rank = same {statementR2C0 -> statementR2C1}
    statementR1C2 -> statementR2C2 [weight=100000000]
    statementR1C4 -> statementR2C4 [weight=100000000]
    statementR1C6 -> statementR2C6 [weight=100000000]
    statementR1C8 -> statementR2C8 [weight=100000000]
    statementR1C10 -> statementR2C10 [weight=100000000]
    statementR1C12 -> statementR2C12 [weight=100000000]
    statementR1C14 -> statementR2C14 [weight=100000000]
    statementR1C16 -> statementR2C16 [weight=100000000]
    statementR2C0 -> statementR3C0 [weight=100000000]
    rank = same {statementR3C0 -> statementR3C1}
    statementR2C17 -> statementR3C17 [weight=100000000]
    rank = same {statementR3C16 -> statementR3C17}
    statementR3C0 -> statementR4C0 [weight=100000000]
    statementR3C1 -> statementR4C1 [weight=100000000]
    rank = same {statementR4C0 -> statementR4C1}
    rank = same {statementR4C1 -> statementR4C2}
    statementR3C3 -> statementR4C3 [weight=100000000]
    rank = same {statementR4C2 -> statementR4C3}
    rank = same {statementR4C3 -> statementR4C4}
    statementR3C5 -> statementR4C5 [weight=100000000]
    rank = same {statementR4C4 -> statementR4C5}
    rank = same {statementR4C5 -> statementR4C6}
    statementR3C7 -> statementR4C7 [weight=100000000]
    rank = same {statementR4C6 -> statementR4C7}
    rank = same {statementR4C7 -> statementR4C8}
    statementR3C9 -> statementR4C9 [weight=100000000]
    rank = same {statementR4C8 -> statementR4C9}
    rank = same {statementR4C9 -> statementR4C10}
    statementR3C11 -> statementR4C11 [weight=100000000]
    rank = same {statementR4C10 -> statementR4C11}
    rank = same {statementR4C11 -> statementR4C12}
    statementR3C13 -> statementR4C13 [weight=100000000]
    rank = same {statementR4C12 -> statementR4C13}
    rank = same {statementR4C13 -> statementR4C14}
    statementR3C15 -> statementR4C15 [weight=100000000]
    rank = same {statementR4C14 -> statementR4C15}
    rank = same {statementR4C15 -> statementR4C16}
    statementR3C17 -> statementR4C17 [weight=100000000]
    rank = same {statementR4C16 -> statementR4C17}
  }
  subgraph clusterprecedenceGroupNames {
    node [shape = box]
    label = <precedenceGroupNames = precedenceGroupName | precedenceGroupName "," precedenceGroupNames .>
    labeljust = l
    precedenceGroupNamesR0C0 [label = <DZW<br/>N precedenceGroupNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    precedenceGroupNamesR0C1 [label = <DZO<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR1C1 [label = <DZP<br/>N precedenceGroupName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR2C1 [label = <DZQ<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR1C1 -> precedenceGroupNamesR2C1 [weight=100000000]
    precedenceGroupNamesR0C1 -> precedenceGroupNamesR1C1 [weight=100000000]
    precedenceGroupNamesR0C2 [label = <DZR<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR1C2 [label = <DZS<br/>N precedenceGroupName<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo [","]<br/>am []<br/>>]
    precedenceGroupNamesR2C2 [label = <DZT<br/>T ","<br/>fi [","]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    precedenceGroupNamesR3C2 [label = <DZU<br/>N precedenceGroupNames<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR4C2 [label = <DZV<br/>END <br/>fi [""]<br/>fo ["assignment", "associativity", "higherThan", "lowerThan", "}"]<br/>am []<br/>>]
    precedenceGroupNamesR3C2 -> precedenceGroupNamesR4C2 [weight=100000000]
    precedenceGroupNamesR2C2 -> precedenceGroupNamesR3C2 [weight=100000000]
    precedenceGroupNamesR1C2 -> precedenceGroupNamesR2C2 [weight=100000000]
    precedenceGroupNamesR0C2 -> precedenceGroupNamesR1C2 [weight=100000000]
    rank = same {precedenceGroupNamesR0C1 -> precedenceGroupNamesR0C2}
    rank = same {precedenceGroupNamesR0C0 -> precedenceGroupNamesR0C1}
    node [style = invis]
    edge [style = invis]
    precedenceGroupNamesR0C0 -> precedenceGroupNamesR1C0 [weight=100000000]
    rank = same {precedenceGroupNamesR1C0 -> precedenceGroupNamesR1C1}
    precedenceGroupNamesR1C0 -> precedenceGroupNamesR2C0 [weight=100000000]
    rank = same {precedenceGroupNamesR2C0 -> precedenceGroupNamesR2C1}
    precedenceGroupNamesR2C0 -> precedenceGroupNamesR3C0 [weight=100000000]
    precedenceGroupNamesR2C1 -> precedenceGroupNamesR3C1 [weight=100000000]
    rank = same {precedenceGroupNamesR3C0 -> precedenceGroupNamesR3C1}
    rank = same {precedenceGroupNamesR3C1 -> precedenceGroupNamesR3C2}
    precedenceGroupNamesR3C0 -> precedenceGroupNamesR4C0 [weight=100000000]
    precedenceGroupNamesR3C1 -> precedenceGroupNamesR4C1 [weight=100000000]
    rank = same {precedenceGroupNamesR4C0 -> precedenceGroupNamesR4C1}
    rank = same {precedenceGroupNamesR4C1 -> precedenceGroupNamesR4C2}
  }
  subgraph clusterparameterModifier {
    node [shape = box]
    label = <parameterModifier = "inout" | "borrowing" | "consuming" .>
    labeljust = l
    parameterModifierR0C0 [label = <CSE<br/>N parameterModifier<br/>fi ["borrowing", "consuming", "inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR0C1 [label = <CRV<br/>ALT <br/>fi ["inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C1 [label = <CRW<br/>T "inout"<br/>fi ["inout"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR2C1 [label = <CRX<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C1 -> parameterModifierR2C1 [weight=100000000]
    parameterModifierR0C1 -> parameterModifierR1C1 [weight=100000000]
    parameterModifierR0C2 [label = <CRY<br/>ALT <br/>fi ["borrowing"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C2 [label = <CRZ<br/>T "borrowing"<br/>fi ["borrowing"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR2C2 [label = <CSA<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C2 -> parameterModifierR2C2 [weight=100000000]
    parameterModifierR0C2 -> parameterModifierR1C2 [weight=100000000]
    parameterModifierR0C3 [label = <CSB<br/>ALT <br/>fi ["consuming"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C3 [label = <CSC<br/>T "consuming"<br/>fi ["consuming"]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR2C3 [label = <CSD<br/>END <br/>fi [""]<br/>fo ["(", ")", ",", "...", "=", "@", "Any", "Self", "[", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection", "some"]<br/>am []<br/>>]
    parameterModifierR1C3 -> parameterModifierR2C3 [weight=100000000]
    parameterModifierR0C3 -> parameterModifierR1C3 [weight=100000000]
    rank = same {parameterModifierR0C2 -> parameterModifierR0C3}
    rank = same {parameterModifierR0C1 -> parameterModifierR0C2}
    rank = same {parameterModifierR0C0 -> parameterModifierR0C1}
    node [style = invis]
    edge [style = invis]
    parameterModifierR0C0 -> parameterModifierR1C0 [weight=100000000]
    rank = same {parameterModifierR1C0 -> parameterModifierR1C1}
    parameterModifierR1C0 -> parameterModifierR2C0 [weight=100000000]
    rank = same {parameterModifierR2C0 -> parameterModifierR2C1}
  }
  subgraph clusterswitchExpression {
    node [shape = box]
    label = <switchExpression = "switch" expression "{" switchExpressionCases "}" .>
    labeljust = l
    switchExpressionR0C0 [label = <ACH<br/>N switchExpression<br/>fi ["switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    switchExpressionR0C1 [label = <ACA<br/>ALT <br/>fi ["switch"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    switchExpressionR1C1 [label = <ACB<br/>T "switch"<br/>fi ["switch"]<br/>fo ["try", "{"]<br/>am []<br/>>]
    switchExpressionR2C1 [label = <ACC<br/>N expression<br/>fi ["", "try"]<br/>fo ["{"]<br/>am []<br/>>]
    switchExpressionR3C1 [label = <ACD<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    switchExpressionR4C1 [label = <ACE<br/>N switchExpressionCases<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    switchExpressionR5C1 [label = <ACF<br/>T "}"<br/>fi ["}"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    switchExpressionR6C1 [label = <ACG<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    switchExpressionR5C1 -> switchExpressionR6C1 [weight=100000000]
    switchExpressionR4C1 -> switchExpressionR5C1 [weight=100000000]
    switchExpressionR3C1 -> switchExpressionR4C1 [weight=100000000]
    switchExpressionR2C1 -> switchExpressionR3C1 [weight=100000000]
    switchExpressionR1C1 -> switchExpressionR2C1 [weight=100000000]
    switchExpressionR0C1 -> switchExpressionR1C1 [weight=100000000]
    rank = same {switchExpressionR0C0 -> switchExpressionR0C1}
    node [style = invis]
    edge [style = invis]
    switchExpressionR0C0 -> switchExpressionR1C0 [weight=100000000]
    rank = same {switchExpressionR1C0 -> switchExpressionR1C1}
    switchExpressionR1C0 -> switchExpressionR2C0 [weight=100000000]
    rank = same {switchExpressionR2C0 -> switchExpressionR2C1}
    switchExpressionR2C0 -> switchExpressionR3C0 [weight=100000000]
    rank = same {switchExpressionR3C0 -> switchExpressionR3C1}
    switchExpressionR3C0 -> switchExpressionR4C0 [weight=100000000]
    rank = same {switchExpressionR4C0 -> switchExpressionR4C1}
    switchExpressionR4C0 -> switchExpressionR5C0 [weight=100000000]
    rank = same {switchExpressionR5C0 -> switchExpressionR5C1}
    switchExpressionR5C0 -> switchExpressionR6C0 [weight=100000000]
    rank = same {switchExpressionR6C0 -> switchExpressionR6C1}
  }
  subgraph clusterelseifDirectiveClause {
    node [shape = box]
    label = <elseifDirectiveClause = elseifDirective compilationCondition [ statements ] .>
    labeljust = l
    elseifDirectiveClauseR0C0 [label = <BNI<br/>N elseifDirectiveClause<br/>fi ["#elseif"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR0C1 [label = <BNA<br/>ALT <br/>fi ["#elseif"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR1C1 [label = <BNB<br/>N elseifDirective<br/>fi ["#elseif"]<br/>fo ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>am []<br/>>]
    elseifDirectiveClauseR2C1 [label = <BNC<br/>N compilationCondition<br/>fi ["!", "(", "arch", "canImport", "compiler", "escapedIdentifier", "false", "implicitParameterName", "os", "plainIdentifier", "propertyWrapperProjection", "swift", "targetEnvironment", "true"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>am []<br/>>]
    elseifDirectiveClauseR3C1 [label = <BNG<br/>OPT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR4C1 [label = <BNH<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR3C1 -> elseifDirectiveClauseR4C1 [weight=100000000]
    elseifDirectiveClauseR3C2 [label = <BNE<br/>ALT <br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR4C2 [label = <BND<br/>N statements<br/>fi ["", "#error", "#if", "#sourceLocation", "#warning", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while"]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR5C2 [label = <BNF<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif"]<br/>am []<br/>>]
    elseifDirectiveClauseR4C2 -> elseifDirectiveClauseR5C2 [weight=100000000]
    elseifDirectiveClauseR3C2 -> elseifDirectiveClauseR4C2 [weight=100000000]
    rank = same {elseifDirectiveClauseR3C1 -> elseifDirectiveClauseR3C2}
    elseifDirectiveClauseR2C1 -> elseifDirectiveClauseR3C1 [weight=100000000]
    elseifDirectiveClauseR1C1 -> elseifDirectiveClauseR2C1 [weight=100000000]
    elseifDirectiveClauseR0C1 -> elseifDirectiveClauseR1C1 [weight=100000000]
    rank = same {elseifDirectiveClauseR0C0 -> elseifDirectiveClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {elseifDirectiveClauseR0C1 -> elseifDirectiveClauseR0C2}
    elseifDirectiveClauseR0C0 -> elseifDirectiveClauseR1C0 [weight=100000000]
    rank = same {elseifDirectiveClauseR1C0 -> elseifDirectiveClauseR1C1}
    elseifDirectiveClauseR0C2 -> elseifDirectiveClauseR1C2 [weight=100000000]
    rank = same {elseifDirectiveClauseR1C1 -> elseifDirectiveClauseR1C2}
    elseifDirectiveClauseR1C0 -> elseifDirectiveClauseR2C0 [weight=100000000]
    rank = same {elseifDirectiveClauseR2C0 -> elseifDirectiveClauseR2C1}
    elseifDirectiveClauseR1C2 -> elseifDirectiveClauseR2C2 [weight=100000000]
    rank = same {elseifDirectiveClauseR2C1 -> elseifDirectiveClauseR2C2}
    elseifDirectiveClauseR2C0 -> elseifDirectiveClauseR3C0 [weight=100000000]
    rank = same {elseifDirectiveClauseR3C0 -> elseifDirectiveClauseR3C1}
    elseifDirectiveClauseR2C2 -> elseifDirectiveClauseR3C2 [weight=100000000]
    elseifDirectiveClauseR3C0 -> elseifDirectiveClauseR4C0 [weight=100000000]
    rank = same {elseifDirectiveClauseR4C0 -> elseifDirectiveClauseR4C1}
    elseifDirectiveClauseR4C0 -> elseifDirectiveClauseR5C0 [weight=100000000]
    elseifDirectiveClauseR4C1 -> elseifDirectiveClauseR5C1 [weight=100000000]
    rank = same {elseifDirectiveClauseR5C0 -> elseifDirectiveClauseR5C1}
    rank = same {elseifDirectiveClauseR5C1 -> elseifDirectiveClauseR5C2}
  }
  subgraph clustertrailingClosures {
    node [shape = box]
    label = <trailingClosures = closureExpression [ labeledTrailingClosures ] .>
    labeljust = l
    trailingClosuresR0C0 [label = <ARC<br/>N trailingClosures<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR0C1 [label = <AQV<br/>ALT <br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR1C1 [label = <AQW<br/>N closureExpression<br/>fi ["{"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR2C1 [label = <ARA<br/>OPT <br/>fi ["", "escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>>]
    trailingClosuresR3C1 [label = <ARB<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR2C1 -> trailingClosuresR3C1 [weight=100000000]
    trailingClosuresR2C2 [label = <AQY<br/>ALT <br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR3C2 [label = <AQX<br/>N labeledTrailingClosures<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR4C2 [label = <AQZ<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    trailingClosuresR3C2 -> trailingClosuresR4C2 [weight=100000000]
    trailingClosuresR2C2 -> trailingClosuresR3C2 [weight=100000000]
    rank = same {trailingClosuresR2C1 -> trailingClosuresR2C2}
    trailingClosuresR1C1 -> trailingClosuresR2C1 [weight=100000000]
    trailingClosuresR0C1 -> trailingClosuresR1C1 [weight=100000000]
    rank = same {trailingClosuresR0C0 -> trailingClosuresR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {trailingClosuresR0C1 -> trailingClosuresR0C2}
    trailingClosuresR0C0 -> trailingClosuresR1C0 [weight=100000000]
    rank = same {trailingClosuresR1C0 -> trailingClosuresR1C1}
    trailingClosuresR0C2 -> trailingClosuresR1C2 [weight=100000000]
    rank = same {trailingClosuresR1C1 -> trailingClosuresR1C2}
    trailingClosuresR1C0 -> trailingClosuresR2C0 [weight=100000000]
    rank = same {trailingClosuresR2C0 -> trailingClosuresR2C1}
    trailingClosuresR1C2 -> trailingClosuresR2C2 [weight=100000000]
    trailingClosuresR2C0 -> trailingClosuresR3C0 [weight=100000000]
    rank = same {trailingClosuresR3C0 -> trailingClosuresR3C1}
    trailingClosuresR3C0 -> trailingClosuresR4C0 [weight=100000000]
    trailingClosuresR3C1 -> trailingClosuresR4C1 [weight=100000000]
    rank = same {trailingClosuresR4C0 -> trailingClosuresR4C1}
    rank = same {trailingClosuresR4C1 -> trailingClosuresR4C2}
  }
  subgraph clusterendifDirective {
    node [shape = box]
    label = <endifDirective = "#endif" .>
    labeljust = l
    endifDirectiveR0C0 [label = <BOG<br/>N endifDirective<br/>fi ["#endif"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    endifDirectiveR0C1 [label = <BOD<br/>ALT <br/>fi ["#endif"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    endifDirectiveR1C1 [label = <BOE<br/>T "#endif"<br/>fi ["#endif"]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    endifDirectiveR2C1 [label = <BOF<br/>END <br/>fi [""]<br/>fo ["!", "#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", "(", ")", ",", ".", ":", ";", "=", "?", "@", "[", "]", "as", "break", "continue", "defer", "do", "dotOperator", "else", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "in", "infix", "is", "plainIdentifier", "plainOperator", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "where", "while", "{", "}"]<br/>am []<br/>>]
    endifDirectiveR1C1 -> endifDirectiveR2C1 [weight=100000000]
    endifDirectiveR0C1 -> endifDirectiveR1C1 [weight=100000000]
    rank = same {endifDirectiveR0C0 -> endifDirectiveR0C1}
    node [style = invis]
    edge [style = invis]
    endifDirectiveR0C0 -> endifDirectiveR1C0 [weight=100000000]
    rank = same {endifDirectiveR1C0 -> endifDirectiveR1C1}
    endifDirectiveR1C0 -> endifDirectiveR2C0 [weight=100000000]
    rank = same {endifDirectiveR2C0 -> endifDirectiveR2C1}
  }
  subgraph clustergetterSetterBlock {
    node [shape = box]
    label = <getterSetterBlock = codeBlock | "{" getterClause [ setterClause ] "}" | "{" setterClause getterClause "}" .>
    labeljust = l
    getterSetterBlockR0C0 [label = <CFV<br/>N getterSetterBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am ["{"]<br/>>]
    getterSetterBlockR0C1 [label = <CFS<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR1C1 [label = <CFT<br/>N codeBlock<br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR2C1 [label = <CFU<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR1C1 -> getterSetterBlockR2C1 [weight=100000000]
    getterSetterBlockR0C1 -> getterSetterBlockR1C1 [weight=100000000]
    getterSetterBlockR0C2 [label = <CFW<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR1C2 [label = <CFX<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterSetterBlockR2C2 [label = <CFY<br/>N getterClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterSetterBlockR3C2 [label = <CGC<br/>OPT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterBlockR4C2 [label = <CGD<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR5C2 [label = <CGE<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR4C2 -> getterSetterBlockR5C2 [weight=100000000]
    getterSetterBlockR3C2 -> getterSetterBlockR4C2 [weight=100000000]
    getterSetterBlockR3C3 [label = <CGA<br/>ALT <br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterBlockR4C3 [label = <CFZ<br/>N setterClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterBlockR5C3 [label = <CGB<br/>END <br/>fi [""]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterBlockR4C3 -> getterSetterBlockR5C3 [weight=100000000]
    getterSetterBlockR3C3 -> getterSetterBlockR4C3 [weight=100000000]
    rank = same {getterSetterBlockR3C2 -> getterSetterBlockR3C3}
    getterSetterBlockR2C2 -> getterSetterBlockR3C2 [weight=100000000]
    getterSetterBlockR1C2 -> getterSetterBlockR2C2 [weight=100000000]
    getterSetterBlockR0C2 -> getterSetterBlockR1C2 [weight=100000000]
    getterSetterBlockR0C4 [label = <CGF<br/>ALT <br/>fi ["{"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR1C4 [label = <CGG<br/>T "{"<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    getterSetterBlockR2C4 [label = <CGH<br/>N setterClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    getterSetterBlockR3C4 [label = <CGI<br/>N getterClause<br/>fi ["", "@"]<br/>fo ["}"]<br/>am []<br/>>]
    getterSetterBlockR4C4 [label = <CGJ<br/>T "}"<br/>fi ["}"]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR5C4 [label = <CGK<br/>END <br/>fi [""]<br/>fo ["#else", "#elseif", "#endif", "#error", "#if", "#sourceLocation", "#warning", "$", ";", "@", "break", "continue", "defer", "do", "escapedIdentifier", "fallthrough", "for", "guard", "if", "implicitParameterName", "infix", "plainIdentifier", "postfix", "precedencegroup", "prefix", "propertyWrapperProjection", "repeat", "return", "switch", "throw", "try", "while", "}"]<br/>am []<br/>>]
    getterSetterBlockR4C4 -> getterSetterBlockR5C4 [weight=100000000]
    getterSetterBlockR3C4 -> getterSetterBlockR4C4 [weight=100000000]
    getterSetterBlockR2C4 -> getterSetterBlockR3C4 [weight=100000000]
    getterSetterBlockR1C4 -> getterSetterBlockR2C4 [weight=100000000]
    getterSetterBlockR0C4 -> getterSetterBlockR1C4 [weight=100000000]
    rank = same {getterSetterBlockR0C2 -> getterSetterBlockR0C4}
    rank = same {getterSetterBlockR0C1 -> getterSetterBlockR0C2}
    rank = same {getterSetterBlockR0C0 -> getterSetterBlockR0C1}
    node [style = invis]
    edge [style = invis]
    getterSetterBlockR0C0 -> getterSetterBlockR1C0 [weight=100000000]
    rank = same {getterSetterBlockR1C0 -> getterSetterBlockR1C1}
    rank = same {getterSetterBlockR1C2 -> getterSetterBlockR1C3}
    rank = same {getterSetterBlockR1C3 -> getterSetterBlockR1C4}
    getterSetterBlockR1C0 -> getterSetterBlockR2C0 [weight=100000000]
    rank = same {getterSetterBlockR2C0 -> getterSetterBlockR2C1}
    getterSetterBlockR1C3 -> getterSetterBlockR2C3 [weight=100000000]
    rank = same {getterSetterBlockR2C2 -> getterSetterBlockR2C3}
    rank = same {getterSetterBlockR2C3 -> getterSetterBlockR2C4}
    getterSetterBlockR2C0 -> getterSetterBlockR3C0 [weight=100000000]
    getterSetterBlockR2C1 -> getterSetterBlockR3C1 [weight=100000000]
    rank = same {getterSetterBlockR3C0 -> getterSetterBlockR3C1}
    rank = same {getterSetterBlockR3C1 -> getterSetterBlockR3C2}
    getterSetterBlockR2C3 -> getterSetterBlockR3C3 [weight=100000000]
    getterSetterBlockR3C0 -> getterSetterBlockR4C0 [weight=100000000]
    getterSetterBlockR3C1 -> getterSetterBlockR4C1 [weight=100000000]
    rank = same {getterSetterBlockR4C0 -> getterSetterBlockR4C1}
    rank = same {getterSetterBlockR4C1 -> getterSetterBlockR4C2}
    getterSetterBlockR4C0 -> getterSetterBlockR5C0 [weight=100000000]
    getterSetterBlockR4C1 -> getterSetterBlockR5C1 [weight=100000000]
    rank = same {getterSetterBlockR5C0 -> getterSetterBlockR5C1}
    rank = same {getterSetterBlockR5C1 -> getterSetterBlockR5C2}
  }
  subgraph clusterdidSetClause {
    node [shape = box]
    label = <didSetClause = [ attributes ] "didSet" [ setterName ] codeBlock .>
    labeljust = l
    didSetClauseR0C0 [label = <CLB<br/>N didSetClause<br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    didSetClauseR0C1 [label = <CKP<br/>ALT <br/>fi ["", "@"]<br/>fo ["@", "}"]<br/>am ["@"]<br/>>]
    didSetClauseR1C1 [label = <CKT<br/>OPT <br/>fi ["", "@"]<br/>fo ["didSet"]<br/>am []<br/>>]
    didSetClauseR2C1 [label = <CKU<br/>T "didSet"<br/>fi ["didSet"]<br/>fo ["(", "{"]<br/>am []<br/>>]
    didSetClauseR3C1 [label = <CKY<br/>OPT <br/>fi ["", "("]<br/>fo ["{"]<br/>am []<br/>>]
    didSetClauseR4C1 [label = <CKZ<br/>N codeBlock<br/>fi ["{"]<br/>fo ["@", "}"]<br/>am []<br/>>]
    didSetClauseR5C1 [label = <CLA<br/>END <br/>fi [""]<br/>fo ["@", "}"]<br/>am []<br/>>]
    didSetClauseR4C1 -> didSetClauseR5C1 [weight=100000000]
    didSetClauseR3C1 -> didSetClauseR4C1 [weight=100000000]
    didSetClauseR3C2 [label = <CKW<br/>ALT <br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    didSetClauseR4C2 [label = <CKV<br/>N setterName<br/>fi ["("]<br/>fo ["{"]<br/>am []<br/>>]
    didSetClauseR5C2 [label = <CKX<br/>END <br/>fi [""]<br/>fo ["{"]<br/>am []<br/>>]
    didSetClauseR4C2 -> didSetClauseR5C2 [weight=100000000]
    didSetClauseR3C2 -> didSetClauseR4C2 [weight=100000000]
    rank = same {didSetClauseR3C1 -> didSetClauseR3C2}
    didSetClauseR2C1 -> didSetClauseR3C1 [weight=100000000]
    didSetClauseR1C1 -> didSetClauseR2C1 [weight=100000000]
    didSetClauseR1C3 [label = <CKR<br/>ALT <br/>fi ["@"]<br/>fo ["didSet"]<br/>am []<br/>>]
    didSetClauseR2C3 [label = <CKQ<br/>N attributes<br/>fi ["@"]<br/>fo ["didSet"]<br/>am []<br/>>]
    didSetClauseR3C3 [label = <CKS<br/>END <br/>fi [""]<br/>fo ["didSet"]<br/>am []<br/>>]
    didSetClauseR2C3 -> didSetClauseR3C3 [weight=100000000]
    didSetClauseR1C3 -> didSetClauseR2C3 [weight=100000000]
    rank = same {didSetClauseR1C1 -> didSetClauseR1C3}
    didSetClauseR0C1 -> didSetClauseR1C1 [weight=100000000]
    rank = same {didSetClauseR0C0 -> didSetClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {didSetClauseR0C1 -> didSetClauseR0C2}
    rank = same {didSetClauseR0C2 -> didSetClauseR0C3}
    didSetClauseR0C0 -> didSetClauseR1C0 [weight=100000000]
    rank = same {didSetClauseR1C0 -> didSetClauseR1C1}
    didSetClauseR0C3 -> didSetClauseR1C3 [weight=100000000]
    didSetClauseR1C0 -> didSetClauseR2C0 [weight=100000000]
    rank = same {didSetClauseR2C0 -> didSetClauseR2C1}
    rank = same {didSetClauseR2C1 -> didSetClauseR2C2}
    rank = same {didSetClauseR2C2 -> didSetClauseR2C3}
    didSetClauseR2C0 -> didSetClauseR3C0 [weight=100000000]
    rank = same {didSetClauseR3C0 -> didSetClauseR3C1}
    didSetClauseR2C2 -> didSetClauseR3C2 [weight=100000000]
    didSetClauseR3C0 -> didSetClauseR4C0 [weight=100000000]
    rank = same {didSetClauseR4C0 -> didSetClauseR4C1}
    didSetClauseR3C3 -> didSetClauseR4C3 [weight=100000000]
    rank = same {didSetClauseR4C2 -> didSetClauseR4C3}
    didSetClauseR4C0 -> didSetClauseR5C0 [weight=100000000]
    rank = same {didSetClauseR5C0 -> didSetClauseR5C1}
    didSetClauseR4C3 -> didSetClauseR5C3 [weight=100000000]
    rank = same {didSetClauseR5C2 -> didSetClauseR5C3}
  }
  subgraph clusterrawValueStyleEnumCaseClause {
    node [shape = box]
    label = <rawValueStyleEnumCaseClause = [ attributes ] "case" rawValueStyleEnumCaseList .>
    labeljust = l
    rawValueStyleEnumCaseClauseR0C0 [label = <CYD<br/>N rawValueStyleEnumCaseClause<br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    rawValueStyleEnumCaseClauseR0C1 [label = <CXV<br/>ALT <br/>fi ["", "@"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am ["@"]<br/>>]
    rawValueStyleEnumCaseClauseR1C1 [label = <CXZ<br/>OPT <br/>fi ["", "@"]<br/>fo ["case"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR2C1 [label = <CYA<br/>T "case"<br/>fi ["case"]<br/>fo ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR3C1 [label = <CYB<br/>N rawValueStyleEnumCaseList<br/>fi ["escapedIdentifier", "implicitParameterName", "plainIdentifier", "propertyWrapperProjection"]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR4C1 [label = <CYC<br/>END <br/>fi [""]<br/>fo ["#error", "#if", "#sourceLocation", "#warning", "@", "infix", "postfix", "precedencegroup", "prefix", "}"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR3C1 -> rawValueStyleEnumCaseClauseR4C1 [weight=100000000]
    rawValueStyleEnumCaseClauseR2C1 -> rawValueStyleEnumCaseClauseR3C1 [weight=100000000]
    rawValueStyleEnumCaseClauseR1C1 -> rawValueStyleEnumCaseClauseR2C1 [weight=100000000]
    rawValueStyleEnumCaseClauseR1C2 [label = <CXX<br/>ALT <br/>fi ["@"]<br/>fo ["case"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR2C2 [label = <CXW<br/>N attributes<br/>fi ["@"]<br/>fo ["case"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR3C2 [label = <CXY<br/>END <br/>fi [""]<br/>fo ["case"]<br/>am []<br/>>]
    rawValueStyleEnumCaseClauseR2C2 -> rawValueStyleEnumCaseClauseR3C2 [weight=100000000]
    rawValueStyleEnumCaseClauseR1C2 -> rawValueStyleEnumCaseClauseR2C2 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR1C1 -> rawValueStyleEnumCaseClauseR1C2}
    rawValueStyleEnumCaseClauseR0C1 -> rawValueStyleEnumCaseClauseR1C1 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR0C0 -> rawValueStyleEnumCaseClauseR0C1}
    node [style = invis]
    edge [style = invis]
    rank = same {rawValueStyleEnumCaseClauseR0C1 -> rawValueStyleEnumCaseClauseR0C2}
    rawValueStyleEnumCaseClauseR0C0 -> rawValueStyleEnumCaseClauseR1C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR1C0 -> rawValueStyleEnumCaseClauseR1C1}
    rawValueStyleEnumCaseClauseR0C2 -> rawValueStyleEnumCaseClauseR1C2 [weight=100000000]
    rawValueStyleEnumCaseClauseR1C0 -> rawValueStyleEnumCaseClauseR2C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR2C0 -> rawValueStyleEnumCaseClauseR2C1}
    rawValueStyleEnumCaseClauseR2C0 -> rawValueStyleEnumCaseClauseR3C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR3C0 -> rawValueStyleEnumCaseClauseR3C1}
    rawValueStyleEnumCaseClauseR3C0 -> rawValueStyleEnumCaseClauseR4C0 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR4C0 -> rawValueStyleEnumCaseClauseR4C1}
    rawValueStyleEnumCaseClauseR3C2 -> rawValueStyleEnumCaseClauseR4C2 [weight=100000000]
    rank = same {rawValueStyleEnumCaseClauseR4C1 -> rawValueStyleEnumCaseClauseR4C2}
  }
}