// SWIFT 6 GRAMMAR

topLevelDeclaration = statements? .

// WHITESPACE AND COMMENT

whitespace : /\s+/.                                                     // simplified
//whitespace = whitespaceItem whitespace? .
//whitespaceItem = lineBreak .
//whitespaceItem = inlineSpace .
//whitespaceItem = comment .
//whitespaceItem = multilineComment .
//whitespaceItem = U+0000, U+000B, or U+000C.                           // NULL or \0 or \u{0000}, VERTICAL TAB or \u{000B}, or FORM FEED or \u{000C}

//lineBreak = U+000A                                                    // NEWLINE or \n or \u{000A}
//lineBreak = U+000D                                                    // CARRIAGE RETURN or \r or \u{000D}
//lineBreak = U+000D followed by U+000A

//inlineSpaces = inlineSpace inlineSpaces? .
//inlineSpace = U+0009 or U+0020                                        // HORIZONTAL TAB or \t or \u{0009}, SPACE or \u{0020}

comment : /\/\/.*\r?\n?/ .                                              // simplified
// comment = "//" commentText lineBreak .

multilineComment : /\/\*(?s).*?\*\// .                                  // simplified
//multilineComment = "/*" multilineCommentText "*/" .

//commentText = commentTextItem commentText? .
//commentTextItem = Any Unicode scalar value except U+000A or U+000D

//multilineCommentText = multilineCommentTextItem multilineCommentText? .
//multilineCommentTextItem = multilineComment .
//multilineCommentTextItem = commentTextItem .
//multilineCommentTextItem = Any Unicode scalar value except "/*" or "*/"


//IDENTIFIERS

plainIdentifier             = /\p{XID_Start}\p{XID_Continue}*/ .       // simplified
escapedIdentifier           = /`\p{XID_Start}\p{XID_Continue}*`/ .
implicitParameterName       = /\$[0-9]+/ .
propertyWrapperProjection   = /\$\p{XID_Continue}+/ .

identifier = "_" | plainIdentifier | escapedIdentifier | implicitParameterName | propertyWrapperProjection .

//identifier = identifierHead identifierCharacters? .
//identifier = "`" identifierHead identifierCharacters? "`" .
//identifier = implicitParameterName .
//identifier = propertyWrapperProjection .

identifierList = identifier | identifier "," identifierList .
//identifierList = identifier { "," identifier } .                      // EBNF

// these are included in XID_Start
//identifierHead = Upper or lowercase letter A through Z
//identifierHead = "_" .
//identifierHead = U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or U+00B7–U+00BA
//identifierHead = U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or U+00F8–U+00FF
//identifierHead = U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or U+180F–U+1DBF
//identifierHead = U+1E00–U+1FFF
//identifierHead = U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, or U+2060–U+206F
//identifierHead = U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or U+2776–U+2793
//identifierHead = U+2C00–U+2DFF or U+2E80–U+2FFF
//identifierHead = U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or U+3040–U+D7FF
//identifierHead = U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or U+FE30–U+FE44
//identifierHead = U+FE47–U+FFFD
//identifierHead = U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, or U+40000–U+4FFFD
//identifierHead = U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, or U+80000–U+8FFFD
//identifierHead = U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, or U+C0000–U+CFFFD
//identifierHead = U+D0000–U+DFFFD or U+E0000–U+EFFFD

// These are included in XID_Continue
//identifierCharacter = Digit 0 through 9
//identifierCharacter = U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, or U+FE20–U+FE2F
//identifierCharacter = identifierHead .
//identifierCharacters = identifierCharacter identifierCharacters? .

//implicitParameterName = "$" decimalDigits .
//propertyWrapperProjection = "$" identifierCharacters .


// REGULAR EXPRESSIONS

plainRegularExpressionLiteral = /\/[^\s](?:(?:[^\/\\\s]|\\.)*[^\s])?\// .       // eliminates start or end whitespace, helps with / division sign
extendedRegularExpressionLiteral = /#+\/(?:[^\/\\]|\\.)+\/#+/ .                 // captures legal Swift regex already validated by the compiler
regularExpressionLiteral = plainRegularExpressionLiteral | extendedRegularExpressionLiteral .

//regularExpressionLiteral = regularExpressionLiteralOpeningDelimiter regularExpression regularExpressionLiteralClosingDelimiter .
//regularExpression = Any regular expression
//regularExpressionLiteralOpeningDelimiter = extendedRegularExpressionLiteralDelimiter? "/" .
//regularExpressionLiteralClosingDelimiter = "/" extendedRegularExpressionLiteralDelimiter? .
//extendedRegularExpressionLiteralDelimiter = "#" extendedRegularExpressionLiteralDelimiter? .




// STRINGS

// this is a catchall for staticStringLiteral and interpolatedStringLiteral (which includes staticStringLiteral), the parser will need to validate
stringLiteral = /"(?:\\(?:#*\([^)]*\)|#*[0\\tnr"']|#*u\{[0-9a-fA-F]{1,8}\}|#*\s*\n)|[^\\"])*"|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .

//stringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"" .
//stringLiteralClosingDelimiter = "\"" extendedStringLiteralDelimiter? .

staticStringLiteral = stringLiteral .

//staticStringLiteral = /#*"(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .
//staticStringLiteral = stringLiteralOpeningDelimiter quotedText? stringLiteralClosingDelimiter .
//staticStringLiteral = multilineStringLiteralOpeningDelimiter multilineQuotedText? multilineStringLiteralClosingDelimiter .

//multilineStringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"\"\"" .
//multilineStringLiteralClosingDelimiter = "\"\"\"" extendedStringLiteralDelimiter? .
//extendedStringLiteralDelimiter = "#" extendedStringLiteralDelimiter? .

//quotedText = quotedTextItem quotedText? .
//quotedTextItem = escapedCharacter .
//quotedTextItem = Any Unicode scalar value except ", \, U+000A, or U+000D

//multilineQuotedText = multilineQuotedTextItem multilineQuotedText? .
//multilineQuotedTextItem = escapedCharacter .
//multilineQuotedTextItem = Any Unicode scalar value except \
//multilineQuotedTextItem = escapedNewline .

interpolatedStringLiteral = stringLiteral .
//interpolatedStringLiteral = /#*"(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .
//interpolatedStringLiteral = stringLiteralOpeningDelimiter interpolatedText? stringLiteralClosingDelimiter .
//interpolatedStringLiteral = multilineStringLiteralOpeningDelimiter multilineInterpolatedText? multilineStringLiteralClosingDelimiter .

//interpolatedText = interpolatedTextItem interpolatedText? .
//interpolatedTextItem = "\\(" expression ")" | quotedTextItem .

//multilineInterpolatedText = multilineInterpolatedTextItem multilineInterpolatedText? .
//multilineInterpolatedTextItem = "\\(" expression ")" | multilineQuotedTextItem .

//escapeSequence = "\\" extendedStringLiteralDelimiter .
//escapedCharacter = escapeSequence "0" | escapeSequence "\\" | escapeSequence "t" | escapeSequence "n" | escapeSequence "r" | escapeSequence """ | escapeSequence "'" .
//escapedCharacter = escapeSequence "u" "{" unicodeScalarDigits "}" .
//unicodeScalarDigits = Between one and eight hexadecimal digits

//escapedNewline = escapeSequence inlineSpaces? lineBreak .





// LITERALS

binaryLiteral = /-?0b[0-1][0-1_]*/ .
//binaryLiteral = "0b" binaryDigit binaryLiteralCharacters? .
//binaryDigit = Digit 0 or 1
//binaryLiteralCharacter = binaryDigit | "_" .
//binaryLiteralCharacters = binaryLiteralCharacter binaryLiteralCharacters? .

octalLiteral = /-?0o[0-7][0-7_]*/ .
//octalLiteral = "0o" octalDigit octalLiteralCharacters? .
//octalDigit = Digit 0 through 7
//octalLiteralCharacter = octalDigit | "_" .
//octalLiteralCharacters = octalLiteralCharacter octalLiteralCharacters? .

decimalNumber = /-?[0-9][0-9_]*/ .                                      // this is the catchall for decimalLiteral and decimalDigits
decimalLiteral = decimalNumber .
//decimalLiteral = decimalDigit decimalLiteralCharacters? .
//decimalDigit = Digit 0 through 9

decimalDigits = decimalNumber .                                         // parser to verify it matches /[0-9]+/ !!!
//decimalDigits = decimalDigit decimalDigits? .
//decimalLiteralCharacter = decimalDigit | "_" .
//decimalLiteralCharacters = decimalLiteralCharacter decimalLiteralCharacters? .

hexadecimalLiteral = /-?0x[0-9a-fA-F][0-9a-fA-F_]*/ .
//hexadecimalLiteral = "0x" hexadecimalDigit hexadecimalLiteralCharacters? .
//hexadecimalDigit = Digit 0 through 9, a through f, or A through F
//hexadecimalLiteralCharacter = hexadecimalDigit | "_" .
//hexadecimalLiteralCharacters = hexadecimalLiteralCharacter hexadecimalLiteralCharacters? .

decimalFloatingPointLiteral     = /-?[0-9][0-9_]*(?:\.[0-9][0-9_]*)(?:[eE][+-]?[0-9][0-9_]*)?/ .    // made the decimal fraction non-optional to avoid conflict with decimalDigits
//decimalFloatingPointLiteral     = /-?[0-9][0-9_]*(?:\.[0-9][0-9_]*)?(?:[eE][+-]?[0-9][0-9_]*)?/ .

hexadecimalFloatingPointLiteral = /-?0x[0-9a-fA-F][0-9a-fA-F_]*(?:\.[0-9a-fA-F][0-9a-fA-F_]*)?(?:[pP][+-]?[0-9][0-9_]*)/ .
//floatingPointLiteral = decimalLiteral decimalFraction? decimalExponent? .
//floatingPointLiteral = hexadecimalLiteral hexadecimalFraction? hexadecimalExponent .
floatingPointLiteral = decimalFloatingPointLiteral | hexadecimalFloatingPointLiteral .

//decimalFraction = "." decimalLiteral .
//decimalExponent = floatingPointE sign? decimalLiteral .

//hexadecimalFraction = "." hexadecimalDigit hexadecimalLiteralCharacters? .
//hexadecimalExponent = floatingPointP sign? decimalLiteral .

//floatingPointE = "e" | "E" .
//floatingPointP = "p" | "P" .
//sign = "+" | "-" .

literal = numericLiteral | stringLiteral | regularExpressionLiteral | booleanLiteral | nilLiteral .

numericLiteral = integerLiteral | floatingPointLiteral .
//numericLiteral = "-"? integerLiteral | "-"? floatingPointLiteral .
booleanLiteral = "true" | "false" .
nilLiteral = "nil" .

integerLiteral = binaryLiteral .
integerLiteral = octalLiteral .
integerLiteral = decimalLiteral .
integerLiteral = hexadecimalLiteral .




// OPERATORS

//simpleOperator = "/" | "=" | "-" | "+" | "!" | "*" | "%" | "<" | ">" | "&" | "|" | "^" | "~" | "?" .      // captured as literals used elsewhere ("/")
//compoundOperator = /[\/=+\-*%!&|^~?<>\p{Sm}\p{So}][\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]*/ .                // overlaps with simpleOperator, and literals win
plainOperator = /[\/=+\-*%!&|^~?<>\p{Sm}\p{So}][\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]*/ .                     // overlaps with literals like '/' and '='

dotOperator   = /\.[\.\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]+/ .           // captures legal Swift operators already validated by the compiler

//plainOperator = simpleOperator | compoundOperator .
Operator = plainOperator | dotOperator .                                // capitalized to 'Operator' to avoid conflict with "operator" literal

//operator = operatorHead operatorCharacters? .
//operator = dotOperatorHead dotOperatorCharacters .


//operatorHead = "/" | "=" | "-" | "+" | "!" | "*" | "%" | "<" | ">" | "&" | "|" | "^" | "~" | "?" .
// Grok: the following characters are covered by Sm (Symbol, Math), and So (Symbol, Other).
//operatorHead = U+00A1–U+00A7
//operatorHead = U+00A9 or U+00AB
//operatorHead = U+00AC or U+00AE
//operatorHead = U+00B0–U+00B1
//operatorHead = U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7
//operatorHead = U+2016–U+2017
//operatorHead = U+2020–U+2027
//operatorHead = U+2030–U+203E
//operatorHead = U+2041–U+2053
//operatorHead = U+2055–U+205E
//operatorHead = U+2190–U+23FF
//operatorHead = U+2500–U+2775
//operatorHead = U+2794–U+2BFF
//operatorHead = U+2E00–U+2E7F
//operatorHead = U+3001–U+3003
//operatorHead = U+3008–U+3020
//operatorHead = U+3030

//operatorCharacter = operatorHead .
// Grok: the following characters are covered by Mn (Mark, Nonspacing).
//operatorCharacter = U+0300–U+036F
//operatorCharacter = U+1DC0–U+1DFF
//operatorCharacter = U+20D0–U+20FF
//operatorCharacter = U+FE00–U+FE0F
//operatorCharacter = U+FE20–U+FE2F
//operatorCharacter = U+E0100–U+E01EF
//operatorCharacters = operatorCharacter operatorCharacters? .

//dotOperatorHead = "." .
//dotOperatorCharacter = "." | operatorCharacter .
//dotOperatorCharacters = dotOperatorCharacter dotOperatorCharacters? .

infixOperator = Operator .
prefixOperator = Operator .
postfixOperator = Operator .



// TYPES

type = functionType .
type = arrayType .
type = dictionaryType .
type = typeIdentifier .
type = tupleType .
type = optionalType .
type = implicitlyUnwrappedOptionalType .
type = protocolCompositionType .
type = opaqueType .
type = metatypeType .
type = anyType .
type = selfType .
type = "(" type ")" .

typeAnnotation = ":" attributes? "inout"? type .

typeIdentifier = typeName genericArgumentClause? | typeName genericArgumentClause? "." typeIdentifier .
typeName = identifier .

tupleType = "(" ")" | "(" tupleTypeElement "," tupleTypeElementList ")" .
tupleTypeElementList = tupleTypeElement | tupleTypeElement "," tupleTypeElementList .
tupleTypeElement = elementName typeAnnotation | type .
elementName = identifier .

functionType = attributes? functionTypeArgumentClause "async"? throwsClause? ">" type .

functionTypeArgumentClause = "(" ")" .
functionTypeArgumentClause = "(" functionTypeArgumentList "..."? ")" .

functionTypeArgumentList = functionTypeArgument | functionTypeArgument "," functionTypeArgumentList .
functionTypeArgument = attributes? "inout"? type | argumentLabel typeAnnotation .
argumentLabel = identifier .

throwsClause = "throws" | "throws" "(" type ")" .

arrayType = "[" type "]" .

dictionaryType = "[" type ":" type "]" .

optionalType = type "?" .

implicitlyUnwrappedOptionalType = type "!" .

protocolCompositionType = typeIdentifier "&" protocolCompositionContinuation .
protocolCompositionContinuation = typeIdentifier | protocolCompositionType .

opaqueType = "some" type .

boxedProtocolType = "any" type .

metatypeType = type "." "Type" | type "." "Protocol" .

anyType = "Any" .

selfType = "Self" .

typeInheritanceClause = ":" typeInheritanceList .
typeInheritanceList = attributes? typeIdentifier | attributes? typeIdentifier "," typeInheritanceList .



// EXPRESSIONS

expression = tryOperator? awaitOperator? prefixExpression infixExpressions? .  // WTF is this \ doing here?

prefixExpression = prefixOperator? postfixExpression .
prefixExpression = inOutExpression .

inOutExpression = "&" primaryExpression .

tryOperator = "try" | "try" "?" | "try" "!" .

awaitOperator = "await" .

infixExpression = infixOperator prefixExpression .
infixExpression = assignmentOperator tryOperator? awaitOperator? prefixExpression .
infixExpression = conditionalOperator tryOperator? awaitOperator? prefixExpression .
infixExpression = typeCastingOperator .
infixExpressions = infixExpression infixExpressions? .

assignmentOperator = "=" .

conditionalOperator = "?" expression ":" .

typeCastingOperator = "is" type .
typeCastingOperator = "as" type .
typeCastingOperator = "as" "?" type .
typeCastingOperator = "as" "!" type .

primaryExpression = identifier genericArgumentClause? .
primaryExpression = literalExpression .
primaryExpression = selfExpression .
primaryExpression = superclassExpression .
primaryExpression = conditionalExpression .
primaryExpression = closureExpression .
primaryExpression = parenthesizedExpression .
primaryExpression = tupleExpression .
primaryExpression = implicitMemberExpression .
primaryExpression = wildcardExpression .
primaryExpression = macroExpansionExpression .
primaryExpression = keyPathExpression .
primaryExpression = selectorExpression .
primaryExpression = keyPathStringExpression .

literalExpression = literal .
literalExpression = arrayLiteral | dictionaryLiteral | playgroundLiteral .

arrayLiteral = "[" arrayLiteralItems? "]" .
arrayLiteralItems = arrayLiteralItem ","? | arrayLiteralItem "," arrayLiteralItems .
arrayLiteralItem = expression .

dictionaryLiteral = "[" dictionaryLiteralItems "]" | "[" ":" "]" .
dictionaryLiteralItems = dictionaryLiteralItem ","? | dictionaryLiteralItem "," dictionaryLiteralItems .
dictionaryLiteralItem = expression ":" expression .

playgroundLiteral = "#colorLiteral" "(" "red" ":" expression "," "green" ":" expression "," "blue" ":" expression "," "alpha" ":" expression ")" .
playgroundLiteral = "#fileLiteral" "(" "resourceName" ":" expression ")" .
playgroundLiteral = "#imageLiteral" "(" "resourceName" ":" expression ")" .

selfExpression = "self" | selfMethodExpression | selfSubscriptExpression | selfInitializerExpression .

selfMethodExpression = "self" "." identifier .
selfSubscriptExpression = "self" "[" functionCallArgumentList "]" .
selfInitializerExpression = "self" "." "init" .

superclassExpression = superclassMethodExpression | superclassSubscriptExpression | superclassInitializerExpression .

superclassMethodExpression = "super" "." identifier .
superclassSubscriptExpression = "super" "[" functionCallArgumentList "]" .
superclassInitializerExpression = "super" "." "init" .

conditionalExpression = ifExpression | switchExpression .

ifExpression = "if" conditionList "{" statement "}" ifExpressionTail .
ifExpressionTail = "else" ifExpression .
ifExpressionTail = "else" "{" statement "}" .

switchExpression = "switch" expression "{" switchExpressionCases "}" .
switchExpressionCases = switchExpressionCase switchExpressionCases? .
switchExpressionCase = caseLabel statement .
switchExpressionCase = defaultLabel statement .

closureExpression = "{" attributes? closureSignature? statements? "}" .

closureSignature = captureList? closureParameterClause "async"? throwsClause? functionResult? "in" .
closureSignature = captureList "in" .

closureParameterClause = "(" ")" | "(" closureParameterList ")" | identifierList .
closureParameterList = closureParameter | closureParameter "," closureParameterList .
closureParameter = closureParameterName typeAnnotation? .
closureParameter = closureParameterName typeAnnotation "..." .
closureParameterName = identifier .

captureList = "[" captureListItems "]" .
captureListItems = captureListItem | captureListItem "," captureListItems .
captureListItem = captureSpecifier? identifier .
captureListItem = captureSpecifier? identifier "=" expression .
captureListItem = captureSpecifier? selfExpression .
captureSpecifier = "weak" | "unowned" | "unowned(safe)" | "unowned(unsafe)" .

implicitMemberExpression = "." identifier .
implicitMemberExpression = "." identifier "." postfixExpression .

parenthesizedExpression = "(" expression ")" .

tupleExpression = "(" ")" | "(" tupleElement "," tupleElementList ")" .
tupleElementList = tupleElement | tupleElement "," tupleElementList .
tupleElement = expression | identifier ":" expression .

wildcardExpression = "_" .

//macroExpansionExpression = "#" identifier genericArgumentClause? functionCallArgumentClause? trailingClosures? .
macroIdentifier = /#\p{XID_Start}\p{XID_Continue}*/ .
macroExpansionExpression = macroIdentifier genericArgumentClause? functionCallArgumentClause? trailingClosures? .

keyPathExpression = "\\" type? "." keyPathComponents .      // escape needed
//keyPathExpression = "\" type? "." keyPathComponents .
keyPathComponents = keyPathComponent | keyPathComponent "." keyPathComponents .
keyPathComponent = identifier keyPathPostfixes? | keyPathPostfixes .

keyPathPostfixes = keyPathPostfix keyPathPostfixes? .
keyPathPostfix = "?" | "!" | "self" | "[" functionCallArgumentList "]" .

selectorExpression = "#selector" "(" expression ")" .
selectorExpression = "#selector" "(" "getter:" expression ")" .
selectorExpression = "#selector" "(" "setter:" expression ")" .

keyPathStringExpression = "#keyPath" "(" expression ")" .

postfixExpression = primaryExpression .
postfixExpression = postfixExpression postfixOperator .
postfixExpression = functionCallExpression .
postfixExpression = initializerExpression .
postfixExpression = explicitMemberExpression .
postfixExpression = postfixSelfExpression .
postfixExpression = subscriptExpression .
postfixExpression = forcedValueExpression .
postfixExpression = optionalChainingExpression .

functionCallExpression = postfixExpression functionCallArgumentClause .
functionCallExpression = postfixExpression functionCallArgumentClause? trailingClosures .

functionCallArgumentClause = "(" ")" | "(" functionCallArgumentList ")" .
functionCallArgumentList = functionCallArgument | functionCallArgument "," functionCallArgumentList .
functionCallArgument = expression | identifier ":" expression .
functionCallArgument = Operator | identifier ":" Operator .

trailingClosures = closureExpression labeledTrailingClosures? .
labeledTrailingClosures = labeledTrailingClosure labeledTrailingClosures? .
labeledTrailingClosure = identifier ":" closureExpression .

initializerExpression = postfixExpression "." "init" .
initializerExpression = postfixExpression "." "init" "(" argumentNames ")" .

explicitMemberExpression = postfixExpression "." decimalDigits .
explicitMemberExpression = postfixExpression "." identifier genericArgumentClause? .
explicitMemberExpression = postfixExpression "." identifier "(" argumentNames ")" .
explicitMemberExpression = postfixExpression conditionalCompilationBlock .

argumentNames = argumentName argumentNames? .
argumentName = identifier ":" .

postfixSelfExpression = postfixExpression "." "self" .

subscriptExpression = postfixExpression "[" functionCallArgumentList "]" .

forcedValueExpression = postfixExpression "!" .

optionalChainingExpression = postfixExpression "?" .



// STATEMENTS

statement = expression ";"? .
statement = declaration ";"? .
statement = loopStatement ";"? .
statement = branchStatement ";"? .
statement = labeledStatement ";"? .
statement = controlTransferStatement ";"? .
statement = deferStatement ";"? .
statement = doStatement ";"? .
statement = compilerControlStatement .
statements = statement statements? .

loopStatement = forInStatement .
loopStatement = whileStatement .
loopStatement = repeatWhileStatement .

forInStatement = "for" "case"? pattern "in" expression whereClause? codeBlock .

whileStatement = "while" conditionList codeBlock .

conditionList = condition | condition "," conditionList .
condition = expression | availabilityCondition | caseCondition | optionalBindingCondition .

caseCondition = "case" pattern initializer .
optionalBindingCondition = "let" pattern initializer? | "var" pattern initializer? .

repeatWhileStatement = "repeat" codeBlock "while" expression .

branchStatement = ifStatement .
branchStatement = guardStatement .
branchStatement = switchStatement .

ifStatement = "if" conditionList codeBlock elseClause? .
elseClause = "else" codeBlock | "else" ifStatement .

guardStatement = "guard" conditionList "else" codeBlock .

switchStatement = "switch" expression "{" switchCases? "}" .
switchCases = switchCase switchCases? .
switchCase = caseLabel statements .
switchCase = defaultLabel statements .
switchCase = conditionalSwitchCase .

caseLabel = attributes? "case" caseItemList ":" .
caseItemList = pattern whereClause? | pattern whereClause? "," caseItemList .
defaultLabel = attributes? "default" ":" .

whereClause = "where" whereExpression .
whereExpression = expression .

conditionalSwitchCase = switchIfDirectiveClause switchElseifDirectiveClauses? switchElseDirectiveClause? endifDirective .
switchIfDirectiveClause = ifDirective compilationCondition switchCases? .
switchElseifDirectiveClauses = elseifDirectiveClause switchElseifDirectiveClauses? .
switchElseifDirectiveClause = elseifDirective compilationCondition switchCases? .
switchElseDirectiveClause = elseDirective switchCases? .

labeledStatement = statementLabel loopStatement .
labeledStatement = statementLabel ifStatement .
labeledStatement = statementLabel switchStatement .
labeledStatement = statementLabel doStatement .

statementLabel = labelName ":" .
labelName = identifier .

controlTransferStatement = breakStatement .
controlTransferStatement = continueStatement .
controlTransferStatement = fallthroughStatement .
controlTransferStatement = returnStatement .
controlTransferStatement = throwStatement .

breakStatement = "break" labelName? .

continueStatement = "continue" labelName? .

fallthroughStatement = "fallthrough" .

returnStatement = "return" expression? .

throwStatement = "throw" expression .

deferStatement = "defer" codeBlock .

doStatement = "do" throwsClause? codeBlock catchClauses? .
catchClauses = catchClause catchClauses? .
catchClause = "catch" catchPatternList? codeBlock .
catchPatternList = catchPattern | catchPattern "," catchPatternList .
catchPattern = pattern whereClause? .

compilerControlStatement = conditionalCompilationBlock .
compilerControlStatement = lineControlStatement .
compilerControlStatement = diagnosticStatement .

conditionalCompilationBlock = ifDirectiveClause elseifDirectiveClauses? elseDirectiveClause? endifDirective .

ifDirectiveClause = ifDirective compilationCondition statements? .
elseifDirectiveClauses = elseifDirectiveClause elseifDirectiveClauses? .
elseifDirectiveClause = elseifDirective compilationCondition statements? .
elseDirectiveClause = elseDirective statements? .
ifDirective = "#if" .
elseifDirective = "#elseif" .
elseDirective = "#else" .
endifDirective = "#endif" .

compilationCondition = platformCondition .
compilationCondition = identifier .
compilationCondition = booleanLiteral .
compilationCondition = "(" compilationCondition ")" .
compilationCondition = "!" compilationCondition .
compilationCondition = compilationCondition "&&" compilationCondition .
compilationCondition = compilationCondition "||" compilationCondition .

platformCondition = "os" "(" operatingSystem ")" .
platformCondition = "arch" "(" architecture ")" .
platformCondition = "swift" "(" ">=" swiftVersion ")" | "swift" "(" "<" swiftVersion ")" .
platformCondition = "compiler" "(" ">=" swiftVersion ")" | "compiler" "(" "<" swiftVersion ")" .
platformCondition = "canImport" "(" importPath ")" .
platformCondition = "targetEnvironment" "(" environment ")" .

operatingSystem = "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows" .
architecture = "i386" | "x86_64" | "arm" | "arm64" .
swiftVersion = decimalDigits swiftVersionContinuation? .
swiftVersionContinuation = "." decimalDigits swiftVersionContinuation? .
environment = "simulator" | "macCatalyst" .

lineNumber = decimalDigits .        // replace 'greater than zero' with parser post check'
//lineNumber = /0*[1-9][0-9]*/ .
lineControlStatement = "#sourceLocation" "(" "file:" filePath "," "line:" lineNumber ")" .
lineControlStatement = "#sourceLocation" "(" ")" .

//lineNumber = A decimal integer greater than zero .

filePath = staticStringLiteral .

diagnosticStatement = "#warning" "(" stringLiteral ")" | "#error" "(" stringLiteral ")" . // WTF missing, added as per Grok suggestion

availabilityCondition = "#available" "(" availabilityArguments ")" .
availabilityCondition = "#unavailable" "(" availabilityArguments ")" .
availabilityArguments = availabilityArgument | availabilityArgument "," availabilityArguments .
availabilityArgument = platformName platformVersion .
availabilityArgument = "*" .

platformName = "iOS" | "iOSApplicationExtension" .
platformName = "macOS" | "macOSApplicationExtension" .
platformName = "macCatalyst" | "macCatalystApplicationExtension" .
platformName = "watchOS" | "watchOSApplicationExtension" .
platformName = "tvOS" | "tvOSApplicationExtension" .
platformName = "visionOS" | "visionOSApplicationExtension" .
platformVersion = decimalDigits .
platformVersion = decimalDigits "." decimalDigits .
platformVersion = decimalDigits "." decimalDigits "." decimalDigits .



// DECLARATIONS

declaration = importDeclaration .
declaration = constantDeclaration .
declaration = variableDeclaration .
declaration = typealiasDeclaration .
declaration = functionDeclaration .
declaration = enumDeclaration .
declaration = structDeclaration .
declaration = classDeclaration .
declaration = actorDeclaration .
declaration = protocolDeclaration .
declaration = initializerDeclaration .
declaration = deinitializerDeclaration .
declaration = extensionDeclaration .
declaration = subscriptDeclaration .
declaration = operatorDeclaration .
declaration = precedenceGroupDeclaration . // WTF is \ doing here ???

codeBlock = "{" statements? "}" .

importDeclaration = attributes? "import" importKind? importPath .

importKind = "typealias" | "struct" | "class" | "enum" | "protocol" | "let" | "var" | "func" .
importPath = identifier | identifier "." importPath .

constantDeclaration = attributes? declarationModifiers? "let" patternInitializerList .

patternInitializerList = patternInitializer | patternInitializer "," patternInitializerList .
patternInitializer = pattern initializer? .
initializer = "=" expression .

variableDeclaration = variableDeclarationHead patternInitializerList .
variableDeclaration = variableDeclarationHead variableName typeAnnotation codeBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .
variableDeclaration = variableDeclarationHead variableName initializer willSetDidSetBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation initializer? willSetDidSetBlock .

variableDeclarationHead = attributes? declarationModifiers? "var" .
variableName = identifier .

getterSetterBlock = codeBlock .
getterSetterBlock = "{" getterClause setterClause? "}" .
getterSetterBlock = "{" setterClause getterClause "}" .
getterClause = attributes? mutationModifier? "get" codeBlock .
setterClause = attributes? mutationModifier? "set" setterName? codeBlock .
setterName = "(" identifier ")" .

getterSetterKeywordBlock = "{" getterKeywordClause setterKeywordClause? "}" .
getterSetterKeywordBlock = "{" setterKeywordClause getterKeywordClause "}" .
getterKeywordClause = attributes? mutationModifier? "get" .
setterKeywordClause = attributes? mutationModifier? "set" .

willSetDidSetBlock = "{" willSetClause didSetClause? "}" .
willSetDidSetBlock = "{" didSetClause willSetClause? "}" .
willSetClause = attributes? "willSet" setterName? codeBlock .
didSetClause = attributes? "didSet" setterName? codeBlock .

typealiasDeclaration = attributes? accessLevelModifier? "typealias" typealiasName genericParameterClause? typealiasAssignment .
typealiasName = identifier .
typealiasAssignment = "=" type .

functionDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? functionBody? .

functionHead = attributes? declarationModifiers? "func" .
functionName = identifier | Operator .

functionSignature = parameterClause "async"? throwsClause? functionResult? .
functionSignature = parameterClause "async"? "rethrows" functionResult? .
functionResult = ">" attributes? type .
functionBody = codeBlock .

parameterClause = "(" ")" | "(" parameterList ")" .
parameterList = parameter | parameter "," parameterList .
parameter = externalParameterName? localParameterName parameterTypeAnnotation defaultArgumentClause? .
parameter = externalParameterName? localParameterName parameterTypeAnnotation .
parameter = externalParameterName? localParameterName parameterTypeAnnotation "..." .

externalParameterName = identifier .
localParameterName = identifier .
parameterTypeAnnotation = ":" attributes? parameterModifier? type .
parameterModifier = "inout" | "borrowing" | "consuming" .
defaultArgumentClause = "=" expression .

enumDeclaration = attributes? accessLevelModifier? unionStyleEnum .
enumDeclaration = attributes? accessLevelModifier? rawValueStyleEnum .

unionStyleEnum = "indirect"? "enum" enumName genericParameterClause? typeInheritanceClause? genericWhereClause? "{" unionStyleEnumMembers? "}" .
unionStyleEnumMembers = unionStyleEnumMember unionStyleEnumMembers? .
unionStyleEnumMember = declaration | unionStyleEnumCaseClause | compilerControlStatement .
unionStyleEnumCaseClause = attributes? "indirect"? "case" unionStyleEnumCaseList .
unionStyleEnumCaseList = unionStyleEnumCase | unionStyleEnumCase "," unionStyleEnumCaseList .
unionStyleEnumCase = enumCaseName tupleType? .
enumName = identifier .
enumCaseName = identifier .

rawValueStyleEnum = "enum" enumName genericParameterClause? typeInheritanceClause genericWhereClause? "{" rawValueStyleEnumMembers "}" .
rawValueStyleEnumMembers = rawValueStyleEnumMember rawValueStyleEnumMembers? .
rawValueStyleEnumMember = declaration | rawValueStyleEnumCaseClause | compilerControlStatement .
rawValueStyleEnumCaseClause = attributes? "case" rawValueStyleEnumCaseList .
rawValueStyleEnumCaseList = rawValueStyleEnumCase | rawValueStyleEnumCase "," rawValueStyleEnumCaseList .
rawValueStyleEnumCase = enumCaseName rawValueAssignment? .
rawValueAssignment = "=" rawValueLiteral .
rawValueLiteral = numericLiteral | staticStringLiteral | booleanLiteral .

structDeclaration = attributes? accessLevelModifier? "struct" structName genericParameterClause? typeInheritanceClause? genericWhereClause? structBody .
structName = identifier .
structBody = "{" structMembers? "}" .

structMembers = structMember structMembers? .
structMember = declaration | compilerControlStatement .

classDeclaration = attributes? accessLevelModifier? "final"? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .
classDeclaration = attributes? "final" accessLevelModifier? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .
className = identifier .
classBody = "{" classMembers? "}" .

classMembers = classMember classMembers? .
classMember = declaration | compilerControlStatement .

actorDeclaration = attributes? accessLevelModifier? "actor" actorName genericParameterClause? typeInheritanceClause? genericWhereClause? actorBody .
actorName = identifier .
actorBody = "{" actorMembers? "}" .

actorMembers = actorMember actorMembers? .
actorMember = declaration | compilerControlStatement .

protocolDeclaration = attributes? accessLevelModifier? "protocol" protocolName typeInheritanceClause? genericWhereClause? protocolBody .
protocolName = identifier .
protocolBody = "{" protocolMembers? "}" .

protocolMembers = protocolMember protocolMembers? .
protocolMember = protocolMemberDeclaration | compilerControlStatement .

protocolMemberDeclaration = protocolPropertyDeclaration .
protocolMemberDeclaration = protocolMethodDeclaration .
protocolMemberDeclaration = protocolInitializerDeclaration .
protocolMemberDeclaration = protocolSubscriptDeclaration .
protocolMemberDeclaration = protocolAssociatedTypeDeclaration .
protocolMemberDeclaration = typealiasDeclaration .

protocolPropertyDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .

protocolMethodDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? .

protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause throwsClause? genericWhereClause? .
protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause "rethrows" genericWhereClause? .

protocolSubscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .

protocolAssociatedTypeDeclaration = attributes? accessLevelModifier? "associatedtype" typealiasName typeInheritanceClause? typealiasAssignment? genericWhereClause? .

initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? throwsClause? genericWhereClause? initializerBody .
initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? "rethrows" genericWhereClause? initializerBody .
initializerHead = attributes? declarationModifiers? "init" .
initializerHead = attributes? declarationModifiers? "init" "?" .
initializerHead = attributes? declarationModifiers? "init" "!" .
initializerBody = codeBlock .

deinitializerDeclaration = attributes? "deinit" codeBlock .

extensionDeclaration = attributes? accessLevelModifier? "extension" typeIdentifier typeInheritanceClause? genericWhereClause? extensionBody .
extensionBody = "{" extensionMembers? "}" .

extensionMembers = extensionMember extensionMembers? .
extensionMember = declaration | compilerControlStatement .

subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? codeBlock .
subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterBlock .
subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .
subscriptHead = attributes? declarationModifiers? "subscript" genericParameterClause? parameterClause .
subscriptResult = ">" attributes? type .

macroDeclaration = macroHead identifier genericParameterClause? macroSignature macroDefinition? genericWhereClause .
macroHead = attributes? declarationModifiers? "macro" .
macroSignature = parameterClause macroFunctionSignatureResult? .
macroFunctionSignatureResult = ">" type .
macroDefinition = "=" expression .

operatorDeclaration = prefixOperatorDeclaration | postfixOperatorDeclaration | infixOperatorDeclaration .

prefixOperatorDeclaration = "prefix" "operator" Operator .
postfixOperatorDeclaration = "postfix" "operator" Operator .
infixOperatorDeclaration = "infix" "operator" Operator infixOperatorGroup? .

infixOperatorGroup = ":" precedenceGroupName .

precedenceGroupDeclaration = "precedencegroup" precedenceGroupName "{" precedenceGroupAttributes? "}" .

precedenceGroupAttributes = precedenceGroupAttribute precedenceGroupAttributes? .
precedenceGroupAttribute = precedenceGroupRelation .
precedenceGroupAttribute = precedenceGroupAssignment .
precedenceGroupAttribute = precedenceGroupAssociativity .

precedenceGroupRelation = "higherThan" ":" precedenceGroupNames .
precedenceGroupRelation = "lowerThan" ":" precedenceGroupNames .

precedenceGroupAssignment = "assignment" ":" booleanLiteral .

precedenceGroupAssociativity = "associativity" ":" "left" .
precedenceGroupAssociativity = "associativity" ":" "right" .
precedenceGroupAssociativity = "associativity" ":" "none" .

precedenceGroupNames = precedenceGroupName | precedenceGroupName "," precedenceGroupNames .
precedenceGroupName = identifier .

declarationModifier = "class" | "convenience" | "dynamic" | "final" | "infix" | "lazy" | "optional" | "override" | "postfix" | "prefix" | "required" | "static" | "unowned" | "unowned" "(" "safe" ")" | "unowned" "(" "unsafe" ")" | "weak" .
declarationModifier = accessLevelModifier .
declarationModifier = mutationModifier .
declarationModifier = actorIsolationModifier .
declarationModifiers = declarationModifier declarationModifiers? .

accessLevelModifier = "private" | "private" "(" "set" ")" .
accessLevelModifier = "fileprivate" | "fileprivate" "(" "set" ")" .
accessLevelModifier = "internal" | "internal" "(" "set" ")" .
accessLevelModifier = "package" | "package" "(" "set" ")" .
accessLevelModifier = "public" | "public" "(" "set" ")" .
accessLevelModifier = "open" | "open" "(" "set" ")" .

mutationModifier = "mutating" | "nonmutating" .

actorIsolationModifier = "nonisolated" .



// ATTRIBUTES

attribute = "@" attributeName attributeArgumentClause? .
attributeName = identifier .
attributeArgumentClause = "(" balancedTokens? ")" .
attributes = attribute attributes? .

//keyword = "actor" | "associatedtype" | "class" | "deinit" | "enum" | "extension" | "fileprivate" | "func" | "import" | "init" | "inout" | "internal" | "let" | "open" | "operator" | "private" | "precedencegroup" | "protocol" | "public" | "rethrows" | "static" | "struct" | "subscript" | "typealias" | "var" | "break" | "case" | "catch" | "continue" | "default" | "defer" | "do" | "else" | "fallthrough" | "for" | "guard" | "if" | "in" | "repeat" | "return" | "switch" | "throw" | "try" | "where" | "while" | "Any" | "as" | "borrowing" | "consuming" | "copy" | "discard" | "false" | "is" | "move" | "nil" | "self" | "Self" | "super" | "throws" | "true" | "_unsafeInheritExecutor" | "_" | "each" | "associativity" | "convenience" | "didSet" | "dynamic" | "final" | "get" | "higherThan" | "indirect" | "lazy" | "left" | "lowerThan" | "mutating" | "nonmutating" | "none" | "optional" | "override" | "postfix" | "prefix" | "required" | "right" | "set" | "some" | "unowned" | "weak" | "willSet" | "#available" | "#colorLiteral" | "#column" | "#dsohandle" | "#elseif" | "#else" | "#endif" | "#error" | "#file" | "#fileID" | "#fileLiteral" | "#filePath" | "#function" | "#if" | "#imageLiteral" | "#keyPath" | "#line" | "#selector" | "#sourceLocation" | "#unavailable" | "#warning" | "(" | ")" | "{" | "}" | "[" | "]" | "." | "," | ":" | ";" | "=" | "@" | "#" | "&" | "?" | "!" | "<" | ">" | "|" | "^" | "~" | "%" | "*" | "+" | "-" | "/" | "isolated" | "nonisolated" | "async" | "await" | "yield" | "package" .


keywordMinusBrackets = "actor" | "associatedtype" | "class" | "deinit" | "enum" | "extension" | "fileprivate" | "func" | "import" | "init" | "inout" | "internal" | "let" | "open" | "operator" | "private" | "precedencegroup" | "protocol" | "public" | "rethrows" | "static" | "struct" | "subscript" | "typealias" | "var" | "break" | "case" | "catch" | "continue" | "default" | "defer" | "do" | "else" | "fallthrough" | "for" | "guard" | "if" | "in" | "repeat" | "return" | "switch" | "throw" | "try" | "where" | "while" | "Any" | "as" | "borrowing" | "consuming" | "copy" | "discard" | "false" | "is" | "move" | "nil" | "self" | "Self" | "super" | "throws" | "true" | "_unsafeInheritExecutor" | "_" | "each" | "associativity" | "convenience" | "didSet" | "dynamic" | "final" | "get" | "higherThan" | "indirect" | "lazy" | "left" | "lowerThan" | "mutating" | "nonmutating" | "none" | "optional" | "override" | "postfix" | "prefix" | "required" | "right" | "set" | "some" | "unowned" | "weak" | "willSet" | "#available" | "#colorLiteral" | "#elseif" | "#else" | "#endif" | "#error" | "#fileLiteral" | "#if" | "#imageLiteral" | "#keyPath" | "#selector" | "#sourceLocation" | "#unavailable" | "#warning" | "." | "," | ":" | ";" | "=" | "@" | "#" | "&" | "?" | "!" | "<" | ">" | "|" | "^" | "~" | "%" | "*" | "+" | "-" | "/" | "isolated" | "nonisolated" | "async" | "await" | "yield" | "package" .

balancedToken = identifier | keywordMinusBrackets | literal | Operator .
//balancedToken = Any identifier, keyword, literal, or operator .
//balancedToken = Any punctuation except (, ), [, ], {, or } .

balancedTokens = balancedToken balancedTokens? .

balancedToken = "(" balancedTokens? ")" .
balancedToken = "[" balancedTokens? "]" .
balancedToken = "{" balancedTokens? "}" .


// PATTERNS

pattern = wildcardPattern typeAnnotation? .
pattern = identifierPattern typeAnnotation? .
pattern = valueBindingPattern .
pattern = tuplePattern typeAnnotation? .
pattern = enumCasePattern .
pattern = optionalPattern .
pattern = typeCastingPattern .
pattern = expressionPattern .

wildcardPattern = "_" .

identifierPattern = identifier .

valueBindingPattern = "var" pattern | "let" pattern .               // WTF  'let let' pattern is not allowed by compiler

tuplePattern = "(" tuplePatternElementList? ")" .
tuplePatternElementList = tuplePatternElement | tuplePatternElement "," tuplePatternElementList .
tuplePatternElement = pattern | identifier ":" pattern .

enumCasePattern = typeIdentifier? "." enumCaseName tuplePattern? .

optionalPattern = identifierPattern "?" .

typeCastingPattern = isPattern | asPattern .
isPattern = "is" type .
asPattern = pattern "as" type .

expressionPattern = expression .


// GENERIC PARAMETERS AND ARGUMENTS

genericParameterClause = "<" genericParameterList ">" .
genericParameterList = genericParameter | genericParameter "," genericParameterList .
genericParameter = typeName .
genericParameter = typeName ":" typeIdentifier .
genericParameter = typeName ":" protocolCompositionType .

genericWhereClause = "where" requirementList .
requirementList = requirement | requirement "," requirementList .
requirement = conformanceRequirement | sameTypeRequirement .

conformanceRequirement = typeIdentifier ":" typeIdentifier .
conformanceRequirement = typeIdentifier ":" protocolCompositionType .
sameTypeRequirement = typeIdentifier "==" type .

genericArgumentClause = "<" genericArgumentList ">" .
genericArgumentList = genericArgument | genericArgument "," genericArgumentList .
genericArgument = type .

^^^
//class c: p {                          // FAIL with Swift.apus
//    func f () -> Int {}
//}
//
//  GenerateDiagrams.swift
//  Advent
//
//  Created by Johannes Brands on 03/10/2024.
//

// https://graphviz.org

import Foundation

struct Cell: Hashable, CustomStringConvertible {
    let name: String
    let r, c: Int
    var description: String { "\(name)R\(r)C\(c)" }
}

class DiagramsGenerator {
    
    let diagramFile: URL
    
    init(outputFile: URL) {
        self.diagramFile = outputFile
    }

    var content = #"""
        digraph G {
          fontname = Menlo
          fontsize = 10
          node [fontname = Menlo, fontsize = 10, color = gray, height = 0, width = 0, margin= 0.04]
          edge [fontname = Menlo, fontsize = 10, color = gray, arrowsize = 0.3]
          graph [ranksep = 0.1]
          rankdir = "TB"
        """#
//    graph [ordering = out, ranksep = 0.2]

    var endSeqLinks: [(from: GrammarNode, to: GrammarNode)] = []
    var endAltLinks: [(from: GrammarNode, to: GrammarNode)] = []
    var ntrAltLinks: [(from: GrammarNode, to: GrammarNode)] = []
    
    // The Graphviz grammar node grid is stored in a dictionary with the position as key.
    // A Bool value indicates if the node at that position is a true GrammarNode or a skipped node.
    // Absent nodes are absent from the Dictionary.
    var grid: [Cell:Bool] = [:]
    var maxRow = 0
    var maxCol = 0

    // Draw a regular grid of GrammarNodes with arrows for .seq down and .alt to the right.
    func generateDiagrams() throws {
        
        // generate GSS graph
        content.append("\n  subgraph GSS {")
        content.append("\n    cluster = true")
        
        var shortMessage = messages[0]
        if shortMessage.count > 20 {
            shortMessage = String(shortMessage.prefix(17))
            shortMessage.append("...")
        }

        content.append("\n    label = <\(shortMessage.whitespaceMadeVisible.graphvizHTML)> \(successfullParses > 0 ? "fontcolor = green" : "fontcolor = red" )")
        content.append("\n    labeljust = l")
        content.append("\n    node [shape = box, style = rounded, height = 0]")
        for node in gss.sorted() {
            for edge in node.edges {
                let poppedIndexes = node.pops.sorted().description.dropFirst().dropLast()
                content.append("\n    \(node) [label = <\(node)<br/><font color=\"gray\" point-size=\"8.0\"> \(poppedIndexes)</font>>]")
                content.append("\n    \(node) -> \(edge)")
            }
        }
        content.append("\n  }")

        // generate syntax graph for each non-terminal
        for (name, node) in nonTerminals {
            content.append("\n  subgraph cluster\(name) {")
            //        d.append("\n    cluster = true")
            content.append("\n    node [shape = box]")
            content.append("\n    label = <\(node.ebnf().graphvizHTML)>")
            content.append("\n    labeljust = l")
            
            maxRow = 0
            maxCol = 0
            grid = [:]
            
            draw(name: name, node: node, row: 0, col: 0)
            
            addScaffolding(name: name)
            
            content.append("\n  }")
        }
        
//        for (from, to) in endSeqLinks {
//            content.append("\n  \(from.cell):w -> \(to.cell):s [style = solid, color = red, constraint = false]")
//        }
//        for (from, to) in endAltLinks {
//            content.append("\n  \(from.cell):e -> \(to.cell) [style = dotted, color = green, constraint = false]")
//        }
//        for (from, to) in ntrAltLinks {
//            content.append("\n  \(from.cell):e -> \(to.cell) [style = dotted, color = blue, constraint = false]")
//        }
        
        content.append("\n}")
        
        try content.write(to: diagramFile, atomically: true, encoding: .utf8)
    }

    // Draw a pretty picture of a GrammarNode with alt and seq links
    func draw(name: String, node: GrammarNode, row: Int, col: Int) {
        var str = node.str
        if node.kind == .T {
            str = "\"" + str + "\""
        }
        
        node.cell = Cell(name: name, r: row, c: col)
        grid[node.cell] = true
        
        content.append("\n    \(node.cell) [label = <\(node)<br/>\(node.kind) \(str.graphvizHTML)<br/>fi \(node.first.sorted().description.graphvizHTML)<br/>fo \(node.follow.sorted().description.graphvizHTML)>]")
//        content.append("\n    \(node.cell) [label = <\(node)<br/>\(node.kind) \(str.graphvizHTML)<br/>fi \(node.first.sorted().description.graphvizHTML)<br/>fo \(node.follow.sorted().description.graphvizHTML)<br/>am \(node.ambiguous.sorted().description.graphvizHTML)<br/>\(node.actions.joined(separator: "<br/>"))>]")
//        content.append("\n    \(node.cell) [label = <\(node)<br/>\(node.kind) \(str.graphvizHTML)>]")

        if let seq = node.seq {
            if node.kind == .END {
                endSeqLinks.append((from: node, to: seq))
            } else {
                maxRow = max(maxRow, row+1)
                draw(name: name, node: seq, row: row+1, col: col)
//                content.append("\n    \(node.cell):s -> \(seq.cell) [weight=100000000]")
                content.append("\n    \(node.cell) -> \(seq.cell) [weight=100000000]")
            }
        }
        
        if let alt = node.alt {
            // .alt can only point to an ALT node
            if node.kind == .END {
                endAltLinks.append((from: node, to: alt))
            } else if node.kind == .N && node.seq != nil { // rhs nonterminal
                ntrAltLinks.append((from: node, to: alt))
            } else {
                maxCol = max(maxCol+1, col+1)
                
                // fill the row with empty nodes that should not be drawn or connected
                for c in col+1 ..< maxCol {
                    let c = Cell(name: name, r: row, c: c)
                    grid[c] = false
                }
                
                draw(name: name, node: alt, row: row, col: maxCol)
                content.append("\n    rank = same {\(node.cell) -> \(alt.cell)}")
                
            }
        }
    }
    
    // add dummy cells and edges to fool Graphviz into maintaining a rectangular grid
    func addScaffolding(name: String) {
//        d.append("\n    node [color = red]")
//        d.append("\n    edge [color = red]")
        content.append("\n    node [style = invis]")
        content.append("\n    edge [style = invis]")

        // draw the dummy cells and the arrows that go into them
        for r in 0...maxRow {
            for c in 0...maxCol {
                let cell = Cell(name: name, r: r, c: c)
                
                // draw arrows into dummy cell from real cells or dummy cells
                if grid[cell] == nil {
                    if r > 0 {
                        let above = Cell(name: name, r: r-1, c: c)
                        if grid[above] != false {
                            content.append("\n    \(above) -> \(cell) [weight=100000000]")
                        }
                    }
                    if c > 0 {
                        let left = Cell(name: name, r: r, c: c-1)
                        if grid[left] != false {
                            content.append("\n    rank = same {\(left) -> \(cell)}")
                        }
                    }
                    
                // draw arrows into real nodes from dummy cells
                } else if grid[cell] == true {
                    if r > 0 {
                        let above = Cell(name: name, r: r-1, c: c)
                        if grid[above] == nil {
                            content.append("\n    \(above) -> \(cell) [weight=100000000]")
                        }
                    }
                    if c > 0 {
                        let left = Cell(name: name, r: r, c: c-1)
                        if grid[left] == nil {
                            content.append("\n    rank = same {\(left) -> \(cell)}")
                        }
                    }

                }
            }
        }
    }
}
