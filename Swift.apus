// SWIFT 6 GRAMMAR

topLevelDeclaration = statements? .

// WHITESPACE AND COMMENT

whitespace : /\s+/.                                                     // simplified
//whitespace = whitespaceItem whitespace? .
//whitespaceItem = lineBreak .
//whitespaceItem = inlineSpace .
//whitespaceItem = comment .
//whitespaceItem = multilineComment .
//whitespaceItem = U+0000, U+000B, or U+000C.                           // NULL or \0 or \u{0000}, VERTICAL TAB or \u{000B}, or FORM FEED or \u{000C}

//lineBreak = U+000A                                                    // NEWLINE or \n or \u{000A}
//lineBreak = U+000D                                                    // CARRIAGE RETURN or \r or \u{000D}
//lineBreak = U+000D followed by U+000A

//inlineSpaces = inlineSpace inlineSpaces? .
//inlineSpace = U+0009 or U+0020                                        // HORIZONTAL TAB or \t or \u{0009}, SPACE or \u{0020}

comment : /\/\/.*\r?\n?/ .                                              // simplified
// comment = "//" commentText lineBreak .

multilineComment : /\/\*(?s).*?\*\// .                                  // simplified
//multilineComment = "/*" multilineCommentText "*/" .

//commentText = commentTextItem commentText? .
//commentTextItem = Any Unicode scalar value except U+000A or U+000D

//multilineCommentText = multilineCommentTextItem multilineCommentText? .
//multilineCommentTextItem = multilineComment .
//multilineCommentTextItem = commentTextItem .
//multilineCommentTextItem = Any Unicode scalar value except "/*" or "*/"


//IDENTIFIERS

plainIdentifier             = /\p{XID_Start}\p{XID_Continue}*/ .       // simplified
escapedIdentifier           = /`\p{XID_Start}\p{XID_Continue}*`/ .
implicitParameterName       = /\$[0-9]+/ .
propertyWrapperProjection   = /\$\p{XID_Continue}+/ .

identifier = "_" | plainIdentifier | escapedIdentifier | implicitParameterName | propertyWrapperProjection .

//identifier = identifierHead identifierCharacters? .
//identifier = "`" identifierHead identifierCharacters? "`" .
//identifier = implicitParameterName .
//identifier = propertyWrapperProjection .

identifierList = identifier | identifier "," identifierList .
//identifierList = identifier { "," identifier } .                      // EBNF

// these are included in XID_Start
//identifierHead = Upper or lowercase letter A through Z
//identifierHead = "_" .
//identifierHead = U+00A8, U+00AA, U+00AD, U+00AF, U+00B2‚ÄìU+00B5, or U+00B7‚ÄìU+00BA
//identifierHead = U+00BC‚ÄìU+00BE, U+00C0‚ÄìU+00D6, U+00D8‚ÄìU+00F6, or U+00F8‚ÄìU+00FF
//identifierHead = U+0100‚ÄìU+02FF, U+0370‚ÄìU+167F, U+1681‚ÄìU+180D, or U+180F‚ÄìU+1DBF
//identifierHead = U+1E00‚ÄìU+1FFF
//identifierHead = U+200B‚ÄìU+200D, U+202A‚ÄìU+202E, U+203F‚ÄìU+2040, U+2054, or U+2060‚ÄìU+206F
//identifierHead = U+2070‚ÄìU+20CF, U+2100‚ÄìU+218F, U+2460‚ÄìU+24FF, or U+2776‚ÄìU+2793
//identifierHead = U+2C00‚ÄìU+2DFF or U+2E80‚ÄìU+2FFF
//identifierHead = U+3004‚ÄìU+3007, U+3021‚ÄìU+302F, U+3031‚ÄìU+303F, or U+3040‚ÄìU+D7FF
//identifierHead = U+F900‚ÄìU+FD3D, U+FD40‚ÄìU+FDCF, U+FDF0‚ÄìU+FE1F, or U+FE30‚ÄìU+FE44
//identifierHead = U+FE47‚ÄìU+FFFD
//identifierHead = U+10000‚ÄìU+1FFFD, U+20000‚ÄìU+2FFFD, U+30000‚ÄìU+3FFFD, or U+40000‚ÄìU+4FFFD
//identifierHead = U+50000‚ÄìU+5FFFD, U+60000‚ÄìU+6FFFD, U+70000‚ÄìU+7FFFD, or U+80000‚ÄìU+8FFFD
//identifierHead = U+90000‚ÄìU+9FFFD, U+A0000‚ÄìU+AFFFD, U+B0000‚ÄìU+BFFFD, or U+C0000‚ÄìU+CFFFD
//identifierHead = U+D0000‚ÄìU+DFFFD or U+E0000‚ÄìU+EFFFD

// These are included in XID_Continue
//identifierCharacter = Digit 0 through 9
//identifierCharacter = U+0300‚ÄìU+036F, U+1DC0‚ÄìU+1DFF, U+20D0‚ÄìU+20FF, or U+FE20‚ÄìU+FE2F
//identifierCharacter = identifierHead .
//identifierCharacters = identifierCharacter identifierCharacters? .

//implicitParameterName = "$" decimalDigits .
//propertyWrapperProjection = "$" identifierCharacters .


// REGULAR EXPRESSIONS

plainRegularExpressionLiteral = /\/[^\s](?:(?:[^\/\\\s]|\\.)*[^\s])?\// .       // eliminates start or end whitespace, helps with / division sign
extendedRegularExpressionLiteral = /#+\/(?:[^\/\\]|\\.)+\/#+/ .                 // captures legal Swift regex already validated by the compiler
regularExpressionLiteral = plainRegularExpressionLiteral | extendedRegularExpressionLiteral .

//regularExpressionLiteral = regularExpressionLiteralOpeningDelimiter regularExpression regularExpressionLiteralClosingDelimiter .
//regularExpression = Any regular expression
//regularExpressionLiteralOpeningDelimiter = extendedRegularExpressionLiteralDelimiter? "/" .
//regularExpressionLiteralClosingDelimiter = "/" extendedRegularExpressionLiteralDelimiter? .
//extendedRegularExpressionLiteralDelimiter = "#" extendedRegularExpressionLiteralDelimiter? .




// STRINGS

// this is a catchall for staticStringLiteral and interpolatedStringLiteral (which includes staticStringLiteral), the parser will need to validate

//stringLiteral = /#*"(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"#*|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .

stringLiteral = /#*"(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .

//stringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"" .
//stringLiteralClosingDelimiter = "\"" extendedStringLiteralDelimiter? .

staticStringLiteral = stringLiteral .

//staticStringLiteral = /#*"(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .
//staticStringLiteral = stringLiteralOpeningDelimiter quotedText? stringLiteralClosingDelimiter .
//staticStringLiteral = multilineStringLiteralOpeningDelimiter multilineQuotedText? multilineStringLiteralClosingDelimiter .

//multilineStringLiteralOpeningDelimiter = extendedStringLiteralDelimiter? "\"\"\"" .
//multilineStringLiteralClosingDelimiter = "\"\"\"" extendedStringLiteralDelimiter? .
//extendedStringLiteralDelimiter = "#" extendedStringLiteralDelimiter? .

//quotedText = quotedTextItem quotedText? .
//quotedTextItem = escapedCharacter .
//quotedTextItem = Any Unicode scalar value except ", \, U+000A, or U+000D

//multilineQuotedText = multilineQuotedTextItem multilineQuotedText? .
//multilineQuotedTextItem = escapedCharacter .
//multilineQuotedTextItem = Any Unicode scalar value except \
//multilineQuotedTextItem = escapedNewline .

interpolatedStringLiteral = stringLiteral .
//interpolatedStringLiteral = /#*"(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|[^"\\\n\r])*"#*|#*"""(?:\\#*\([^)]*\)|\\#*[0\\tnr"']|\\#*u\{[0-9a-fA-F]{1,8}\}|\\#*\s*\n|[^\\])*"""#*/ .
//interpolatedStringLiteral = stringLiteralOpeningDelimiter interpolatedText? stringLiteralClosingDelimiter .
//interpolatedStringLiteral = multilineStringLiteralOpeningDelimiter multilineInterpolatedText? multilineStringLiteralClosingDelimiter .

//interpolatedText = interpolatedTextItem interpolatedText? .
//interpolatedTextItem = "\\(" expression ")" | quotedTextItem .

//multilineInterpolatedText = multilineInterpolatedTextItem multilineInterpolatedText? .
//multilineInterpolatedTextItem = "\\(" expression ")" | multilineQuotedTextItem .

//escapeSequence = "\\" extendedStringLiteralDelimiter .
//escapedCharacter = escapeSequence "0" | escapeSequence "\\" | escapeSequence "t" | escapeSequence "n" | escapeSequence "r" | escapeSequence """ | escapeSequence "'" .
//escapedCharacter = escapeSequence "u" "{" unicodeScalarDigits "}" .
//unicodeScalarDigits = Between one and eight hexadecimal digits

//escapedNewline = escapeSequence inlineSpaces? lineBreak .





// LITERALS

binaryLiteral = /-?0b[0-1][0-1_]*/ .
//binaryLiteral = "0b" binaryDigit binaryLiteralCharacters? .
//binaryDigit = Digit 0 or 1
//binaryLiteralCharacter = binaryDigit | "_" .
//binaryLiteralCharacters = binaryLiteralCharacter binaryLiteralCharacters? .

octalLiteral = /-?0o[0-7][0-7_]*/ .
//octalLiteral = "0o" octalDigit octalLiteralCharacters? .
//octalDigit = Digit 0 through 7
//octalLiteralCharacter = octalDigit | "_" .
//octalLiteralCharacters = octalLiteralCharacter octalLiteralCharacters? .

decimalNumber = /-?[0-9][0-9_]*/ .                                      // this is the catchall for decimalLiteral and decimalDigits
decimalLiteral = decimalNumber .
//decimalLiteral = decimalDigit decimalLiteralCharacters? .
//decimalDigit = Digit 0 through 9

decimalDigits = decimalNumber .                                         // parser to verify it matches /[0-9]+/ !!!
//decimalDigits = decimalDigit decimalDigits? .
//decimalLiteralCharacter = decimalDigit | "_" .
//decimalLiteralCharacters = decimalLiteralCharacter decimalLiteralCharacters? .

hexadecimalLiteral = /-?0x[0-9a-fA-F][0-9a-fA-F_]*/ .
//hexadecimalLiteral = "0x" hexadecimalDigit hexadecimalLiteralCharacters? .
//hexadecimalDigit = Digit 0 through 9, a through f, or A through F
//hexadecimalLiteralCharacter = hexadecimalDigit | "_" .
//hexadecimalLiteralCharacters = hexadecimalLiteralCharacter hexadecimalLiteralCharacters? .

decimalFloatingPointLiteral     = /-?[0-9][0-9_]*(?:\.[0-9][0-9_]*)(?:[eE][+-]?[0-9][0-9_]*)?/ .    // made the decimal fraction non-optional to avoid conflict with decimalDigits
//decimalFloatingPointLiteral     = /-?[0-9][0-9_]*(?:\.[0-9][0-9_]*)?(?:[eE][+-]?[0-9][0-9_]*)?/ .

hexadecimalFloatingPointLiteral = /-?0x[0-9a-fA-F][0-9a-fA-F_]*(?:\.[0-9a-fA-F][0-9a-fA-F_]*)?(?:[pP][+-]?[0-9][0-9_]*)/ .
//floatingPointLiteral = decimalLiteral decimalFraction? decimalExponent? .
//floatingPointLiteral = hexadecimalLiteral hexadecimalFraction? hexadecimalExponent .
floatingPointLiteral = decimalFloatingPointLiteral | hexadecimalFloatingPointLiteral .

//decimalFraction = "." decimalLiteral .
//decimalExponent = floatingPointE sign? decimalLiteral .

//hexadecimalFraction = "." hexadecimalDigit hexadecimalLiteralCharacters? .
//hexadecimalExponent = floatingPointP sign? decimalLiteral .

//floatingPointE = "e" | "E" .
//floatingPointP = "p" | "P" .
//sign = "+" | "-" .

literal = numericLiteral | stringLiteral | regularExpressionLiteral | booleanLiteral | nilLiteral .

numericLiteral = integerLiteral | floatingPointLiteral .
//numericLiteral = "-"? integerLiteral | "-"? floatingPointLiteral .
booleanLiteral = "true" | "false" .
nilLiteral = "nil" .

integerLiteral = binaryLiteral .
integerLiteral = octalLiteral .
integerLiteral = decimalLiteral .
integerLiteral = hexadecimalLiteral .




// OPERATORS

//simpleOperator = "/" | "=" | "-" | "+" | "!" | "*" | "%" | "<" | ">" | "&" | "|" | "^" | "~" | "?" .      // captured as literals used elsewhere ("/")
//compoundOperator = /[\/=+\-*%!&|^~?<>\p{Sm}\p{So}][\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]*/ .                // overlaps with simpleOperator, and literals win
plainOperator = /[\/=+\-*%!&|^~?<>\p{Sm}\p{So}][\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]*/ .                     // overlaps with literals like '/' and '='

dotOperator   = /\.[\.\/=+\-*%!&|^~?<>\p{Sm}\p{So}\p{Mn}]+/ .           // captures legal Swift operators already validated by the compiler

//plainOperator = simpleOperator | compoundOperator .
Operator = plainOperator | dotOperator .                                // capitalized to 'Operator' to avoid conflict with "operator" literal

//operator = operatorHead operatorCharacters? .
//operator = dotOperatorHead dotOperatorCharacters .


//operatorHead = "/" | "=" | "-" | "+" | "!" | "*" | "%" | "<" | ">" | "&" | "|" | "^" | "~" | "?" .
// Grok: the following characters are covered by Sm (Symbol, Math), and So (Symbol, Other).
//operatorHead = U+00A1‚ÄìU+00A7
//operatorHead = U+00A9 or U+00AB
//operatorHead = U+00AC or U+00AE
//operatorHead = U+00B0‚ÄìU+00B1
//operatorHead = U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7
//operatorHead = U+2016‚ÄìU+2017
//operatorHead = U+2020‚ÄìU+2027
//operatorHead = U+2030‚ÄìU+203E
//operatorHead = U+2041‚ÄìU+2053
//operatorHead = U+2055‚ÄìU+205E
//operatorHead = U+2190‚ÄìU+23FF
//operatorHead = U+2500‚ÄìU+2775
//operatorHead = U+2794‚ÄìU+2BFF
//operatorHead = U+2E00‚ÄìU+2E7F
//operatorHead = U+3001‚ÄìU+3003
//operatorHead = U+3008‚ÄìU+3020
//operatorHead = U+3030

//operatorCharacter = operatorHead .
// Grok: the following characters are covered by Mn (Mark, Nonspacing).
//operatorCharacter = U+0300‚ÄìU+036F
//operatorCharacter = U+1DC0‚ÄìU+1DFF
//operatorCharacter = U+20D0‚ÄìU+20FF
//operatorCharacter = U+FE00‚ÄìU+FE0F
//operatorCharacter = U+FE20‚ÄìU+FE2F
//operatorCharacter = U+E0100‚ÄìU+E01EF
//operatorCharacters = operatorCharacter operatorCharacters? .

//dotOperatorHead = "." .
//dotOperatorCharacter = "." | operatorCharacter .
//dotOperatorCharacters = dotOperatorCharacter dotOperatorCharacters? .

infixOperator = Operator .
prefixOperator = Operator .
postfixOperator = Operator .



// TYPES

type = functionType .
type = arrayType .
type = dictionaryType .
type = typeIdentifier .
type = tupleType .
type = optionalType .
type = implicitlyUnwrappedOptionalType .
type = protocolCompositionType .
type = opaqueType .
type = metatypeType .
type = anyType .
type = selfType .
type = "(" type ")" .

typeAnnotation = ":" attributes? "inout"? type .

typeIdentifier = typeName genericArgumentClause? | typeName genericArgumentClause? "." typeIdentifier .
typeName = identifier .

tupleType = "(" ")" | "(" tupleTypeElement "," tupleTypeElementList ")" .
tupleTypeElementList = tupleTypeElement | tupleTypeElement "," tupleTypeElementList .
tupleTypeElement = elementName typeAnnotation | type .
elementName = identifier .

functionType = attributes? functionTypeArgumentClause "async"? throwsClause? ">" type .

functionTypeArgumentClause = "(" ")" .
functionTypeArgumentClause = "(" functionTypeArgumentList "..."? ")" .

functionTypeArgumentList = functionTypeArgument | functionTypeArgument "," functionTypeArgumentList .
functionTypeArgument = attributes? "inout"? type | argumentLabel typeAnnotation .
argumentLabel = identifier .

throwsClause = "throws" | "throws" "(" type ")" .

arrayType = "[" type "]" .

dictionaryType = "[" type ":" type "]" .

optionalType = type "?" .

implicitlyUnwrappedOptionalType = type "!" .

protocolCompositionType = typeIdentifier "&" protocolCompositionContinuation .
protocolCompositionContinuation = typeIdentifier | protocolCompositionType .

opaqueType = "some" type .

boxedProtocolType = "any" type .

metatypeType = type "." "Type" | type "." "Protocol" .

anyType = "Any" .

selfType = "Self" .

typeInheritanceClause = ":" typeInheritanceList .
typeInheritanceList = attributes? typeIdentifier | attributes? typeIdentifier "," typeInheritanceList .



// EXPRESSIONS

expression = tryOperator? awaitOperator? prefixExpression infixExpressions? .  // WTF is this \ doing here?

prefixExpression = prefixOperator? postfixExpression .
prefixExpression = inOutExpression .

inOutExpression = "&" primaryExpression .

tryOperator = "try" | "try" "?" | "try" "!" .

awaitOperator = "await" .

infixExpression = infixOperator prefixExpression .
infixExpression = assignmentOperator tryOperator? awaitOperator? prefixExpression .
infixExpression = conditionalOperator tryOperator? awaitOperator? prefixExpression .
infixExpression = typeCastingOperator .
infixExpressions = infixExpression infixExpressions? .

assignmentOperator = "=" .

conditionalOperator = "?" expression ":" .

typeCastingOperator = "is" type .
typeCastingOperator = "as" type .
typeCastingOperator = "as" "?" type .
typeCastingOperator = "as" "!" type .

primaryExpression = identifier genericArgumentClause? .
primaryExpression = literalExpression .
primaryExpression = selfExpression .
primaryExpression = superclassExpression .
primaryExpression = conditionalExpression .
primaryExpression = closureExpression .
primaryExpression = parenthesizedExpression .
primaryExpression = tupleExpression .
primaryExpression = implicitMemberExpression .
primaryExpression = wildcardExpression .
primaryExpression = macroExpansionExpression .
primaryExpression = keyPathExpression .
primaryExpression = selectorExpression .
primaryExpression = keyPathStringExpression .

literalExpression = literal .
literalExpression = arrayLiteral | dictionaryLiteral | playgroundLiteral .

arrayLiteral = "[" arrayLiteralItems? "]" .
arrayLiteralItems = arrayLiteralItem ","? | arrayLiteralItem "," arrayLiteralItems .
arrayLiteralItem = expression .

dictionaryLiteral = "[" dictionaryLiteralItems "]" | "[" ":" "]" .
dictionaryLiteralItems = dictionaryLiteralItem ","? | dictionaryLiteralItem "," dictionaryLiteralItems .
dictionaryLiteralItem = expression ":" expression .

playgroundLiteral = "#colorLiteral" "(" "red" ":" expression "," "green" ":" expression "," "blue" ":" expression "," "alpha" ":" expression ")" .
playgroundLiteral = "#fileLiteral" "(" "resourceName" ":" expression ")" .
playgroundLiteral = "#imageLiteral" "(" "resourceName" ":" expression ")" .

selfExpression = "self" | selfMethodExpression | selfSubscriptExpression | selfInitializerExpression .

selfMethodExpression = "self" "." identifier .
selfSubscriptExpression = "self" "[" functionCallArgumentList "]" .
selfInitializerExpression = "self" "." "init" .

superclassExpression = superclassMethodExpression | superclassSubscriptExpression | superclassInitializerExpression .

superclassMethodExpression = "super" "." identifier .
superclassSubscriptExpression = "super" "[" functionCallArgumentList "]" .
superclassInitializerExpression = "super" "." "init" .

conditionalExpression = ifExpression | switchExpression .

ifExpression = "if" conditionList "{" statement "}" ifExpressionTail .
ifExpressionTail = "else" ifExpression .
ifExpressionTail = "else" "{" statement "}" .

switchExpression = "switch" expression "{" switchExpressionCases "}" .
switchExpressionCases = switchExpressionCase switchExpressionCases? .
switchExpressionCase = caseLabel statement .
switchExpressionCase = defaultLabel statement .

closureExpression = "{" attributes? closureSignature? statements? "}" .

closureSignature = captureList? closureParameterClause "async"? throwsClause? functionResult? "in" .
closureSignature = captureList "in" .

closureParameterClause = "(" ")" | "(" closureParameterList ")" | identifierList .
closureParameterList = closureParameter | closureParameter "," closureParameterList .
closureParameter = closureParameterName typeAnnotation? .
closureParameter = closureParameterName typeAnnotation "..." .
closureParameterName = identifier .

captureList = "[" captureListItems "]" .
captureListItems = captureListItem | captureListItem "," captureListItems .
captureListItem = captureSpecifier? identifier .
captureListItem = captureSpecifier? identifier "=" expression .
captureListItem = captureSpecifier? selfExpression .
captureSpecifier = "weak" | "unowned" | "unowned(safe)" | "unowned(unsafe)" .

implicitMemberExpression = "." identifier .
implicitMemberExpression = "." identifier "." postfixExpression .

parenthesizedExpression = "(" expression ")" .

tupleExpression = "(" ")" | "(" tupleElement "," tupleElementList ")" .
tupleElementList = tupleElement | tupleElement "," tupleElementList .
tupleElement = expression | identifier ":" expression .

wildcardExpression = "_" .

//macroExpansionExpression = "#" identifier genericArgumentClause? functionCallArgumentClause? trailingClosures? .
macroIdentifier = /#\p{XID_Start}\p{XID_Continue}*/ .
macroExpansionExpression = macroIdentifier genericArgumentClause? functionCallArgumentClause? trailingClosures? .

keyPathExpression = "\\" type? "." keyPathComponents .      // escape needed
//keyPathExpression = "\" type? "." keyPathComponents .
keyPathComponents = keyPathComponent | keyPathComponent "." keyPathComponents .
keyPathComponent = identifier keyPathPostfixes? | keyPathPostfixes .

keyPathPostfixes = keyPathPostfix keyPathPostfixes? .
keyPathPostfix = "?" | "!" | "self" | "[" functionCallArgumentList "]" .

selectorExpression = "#selector" "(" expression ")" .
selectorExpression = "#selector" "(" "getter:" expression ")" .
selectorExpression = "#selector" "(" "setter:" expression ")" .

keyPathStringExpression = "#keyPath" "(" expression ")" .

postfixExpression = primaryExpression .
postfixExpression = postfixExpression postfixOperator .
postfixExpression = functionCallExpression .
postfixExpression = initializerExpression .
postfixExpression = explicitMemberExpression .
postfixExpression = postfixSelfExpression .
postfixExpression = subscriptExpression .
postfixExpression = forcedValueExpression .
postfixExpression = optionalChainingExpression .

functionCallExpression = postfixExpression functionCallArgumentClause .
functionCallExpression = postfixExpression functionCallArgumentClause? trailingClosures .

functionCallArgumentClause = "(" ")" | "(" functionCallArgumentList ")" .
functionCallArgumentList = functionCallArgument | functionCallArgument "," functionCallArgumentList .
functionCallArgument = expression | identifier ":" expression .
functionCallArgument = Operator | identifier ":" Operator .

trailingClosures = closureExpression labeledTrailingClosures? .
labeledTrailingClosures = labeledTrailingClosure labeledTrailingClosures? .
labeledTrailingClosure = identifier ":" closureExpression .

initializerExpression = postfixExpression "." "init" .
initializerExpression = postfixExpression "." "init" "(" argumentNames ")" .

explicitMemberExpression = postfixExpression "." decimalDigits .
explicitMemberExpression = postfixExpression "." identifier genericArgumentClause? .
explicitMemberExpression = postfixExpression "." identifier "(" argumentNames ")" .
explicitMemberExpression = postfixExpression conditionalCompilationBlock .

argumentNames = argumentName argumentNames? .
argumentName = identifier ":" .

postfixSelfExpression = postfixExpression "." "self" .

subscriptExpression = postfixExpression "[" functionCallArgumentList "]" .

forcedValueExpression = postfixExpression "!" .

optionalChainingExpression = postfixExpression "?" .



// STATEMENTS

statement = expression ";"? .
statement = declaration ";"? .
statement = loopStatement ";"? .
statement = branchStatement ";"? .
statement = labeledStatement ";"? .
statement = controlTransferStatement ";"? .
statement = deferStatement ";"? .
statement = doStatement ";"? .
statement = compilerControlStatement .
statements = statement statements? .

loopStatement = forInStatement .
loopStatement = whileStatement .
loopStatement = repeatWhileStatement .

forInStatement = "for" "case"? pattern "in" expression whereClause? codeBlock .

whileStatement = "while" conditionList codeBlock .

conditionList = condition | condition "," conditionList .
condition = expression | availabilityCondition | caseCondition | optionalBindingCondition .

caseCondition = "case" pattern initializer .
optionalBindingCondition = "let" pattern initializer? | "var" pattern initializer? .

repeatWhileStatement = "repeat" codeBlock "while" expression .

branchStatement = ifStatement .
branchStatement = guardStatement .
branchStatement = switchStatement .

ifStatement = "if" conditionList codeBlock elseClause? .
elseClause = "else" codeBlock | "else" ifStatement .

guardStatement = "guard" conditionList "else" codeBlock .

switchStatement = "switch" expression "{" switchCases? "}" .
switchCases = switchCase switchCases? .
switchCase = caseLabel statements .
switchCase = defaultLabel statements .
switchCase = conditionalSwitchCase .

caseLabel = attributes? "case" caseItemList ":" .
caseItemList = pattern whereClause? | pattern whereClause? "," caseItemList .
defaultLabel = attributes? "default" ":" .

whereClause = "where" whereExpression .
whereExpression = expression .

conditionalSwitchCase = switchIfDirectiveClause switchElseifDirectiveClauses? switchElseDirectiveClause? endifDirective .
switchIfDirectiveClause = ifDirective compilationCondition switchCases? .
switchElseifDirectiveClauses = elseifDirectiveClause switchElseifDirectiveClauses? .
switchElseifDirectiveClause = elseifDirective compilationCondition switchCases? .
switchElseDirectiveClause = elseDirective switchCases? .

labeledStatement = statementLabel loopStatement .
labeledStatement = statementLabel ifStatement .
labeledStatement = statementLabel switchStatement .
labeledStatement = statementLabel doStatement .

statementLabel = labelName ":" .
labelName = identifier .

controlTransferStatement = breakStatement .
controlTransferStatement = continueStatement .
controlTransferStatement = fallthroughStatement .
controlTransferStatement = returnStatement .
controlTransferStatement = throwStatement .

breakStatement = "break" labelName? .

continueStatement = "continue" labelName? .

fallthroughStatement = "fallthrough" .

returnStatement = "return" expression? .

throwStatement = "throw" expression .

deferStatement = "defer" codeBlock .

doStatement = "do" throwsClause? codeBlock catchClauses? .
catchClauses = catchClause catchClauses? .
catchClause = "catch" catchPatternList? codeBlock .
catchPatternList = catchPattern | catchPattern "," catchPatternList .
catchPattern = pattern whereClause? .

compilerControlStatement = conditionalCompilationBlock .
compilerControlStatement = lineControlStatement .
compilerControlStatement = diagnosticStatement .

conditionalCompilationBlock = ifDirectiveClause elseifDirectiveClauses? elseDirectiveClause? endifDirective .

ifDirectiveClause = ifDirective compilationCondition statements? .
elseifDirectiveClauses = elseifDirectiveClause elseifDirectiveClauses? .
elseifDirectiveClause = elseifDirective compilationCondition statements? .
elseDirectiveClause = elseDirective statements? .
ifDirective = "#if" .
elseifDirective = "#elseif" .
elseDirective = "#else" .
endifDirective = "#endif" .

compilationCondition = platformCondition .
compilationCondition = identifier .
compilationCondition = booleanLiteral .
compilationCondition = "(" compilationCondition ")" .
compilationCondition = "!" compilationCondition .
compilationCondition = compilationCondition "&&" compilationCondition .
compilationCondition = compilationCondition "||" compilationCondition .

platformCondition = "os" "(" operatingSystem ")" .
platformCondition = "arch" "(" architecture ")" .
platformCondition = "swift" "(" ">=" swiftVersion ")" | "swift" "(" "<" swiftVersion ")" .
platformCondition = "compiler" "(" ">=" swiftVersion ")" | "compiler" "(" "<" swiftVersion ")" .
platformCondition = "canImport" "(" importPath ")" .
platformCondition = "targetEnvironment" "(" environment ")" .

operatingSystem = "macOS" | "iOS" | "watchOS" | "tvOS" | "visionOS" | "Linux" | "Windows" .
architecture = "i386" | "x86_64" | "arm" | "arm64" .
swiftVersion = decimalDigits swiftVersionContinuation? .
swiftVersionContinuation = "." decimalDigits swiftVersionContinuation? .
environment = "simulator" | "macCatalyst" .

lineNumber = decimalDigits .        // replace 'greater than zero' with parser post check'
//lineNumber = /0*[1-9][0-9]*/ .
lineControlStatement = "#sourceLocation" "(" "file:" filePath "," "line:" lineNumber ")" .
lineControlStatement = "#sourceLocation" "(" ")" .

//lineNumber = A decimal integer greater than zero .

filePath = staticStringLiteral .

diagnosticStatement = "#warning" "(" stringLiteral ")" | "#error" "(" stringLiteral ")" . // WTF missing, added as per Grok suggestion

availabilityCondition = "#available" "(" availabilityArguments ")" .
availabilityCondition = "#unavailable" "(" availabilityArguments ")" .
availabilityArguments = availabilityArgument | availabilityArgument "," availabilityArguments .
availabilityArgument = platformName platformVersion .
availabilityArgument = "*" .

platformName = "iOS" | "iOSApplicationExtension" .
platformName = "macOS" | "macOSApplicationExtension" .
platformName = "macCatalyst" | "macCatalystApplicationExtension" .
platformName = "watchOS" | "watchOSApplicationExtension" .
platformName = "tvOS" | "tvOSApplicationExtension" .
platformName = "visionOS" | "visionOSApplicationExtension" .
platformVersion = decimalDigits .
platformVersion = decimalDigits "." decimalDigits .
platformVersion = decimalDigits "." decimalDigits "." decimalDigits .



// DECLARATIONS

declaration = importDeclaration .
declaration = constantDeclaration .
declaration = variableDeclaration .
declaration = typealiasDeclaration .
declaration = functionDeclaration .
declaration = enumDeclaration .
declaration = structDeclaration .
declaration = classDeclaration .
declaration = actorDeclaration .
declaration = protocolDeclaration .
declaration = initializerDeclaration .
declaration = deinitializerDeclaration .
declaration = extensionDeclaration .
declaration = subscriptDeclaration .
declaration = operatorDeclaration .
declaration = precedenceGroupDeclaration . // WTF is \ doing here ???

codeBlock = "{" statements? "}" .

importDeclaration = attributes? "import" importKind? importPath .

importKind = "typealias" | "struct" | "class" | "enum" | "protocol" | "let" | "var" | "func" .
importPath = identifier | identifier "." importPath .

constantDeclaration = attributes? declarationModifiers? "let" patternInitializerList .

patternInitializerList = patternInitializer | patternInitializer "," patternInitializerList .
patternInitializer = pattern initializer? .
initializer = "=" expression .

variableDeclaration = variableDeclarationHead patternInitializerList .
variableDeclaration = variableDeclarationHead variableName typeAnnotation codeBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .
variableDeclaration = variableDeclarationHead variableName initializer willSetDidSetBlock .
variableDeclaration = variableDeclarationHead variableName typeAnnotation initializer? willSetDidSetBlock .

variableDeclarationHead = attributes? declarationModifiers? "var" .
variableName = identifier .

getterSetterBlock = codeBlock .
getterSetterBlock = "{" getterClause setterClause? "}" .
getterSetterBlock = "{" setterClause getterClause "}" .
getterClause = attributes? mutationModifier? "get" codeBlock .
setterClause = attributes? mutationModifier? "set" setterName? codeBlock .
setterName = "(" identifier ")" .

getterSetterKeywordBlock = "{" getterKeywordClause setterKeywordClause? "}" .
getterSetterKeywordBlock = "{" setterKeywordClause getterKeywordClause "}" .
getterKeywordClause = attributes? mutationModifier? "get" .
setterKeywordClause = attributes? mutationModifier? "set" .

willSetDidSetBlock = "{" willSetClause didSetClause? "}" .
willSetDidSetBlock = "{" didSetClause willSetClause? "}" .
willSetClause = attributes? "willSet" setterName? codeBlock .
didSetClause = attributes? "didSet" setterName? codeBlock .

typealiasDeclaration = attributes? accessLevelModifier? "typealias" typealiasName genericParameterClause? typealiasAssignment .
typealiasName = identifier .
typealiasAssignment = "=" type .

functionDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? functionBody? .

functionHead = attributes? declarationModifiers? "func" .
functionName = identifier | Operator .

functionSignature = parameterClause "async"? throwsClause? functionResult? .
functionSignature = parameterClause "async"? "rethrows" functionResult? .
functionResult = ">" attributes? type .
functionBody = codeBlock .

parameterClause = "(" ")" | "(" parameterList ")" .
parameterList = parameter | parameter "," parameterList .
parameter = externalParameterName? localParameterName parameterTypeAnnotation defaultArgumentClause? .
parameter = externalParameterName? localParameterName parameterTypeAnnotation .
parameter = externalParameterName? localParameterName parameterTypeAnnotation "..." .

externalParameterName = identifier .
localParameterName = identifier .
parameterTypeAnnotation = ":" attributes? parameterModifier? type .
parameterModifier = "inout" | "borrowing" | "consuming" .
defaultArgumentClause = "=" expression .

enumDeclaration = attributes? accessLevelModifier? unionStyleEnum .
enumDeclaration = attributes? accessLevelModifier? rawValueStyleEnum .

unionStyleEnum = "indirect"? "enum" enumName genericParameterClause? typeInheritanceClause? genericWhereClause? "{" unionStyleEnumMembers? "}" .
unionStyleEnumMembers = unionStyleEnumMember unionStyleEnumMembers? .
unionStyleEnumMember = declaration | unionStyleEnumCaseClause | compilerControlStatement .
unionStyleEnumCaseClause = attributes? "indirect"? "case" unionStyleEnumCaseList .
unionStyleEnumCaseList = unionStyleEnumCase | unionStyleEnumCase "," unionStyleEnumCaseList .
unionStyleEnumCase = enumCaseName tupleType? .
enumName = identifier .
enumCaseName = identifier .

rawValueStyleEnum = "enum" enumName genericParameterClause? typeInheritanceClause genericWhereClause? "{" rawValueStyleEnumMembers "}" .
rawValueStyleEnumMembers = rawValueStyleEnumMember rawValueStyleEnumMembers? .
rawValueStyleEnumMember = declaration | rawValueStyleEnumCaseClause | compilerControlStatement .
rawValueStyleEnumCaseClause = attributes? "case" rawValueStyleEnumCaseList .
rawValueStyleEnumCaseList = rawValueStyleEnumCase | rawValueStyleEnumCase "," rawValueStyleEnumCaseList .
rawValueStyleEnumCase = enumCaseName rawValueAssignment? .
rawValueAssignment = "=" rawValueLiteral .
rawValueLiteral = numericLiteral | staticStringLiteral | booleanLiteral .

structDeclaration = attributes? accessLevelModifier? "struct" structName genericParameterClause? typeInheritanceClause? genericWhereClause? structBody .
structName = identifier .
structBody = "{" structMembers? "}" .

structMembers = structMember structMembers? .
structMember = declaration | compilerControlStatement .

classDeclaration = attributes? accessLevelModifier? "final"? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .
classDeclaration = attributes? "final" accessLevelModifier? "class" className genericParameterClause? typeInheritanceClause? genericWhereClause? classBody .
className = identifier .
classBody = "{" classMembers? "}" .

classMembers = classMember classMembers? .
classMember = declaration | compilerControlStatement .

actorDeclaration = attributes? accessLevelModifier? "actor" actorName genericParameterClause? typeInheritanceClause? genericWhereClause? actorBody .
actorName = identifier .
actorBody = "{" actorMembers? "}" .

actorMembers = actorMember actorMembers? .
actorMember = declaration | compilerControlStatement .

protocolDeclaration = attributes? accessLevelModifier? "protocol" protocolName typeInheritanceClause? genericWhereClause? protocolBody .
protocolName = identifier .
protocolBody = "{" protocolMembers? "}" .

protocolMembers = protocolMember protocolMembers? .
protocolMember = protocolMemberDeclaration | compilerControlStatement .

protocolMemberDeclaration = protocolPropertyDeclaration .
protocolMemberDeclaration = protocolMethodDeclaration .
protocolMemberDeclaration = protocolInitializerDeclaration .
protocolMemberDeclaration = protocolSubscriptDeclaration .
protocolMemberDeclaration = protocolAssociatedTypeDeclaration .
protocolMemberDeclaration = typealiasDeclaration .

protocolPropertyDeclaration = variableDeclarationHead variableName typeAnnotation getterSetterKeywordBlock .

protocolMethodDeclaration = functionHead functionName genericParameterClause? functionSignature genericWhereClause? .

protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause throwsClause? genericWhereClause? .
protocolInitializerDeclaration = initializerHead genericParameterClause? parameterClause "rethrows" genericWhereClause? .

protocolSubscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .

protocolAssociatedTypeDeclaration = attributes? accessLevelModifier? "associatedtype" typealiasName typeInheritanceClause? typealiasAssignment? genericWhereClause? .

initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? throwsClause? genericWhereClause? initializerBody .
initializerDeclaration = initializerHead genericParameterClause? parameterClause "async"? "rethrows" genericWhereClause? initializerBody .
initializerHead = attributes? declarationModifiers? "init" .
initializerHead = attributes? declarationModifiers? "init" "?" .
initializerHead = attributes? declarationModifiers? "init" "!" .
initializerBody = codeBlock .

deinitializerDeclaration = attributes? "deinit" codeBlock .

extensionDeclaration = attributes? accessLevelModifier? "extension" typeIdentifier typeInheritanceClause? genericWhereClause? extensionBody .
extensionBody = "{" extensionMembers? "}" .

extensionMembers = extensionMember extensionMembers? .
extensionMember = declaration | compilerControlStatement .

subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? codeBlock .
subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterBlock .
subscriptDeclaration = subscriptHead subscriptResult genericWhereClause? getterSetterKeywordBlock .
subscriptHead = attributes? declarationModifiers? "subscript" genericParameterClause? parameterClause .
subscriptResult = ">" attributes? type .

macroDeclaration = macroHead identifier genericParameterClause? macroSignature macroDefinition? genericWhereClause .
macroHead = attributes? declarationModifiers? "macro" .
macroSignature = parameterClause macroFunctionSignatureResult? .
macroFunctionSignatureResult = ">" type .
macroDefinition = "=" expression .

operatorDeclaration = prefixOperatorDeclaration | postfixOperatorDeclaration | infixOperatorDeclaration .

prefixOperatorDeclaration = "prefix" "operator" Operator .
postfixOperatorDeclaration = "postfix" "operator" Operator .
infixOperatorDeclaration = "infix" "operator" Operator infixOperatorGroup? .

infixOperatorGroup = ":" precedenceGroupName .

precedenceGroupDeclaration = "precedencegroup" precedenceGroupName "{" precedenceGroupAttributes? "}" .

precedenceGroupAttributes = precedenceGroupAttribute precedenceGroupAttributes? .
precedenceGroupAttribute = precedenceGroupRelation .
precedenceGroupAttribute = precedenceGroupAssignment .
precedenceGroupAttribute = precedenceGroupAssociativity .

precedenceGroupRelation = "higherThan" ":" precedenceGroupNames .
precedenceGroupRelation = "lowerThan" ":" precedenceGroupNames .

precedenceGroupAssignment = "assignment" ":" booleanLiteral .

precedenceGroupAssociativity = "associativity" ":" "left" .
precedenceGroupAssociativity = "associativity" ":" "right" .
precedenceGroupAssociativity = "associativity" ":" "none" .

precedenceGroupNames = precedenceGroupName | precedenceGroupName "," precedenceGroupNames .
precedenceGroupName = identifier .

declarationModifier = "class" | "convenience" | "dynamic" | "final" | "infix" | "lazy" | "optional" | "override" | "postfix" | "prefix" | "required" | "static" | "unowned" | "unowned" "(" "safe" ")" | "unowned" "(" "unsafe" ")" | "weak" .
declarationModifier = accessLevelModifier .
declarationModifier = mutationModifier .
declarationModifier = actorIsolationModifier .
declarationModifiers = declarationModifier declarationModifiers? .

accessLevelModifier = "private" | "private" "(" "set" ")" .
accessLevelModifier = "fileprivate" | "fileprivate" "(" "set" ")" .
accessLevelModifier = "internal" | "internal" "(" "set" ")" .
accessLevelModifier = "package" | "package" "(" "set" ")" .
accessLevelModifier = "public" | "public" "(" "set" ")" .
accessLevelModifier = "open" | "open" "(" "set" ")" .

mutationModifier = "mutating" | "nonmutating" .

actorIsolationModifier = "nonisolated" .



// ATTRIBUTES

attribute = "@" attributeName attributeArgumentClause? .
attributeName = identifier .
attributeArgumentClause = "(" balancedTokens? ")" .
attributes = attribute attributes? .

//keyword = "actor" | "associatedtype" | "class" | "deinit" | "enum" | "extension" | "fileprivate" | "func" | "import" | "init" | "inout" | "internal" | "let" | "open" | "operator" | "private" | "precedencegroup" | "protocol" | "public" | "rethrows" | "static" | "struct" | "subscript" | "typealias" | "var" | "break" | "case" | "catch" | "continue" | "default" | "defer" | "do" | "else" | "fallthrough" | "for" | "guard" | "if" | "in" | "repeat" | "return" | "switch" | "throw" | "try" | "where" | "while" | "Any" | "as" | "borrowing" | "consuming" | "copy" | "discard" | "false" | "is" | "move" | "nil" | "self" | "Self" | "super" | "throws" | "true" | "_unsafeInheritExecutor" | "_" | "each" | "associativity" | "convenience" | "didSet" | "dynamic" | "final" | "get" | "higherThan" | "indirect" | "lazy" | "left" | "lowerThan" | "mutating" | "nonmutating" | "none" | "optional" | "override" | "postfix" | "prefix" | "required" | "right" | "set" | "some" | "unowned" | "weak" | "willSet" | "#available" | "#colorLiteral" | "#column" | "#dsohandle" | "#elseif" | "#else" | "#endif" | "#error" | "#file" | "#fileID" | "#fileLiteral" | "#filePath" | "#function" | "#if" | "#imageLiteral" | "#keyPath" | "#line" | "#selector" | "#sourceLocation" | "#unavailable" | "#warning" | "(" | ")" | "{" | "}" | "[" | "]" | "." | "," | ":" | ";" | "=" | "@" | "#" | "&" | "?" | "!" | "<" | ">" | "|" | "^" | "~" | "%" | "*" | "+" | "-" | "/" | "isolated" | "nonisolated" | "async" | "await" | "yield" | "package" .


keywordMinusBrackets = "actor" | "associatedtype" | "class" | "deinit" | "enum" | "extension" | "fileprivate" | "func" | "import" | "init" | "inout" | "internal" | "let" | "open" | "operator" | "private" | "precedencegroup" | "protocol" | "public" | "rethrows" | "static" | "struct" | "subscript" | "typealias" | "var" | "break" | "case" | "catch" | "continue" | "default" | "defer" | "do" | "else" | "fallthrough" | "for" | "guard" | "if" | "in" | "repeat" | "return" | "switch" | "throw" | "try" | "where" | "while" | "Any" | "as" | "borrowing" | "consuming" | "copy" | "discard" | "false" | "is" | "move" | "nil" | "self" | "Self" | "super" | "throws" | "true" | "_unsafeInheritExecutor" | "_" | "each" | "associativity" | "convenience" | "didSet" | "dynamic" | "final" | "get" | "higherThan" | "indirect" | "lazy" | "left" | "lowerThan" | "mutating" | "nonmutating" | "none" | "optional" | "override" | "postfix" | "prefix" | "required" | "right" | "set" | "some" | "unowned" | "weak" | "willSet" | "#available" | "#colorLiteral" | "#elseif" | "#else" | "#endif" | "#error" | "#fileLiteral" | "#if" | "#imageLiteral" | "#keyPath" | "#selector" | "#sourceLocation" | "#unavailable" | "#warning" | "." | "," | ":" | ";" | "=" | "@" | "#" | "&" | "?" | "!" | "<" | ">" | "|" | "^" | "~" | "%" | "*" | "+" | "-" | "/" | "isolated" | "nonisolated" | "async" | "await" | "yield" | "package" .

balancedToken = identifier | keywordMinusBrackets | literal | Operator .
//balancedToken = Any identifier, keyword, literal, or operator .
//balancedToken = Any punctuation except (, ), [, ], {, or } .

balancedTokens = balancedToken balancedTokens? .

balancedToken = "(" balancedTokens? ")" .
balancedToken = "[" balancedTokens? "]" .
balancedToken = "{" balancedTokens? "}" .


// PATTERNS

pattern = wildcardPattern typeAnnotation? .
pattern = identifierPattern typeAnnotation? .
pattern = valueBindingPattern .
pattern = tuplePattern typeAnnotation? .
pattern = enumCasePattern .
pattern = optionalPattern .
pattern = typeCastingPattern .
pattern = expressionPattern .

wildcardPattern = "_" .

identifierPattern = identifier .

valueBindingPattern = "var" pattern | "let" pattern .               // WTF  'let let' pattern is not allowed by compiler

tuplePattern = "(" tuplePatternElementList? ")" .
tuplePatternElementList = tuplePatternElement | tuplePatternElement "," tuplePatternElementList .
tuplePatternElement = pattern | identifier ":" pattern .

enumCasePattern = typeIdentifier? "." enumCaseName tuplePattern? .

optionalPattern = identifierPattern "?" .

typeCastingPattern = isPattern | asPattern .
isPattern = "is" type .
asPattern = pattern "as" type .

expressionPattern = expression .


// GENERIC PARAMETERS AND ARGUMENTS

genericParameterClause = "<" genericParameterList ">" .
genericParameterList = genericParameter | genericParameter "," genericParameterList .
genericParameter = typeName .
genericParameter = typeName ":" typeIdentifier .
genericParameter = typeName ":" protocolCompositionType .

genericWhereClause = "where" requirementList .
requirementList = requirement | requirement "," requirementList .
requirement = conformanceRequirement | sameTypeRequirement .

conformanceRequirement = typeIdentifier ":" typeIdentifier .
conformanceRequirement = typeIdentifier ":" protocolCompositionType .
sameTypeRequirement = typeIdentifier "==" type .

genericArgumentClause = "<" genericArgumentList ">" .
genericArgumentList = genericArgument | genericArgument "," genericArgumentList .
genericArgument = type .

^^^
//class c: p {                          // FAIL with Swift.apus
//    func f () -> Int {}
//}
//
//  GraphStructuredStack.swift
//  Advent
//
//  Created by Johannes Brands on 26/12/2024.
//

final class StackNode: Hashable, CustomStringConvertible, Comparable {
    let slot: GrammarNode
    let index: Int
    // Afroozeh: set can be array
    //    var edges: [Edge] = []
    //    var edges: Set<Edge> = []
//    var edges: Set<StackNode> = []
    var edges: [StackNode] = []
    var pops: Set<Int> = []
    var unique: Set<SlotIndex> = []
    
    init(slot: GrammarNode, index: Int) {
        self.slot = slot
        self.index = index
    }
    static func == (lhs: StackNode, rhs: StackNode) -> Bool {
        lhs.slot == rhs.slot && lhs.index == rhs.index
    }
    func hash(into hasher: inout Hasher) {
        hasher.combine(slot)
        hasher.combine(index)
    }
    var description: String {
        if slot.kind == .EOS { return "‚óè‚óã" }
        //        return slot.description + "," + index.description
        return slot.description + index.description
    }
    static func < (lhs: StackNode, rhs: StackNode) -> Bool {
        lhs.description < rhs.description
    }
}

// TODO: simplify!  does Edge need all this?
//struct Edge: CustomStringConvertible, Comparable {
struct Edge: Hashable, CustomStringConvertible, Comparable {
    let towards: StackNode
    //    var dummy: [GrammarNode] = []
    init(towards: StackNode) {
        self.towards = towards
    }
    //    static func == (lhs: Edge, rhs: Edge) -> Bool {
    //        lhs.towards == rhs.towards
    //    }
    //    func hash(into hasher: inout Hasher) {
    //        hasher.combine(towards)
    //    }
    var description: String {
        towards.description
    }
    static func < (lhs: Edge, rhs: Edge) -> Bool {
        lhs.towards < rhs.towards
    }
}

struct Descriptor: Hashable {
    let slot: GrammarNode
    let stack: StackNode
    let index: Int
}

var U: Set<Descriptor> = []
var R: [Descriptor] = []

// TODO: replace with tuple?
struct SlotIndex: Hashable, CustomStringConvertible {
    let slot: GrammarNode
    let index: Int
    var description: String { slot.description + index.description }
}

//struct BSR: Hashable, CustomStringConvertible {
//    let node: GrammarNode
//    let i: Int  // left
//    let k: Int  // pivot
//    let j: Int  // right
//    var description: String { "\(node) \(i):\(k):\(j)" }
//}
//
//var yield : Set<BSR> = []   // currentYield_Cn_œí_ùõ∂_BSR

// create a GSS node if it doesn't already exist
// add an edge from that node to the current stack top
// add descriptors for previous pop actions from v
func call(slot: GrammarNode) {
    #if DEBUG
    trace("call", slot)
    #endif
    let node = StackNode(slot: slot.seq!, index: currentIndex)
    let actualNode = gss.insert(node).memberAfterInsert
    //    let edge = Edge(towards: currentStack)
    #if DEBUG
    trace("create edge from \(actualNode) to \(currentStack)")
    #endif

    // TODO: change edges from array to set
    assert(!actualNode.edges.contains(currentStack), "Afroozeh was wrong, edge \(currentStack.slot.seq!.str) was already in node \(actualNode.slot.seq!.str) \(actualNode.edges)")
    //        assert(!actualNode.edges.contains(edge), "Afroozeh was wrong, edge \(edge) was already in node \(actualNode) \(actualNode.edges)")
    //    assert(!actualNode.edges.contains(where: { $0.towards === currentStack }), "Afroozeh was wrong, edge \(edge) was already in node \(actualNode) \(actualNode.edges)")
    //    actualNode.edges.append(edge)
    //    print("inserting \(edge) into \(actualNode) (\(actualNode.edges))")
    //    actualNode.edges.insert(edge)
//    actualNode.edges.insert(currentStack)
    actualNode.edges.append(currentStack)

    trace = false
    for pop in actualNode.pops {
    #if DEBUG
        trace("contingent Descriptor")
    #endif
        addDescriptor(slot: slot.seq!, stack: currentStack, index: pop)
    }
    trace = false
    
    // TODO: iterate over all ALT nodes in parseMessage
    var current = slot
    while let next = current.alt, let seq = next.seq {
        addDescriptor(slot: seq, stack: actualNode, index: currentIndex)
        current = next
    }
}

func enter() {
    trace("enter", currentSlot)
    let node = StackNode(slot: currentSlot.seq!, index: currentIndex)
    let actualNode = gss.insert(node).memberAfterInsert
    trace("create edge from \(actualNode) to \(currentStack)")
//    actualNode.edges.insert(currentStack)
    actualNode.edges.append(currentStack)
    for pop in actualNode.pops {
        trace("contingent Descriptor")
        addDescriptor(slot: currentSlot.seq!, stack: currentStack, index: pop)
    }
    // TODO: iterate over all ALT nodes in parseMessage
    while let next = currentSlot.alt, let seq = next.seq {
        if testSelect() {
            addDescriptor(slot: seq, stack: actualNode, index: currentIndex)
        }
        currentSlot = next
    }
}

// TODO: the first edge can be popped without addDescriptor
func ret() {
    #if DEBUG
    trace("ret", currentStack)
    if currentIndex == tokens.count - 1 && currentStack == gssRoot {
        successfullParses += 1
        trace("HURRAH token = \(token)", terminator: "\n")
    } else {
        currentStack.pops.insert(currentIndex)
        for edge in currentStack.edges {
            trace("pop \(edge)")
            //            addDescriptor(slot: currentStack.slot, stack: edge.towards, index: currentIndex)
            addDescriptor(slot: currentStack.slot, stack: edge, index: currentIndex)
        }
    }
    #else
    if currentIndex == tokens.count - 1 && currentStack == gssRoot {
        successfullParses += 1
    } else {
        currentStack.pops.insert(currentIndex)
        for edge in currentStack.edges {
            //            addDescriptor(slot: currentStack.slot, stack: edge.towards, index: currentIndex)
            addDescriptor(slot: currentStack.slot, stack: edge, index: currentIndex)
        }
    }
    #endif
}

// TODO: the first edge can be popped without addDescriptor
func leave() {
    #if DEBUG
    trace("leave", currentStack)
    if currentIndex == tokens.count - 1 && currentStack == gssRoot {
        successfullParses += 1
        trace("HURRAH token = \(token)", terminator: "\n")
    } else {
        currentStack.pops.insert(currentIndex)
        for edge in currentStack.edges {
            trace("pop \(edge)")
            //            addDescriptor(slot: currentStack.slot, stack: edge.towards, index: currentIndex)
            addDescriptor(slot: currentStack.slot, stack: edge, index: currentIndex)
        }
    }
    #else
    if currentIndex == tokens.count - 1 && currentStack == gssRoot {
        successfullParses += 1
    } else {
        currentStack.pops.insert(currentIndex)
        for edge in currentStack.edges {
            //            addDescriptor(slot: currentStack.slot, stack: edge.towards, index: currentIndex)
            addDescriptor(slot: currentStack.slot, stack: edge, index: currentIndex)
        }
    }
    #endif
}

func addDescriptor(slot: GrammarNode, stack: StackNode, index: Int) {
//    let d = Descriptor(slot: slot, stack: stack, index: index)
//    if U.insert(d).inserted {
//        R.append(d)
//    }
    if stack.unique.insert(SlotIndex(slot: slot, index: index)).inserted {
        remainder.append(Descriptor(slot: slot, stack: stack, index: index))
        descriptorCount += 1
        #if DEBUG
        trace("add Descriptor(slot \(slot), stack \(stack), index \(index))")
        #endif
    } else {
        #if DEBUG
        trace("duplicate Descriptor(slot \(slot), stack \(stack), index \(index))")
        #endif
        duplicateDescriptorCount += 1
    }
}

func getDescriptor() -> Bool {
//    if R.isEmpty {
//        return false
//    } else {
//        let d = R.removeLast()
//        currentSlot = d.slot
//        currentStack = d.stack
//        currentIndex = d.index
//        return true
//
//    }
    if remainder.isEmpty {
        return false
    } else {
        let d = remainder.removeLast()
        currentSlot = d.slot
        currentStack = d.stack
        currentIndex = d.index
        #if DEBUG
        trace("get Descriptor(slot \(currentSlot), stack \(currentStack), index \(currentIndex))")
        #endif
        return true
    }
}
